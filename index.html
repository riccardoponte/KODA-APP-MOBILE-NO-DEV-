<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Koda</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap');

        /* --- STILE CSS ISPIRATO A SPOTIFY (Completo e Funzionante) --- */
        :root {
            --spotify-bg: #121212;
            --spotify-bg-light: #181818;
            --spotify-card: #282828;
            --spotify-ai-bubble-bg: #3e3e3e;
            /* NUOVO: Colore distinto per le bolle di testo dell'AI in dark mode */
            --spotify-text: #ffffff;
            --spotify-text-secondary: #b3b3b3;
            --spotify-accent: #1db954;
            --font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            --bottom-nav-height: 70px;
        }

        /* NUOVO: Stili per la modalità Giorno (Light Mode) */
        body.light-mode {
            --spotify-bg: #ffffff;
            --spotify-bg-light: #f5f5f5;
            --spotify-card: #e9e9e9;
            --spotify-ai-bubble-bg: #e9e9e9;
            /* NUOVO: In light mode, le bolle AI usano un grigio chiaro */
            --spotify-text: #121212;
            --spotify-text-secondary: #535353;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            font-family: var(--font-family);
            background-color: var(--spotify-bg);
            color: var(--spotify-text);
            height: 100%;
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Stili per la schermata di autenticazione */
        #auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--spotify-bg);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s, visibility 0.5s;
            padding: 20px;
        }

        #auth-overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .auth-logo {
            width: 80px;
            height: 80px;
            margin-bottom: 24px;
            fill: var(--spotify-accent);
        }

        .auth-card {
            background: var(--spotify-card);
            padding: 32px 24px;
            border-radius: 16px;
            width: 100%;
            max-width: 400px;
            text-align: center;
            position: relative;
        }

        .auth-close-btn {
            position: absolute;
            top: 8px;
            left: 12px;
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
        }

        .auth-card h2 {
            font-size: 24px;
            margin-bottom: 24px;
        }

        .auth-card .input-group {
            margin-bottom: 16px;
            text-align: left;
        }

        .auth-card label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .auth-card input {
            width: 100%;
            padding: 14px 16px;
            font-size: 16px;
            background-color: var(--spotify-bg-light);
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 8px;
            color: var(--spotify-text);
        }

        .auth-card input::placeholder {
            color: #888;
        }

        .auth-card .button {
            width: 100%;
            margin-top: 16px;
        }

        .auth-links {
            margin-top: 24px;
        }

        .auth-switch-link,
        .forgot-password-link {
            color: var(--spotify-text-secondary);
            text-decoration: none;
            cursor: pointer;
            font-size: 14px;
            transition: color 0.2s;
        }

        .auth-switch-link:hover,
        .forgot-password-link:hover {
            color: var(--spotify-text);
            text-decoration: underline;
        }

        .forgot-password-link {
            display: block;
            margin-top: 12px;
        }

        .auth-card.hidden {
            display: none;
        }

        #app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #main-content {
            flex: 1;
            overflow-y: auto;
            padding-bottom: var(--bottom-nav-height);
        }

        /* NUOVO: Blocca lo scroll della pagina quando la welcome screen del chatbot è visibile */
        #main-content:has(#welcome-screen) {
            overflow-y: hidden;
        }

        .top-bar {
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, var(--spotify-bg) 70%, transparent);
            z-index: 10;
            width: 100%;
        }

        .page-title {
            font-size: 22px;
            font-weight: 700;
            flex-grow: 1;
            color: var(--spotify-text);
            margin: 0;
        }

        #global-controls {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .global-btn {
            background: none;
            border: none;
            color: var(--spotify-text);
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s ease;
        }

        .global-btn:hover {
            color: var(--spotify-accent);
        }

        #lang-toggle-btn {
            font-size: 14px;
            font-weight: bold;
            background: var(--spotify-card);
            border-radius: 50px;
            padding: 6px 10px;
            transition: background-color 0.2s ease;
        }

        #lang-toggle-btn:hover {
            background: var(--spotify-bg-light);
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--spotify-accent);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            object-fit: cover;
            color: black;
            position: relative;
            transition: transform 0.2s ease;
        }

        .user-avatar:hover {
            transform: scale(1.05);
        }

        /* User Profile Dropdown Menu */
        .user-profile-container {
            position: relative;
            display: inline-block;
        }

        .user-profile-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            /* MODIFICA: Allineato a sinistra invece che a destra per la responsività */
            margin-top: 8px;
            background-color: var(--spotify-card);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            border: 1px solid rgba(128, 128, 128, 0.2);
        }

        .user-profile-dropdown.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .user-profile-header {
            padding: 16px;
            border-bottom: 1px solid rgba(128, 128, 128, 0.2);
            text-align: center;
        }

        .user-profile-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--spotify-accent);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 20px;
            margin: 0 auto 8px;
            color: black;
        }

        .user-profile-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--spotify-text);
            margin-bottom: 4px;
        }

        .user-profile-email {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        .user-profile-menu {
            padding: 8px 0;
        }

        .user-profile-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            color: var(--spotify-text);
            text-decoration: none;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .user-profile-item:hover {
            background-color: var(--spotify-bg-light);
        }

        .user-profile-item svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .user-profile-divider {
            height: 1px;
            background-color: rgba(128, 128, 128, 0.2);
            margin: 8px 0;
        }

        .user-profile-logout {
            color: #ff6b6b;
        }

        .user-profile-logout:hover {
            background-color: rgba(255, 107, 107, 0.1);
        }

        /* Responsive adjustments for mobile */
        @media (max-width: 768px) {
            .user-profile-dropdown {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                margin: 0;
                border-radius: 12px 12px 0 0;
                min-width: auto;
                max-height: 80vh;
                overflow-y: auto;
            }

            .user-profile-dropdown.visible {
                transform: translateY(0);
            }

            .user-profile-header {
                padding: 20px 16px;
            }

            .user-profile-avatar {
                width: 56px;
                height: 56px;
                font-size: 24px;
            }

            .user-profile-name {
                font-size: 18px;
            }

            .user-profile-item {
                padding: 16px;
                font-size: 16px;
            }

            .user-profile-item svg {
                width: 20px;
                height: 20px;
            }
        }

        @media (max-width: 480px) {
            .top-bar {
                padding: 12px 16px;
            }

            .page-title {
                font-size: 18px;
            }

            .user-avatar {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }

            .user-profile-dropdown {
                max-height: 70vh;
            }

            .user-profile-header {
                padding: 16px;
            }

            .user-profile-avatar {
                width: 48px;
                height: 48px;
                font-size: 20px;
            }

            .user-profile-item {
                padding: 14px 16px;
                font-size: 15px;
            }

            .global-btn {
                font-size: 20px;
                padding: 6px;
            }

            #lang-toggle-btn {
                font-size: 12px;
                padding: 4px 8px;
            }
        }


        .filters-container {
            padding: 8px 16px;
            position: sticky;
            top: 64px;
            background-color: var(--spotify-bg);
            z-index: 9;
        }

        .filter-pills {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .filter-pills::-webkit-scrollbar {
            display: none;
        }

        .pill-btn {
            background-color: var(--spotify-card);
            color: var(--spotify-text);
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 50px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.2s, color 0.2s;
        }

        .pill-btn.active {
            background-color: var(--spotify-text);
            color: var(--spotify-bg);
            font-weight: bold;
        }

        body.light-mode .pill-btn.active {
            color: var(--spotify-bg);
            background-color: #333;
        }

        /* NUOVO: Stili per l'icona mostra/nascondi password */
        .password-input-wrapper {
            position: relative;
        }

        .password-toggle-icon {
            position: absolute;
            top: 50%;
            right: 16px;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            color: var(--spotify-text-secondary);
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .password-toggle-icon svg {
            width: 20px;
            height: 20px;
        }

        #content-area {
            padding: 16px;
        }

        .section-title {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 20px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        .tool-card-grid {
            background: none;
            cursor: pointer;
        }

        .tool-card-grid .logo-container {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            background-color: var(--spotify-card);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            /* Needed for absolute positioning of edit icon */
        }

        .tool-card-grid .tool-logo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .tool-card-grid .tool-name {
            font-size: 14px;
            font-weight: 600;
            line-height: 1.3;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        /* NUOVO: Stile per la card "+" per aggiungere app */
        .add-app-card {
            display: flex;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            border: 2px dashed var(--spotify-text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .add-app-card:hover {
            border-color: var(--spotify-accent);
            background-color: var(--spotify-card);
        }

        .add-app-card svg {
            width: 40px;
            height: 40px;
            fill: var(--spotify-text-secondary);
            transition: all 0.2s ease;
        }

        .add-app-card:hover svg {
            fill: var(--spotify-accent);
            transform: scale(1.1);
        }

        .list-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .tool-card-list {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
        }

        .tool-card-list .logo-container {
            width: 56px;
            height: 56px;
            flex-shrink: 0;
            background-color: var(--spotify-card);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            /* Needed for absolute positioning of edit icon */
        }

        .tool-card-list .tool-logo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .tool-card-list .info {
            flex-grow: 1;
        }

        .tool-card-list .tool-name {
            font-size: 16px;
            font-weight: 500;
        }

        .tool-card-list .tool-subtext {
            font-size: 13px;
            color: var(--spotify-text-secondary);
        }

        .tool-card-list .favorite-icon {
            font-size: 22px;
            color: var(--spotify-accent);
            margin-left: auto;
            padding: 10px;
            cursor: pointer;
        }

        /* NUOVO: Stili per il sistema di recensioni e valutazioni */
        .rating-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .stars-display {
            display: flex;
            gap: 2px;
        }

        .star {
            font-size: 14px;
            color: #ffd700;
        }

        .star.empty {
            color: var(--spotify-text-secondary);
        }

        .rating-text {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        .reviews-section {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid rgba(128, 128, 128, 0.2);
        }

        .reviews-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .reviews-title {
            font-size: 18px;
            font-weight: 600;
        }

        .add-review-btn {
            background-color: var(--spotify-accent);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .add-review-btn:hover {
            background-color: #1ed760;
        }

        .add-review-btn:disabled {
            background-color: var(--spotify-text-secondary);
            cursor: not-allowed;
        }

        .review-item {
            background-color: var(--spotify-bg-light);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            border: 1px solid rgba(128, 128, 128, 0.1);
        }

        .review-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .review-user {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .review-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--spotify-accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: #000;
        }

        .review-user-info {
            display: flex;
            flex-direction: column;
        }

        .review-username {
            font-size: 14px;
            font-weight: 600;
        }

        .review-date {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        .review-rating {
            display: flex;
            gap: 2px;
        }

        .review-text {
            font-size: 14px;
            line-height: 1.5;
            color: var(--spotify-text);
        }

        .no-reviews {
            text-align: center;
            color: var(--spotify-text-secondary);
            padding: 24px;
            font-style: italic;
        }

        /* Modal per aggiungere recensione */
        .review-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .review-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .review-modal-content {
            background: var(--spotify-card);
            padding: 24px;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            position: relative;
        }

        .review-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .review-modal-title {
            font-size: 20px;
            font-weight: 600;
        }

        .review-modal-close {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
        }

        .rating-input-container {
            margin-bottom: 20px;
        }

        .rating-input-label {
            display: block;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .stars-input {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .star-input {
            font-size: 24px;
            color: var(--spotify-text-secondary);
            cursor: pointer;
            transition: color 0.2s;
        }

        .star-input:hover,
        .star-input.active {
            color: #ffd700;
        }

        .review-text-container {
            margin-bottom: 24px;
        }

        .review-text-label {
            display: block;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .review-text-input {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 8px;
            background-color: var(--spotify-bg-light);
            color: var(--spotify-text);
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }

        .review-text-input::placeholder {
            color: var(--spotify-text-secondary);
        }

        .review-modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .review-cancel-btn {
            background: none;
            border: 1px solid var(--spotify-text-secondary);
            color: var(--spotify-text);
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .review-cancel-btn:hover {
            background-color: var(--spotify-bg-light);
        }

        .review-submit-btn {
            background-color: var(--spotify-accent);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .review-submit-btn:hover {
            background-color: #1ed760;
        }

        .review-submit-btn:disabled {
            background-color: var(--spotify-text-secondary);
            cursor: not-allowed;
        }

        /* Sent Reviews Modal Styles */
        .sent-reviews-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .sent-reviews-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .sent-reviews-modal-content {
            background: var(--spotify-card);
            padding: 24px;
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .sent-reviews-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(128, 128, 128, 0.2);
        }

        .sent-reviews-modal-title {
            font-size: 20px;
            font-weight: 600;
        }

        .sent-reviews-modal-close {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
        }

        .sent-review-item {
            background-color: var(--spotify-bg-light);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid rgba(128, 128, 128, 0.1);
        }

        .sent-review-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .sent-review-tool-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .sent-review-tool-logo {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            object-fit: cover;
            background-color: var(--spotify-card);
        }

        .sent-review-tool-name {
            font-size: 16px;
            font-weight: 600;
        }

        .sent-review-actions {
            display: flex;
            gap: 8px;
        }

        .sent-review-edit-btn,
        .sent-review-delete-btn {
            background: none;
            border: 1px solid var(--spotify-text-secondary);
            color: var(--spotify-text);
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sent-review-edit-btn:hover {
            background-color: var(--spotify-accent);
            border-color: var(--spotify-accent);
            color: #000;
        }

        .sent-review-delete-btn:hover {
            background-color: #ff6b6b;
            border-color: #ff6b6b;
            color: #fff;
        }

        .sent-review-rating {
            display: flex;
            gap: 2px;
            margin-bottom: 8px;
        }

        .sent-review-text {
            font-size: 14px;
            line-height: 1.5;
            color: var(--spotify-text);
        }

        .sent-review-date {
            font-size: 12px;
            color: var(--spotify-text-secondary);
            margin-top: 8px;
        }

        .no-sent-reviews {
            text-align: center;
            color: var(--spotify-text-secondary);
            padding: 40px 20px;
            font-style: italic;
        }

        /* View All Reviews Link */
        .view-all-reviews-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: var(--spotify-accent);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            margin-top: 12px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .view-all-reviews-link:hover {
            color: #1ed760;
            text-decoration: underline;
        }

        .view-all-reviews-link svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .tool-card-list .edit-icon {
            /* Style for edit icon in list view */
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: rgba(0, 0, 0, 0.6);
            /* Semi-transparent background */
            border-radius: 50%;
            width: 20px;
            /* Smaller icon */
            height: 20px;
            /* Smaller icon */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 5;
            /* Above the logo */
            color: white;
            /* White pencil icon */
            font-size: 12px;
            /* Adjust size as needed */
        }

        .tool-card-list .edit-icon svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }


        .category-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 30px;
        }

        .category-card {
            position: relative;
            padding: 12px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 700;
            overflow: hidden;
            aspect-ratio: 1.5 / 1;
            cursor: pointer;
        }

        .category-card h3 {
            position: relative;
            z-index: 2;
            color: #fff;
        }

        .category-card .logo-container {
            position: absolute;
            bottom: -10px;
            right: -20px;
            width: 80px;
            height: 80px;
            transform: rotate(25deg);
            z-index: 1;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .category-card .tool-logo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .search-bar-container {
            padding: 16px 16px 16px;
        }

        #search-input {
            width: 100%;
            padding: 14px 16px;
            font-size: 16px;
            background-color: var(--spotify-card);
            border: none;
            border-radius: 8px;
            color: var(--spotify-text);
        }

        #search-input::placeholder {
            color: var(--spotify-text-secondary);
        }

        body.light-mode #search-input {
            background-color: var(--spotify-card);
            color: var(--spotify-text);
        }

        body.light-mode #search-input::placeholder {
            color: var(--spotify-text-secondary);
        }

        #empty-state {
            text-align: center;
            color: var(--spotify-text-secondary);
            padding: 40px;
        }

        #bottom-nav {
            display: flex;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--bottom-nav-height);
            background: linear-gradient(to top, var(--spotify-bg) 80%, transparent);
            z-index: 100;
            border-top: 1px solid var(--spotify-card);
        }

        .nav-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.2s;
        }

        .nav-btn .icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .nav-btn.active {
            color: var(--spotify-accent);
        }

        /* Badge di notifica per messaggi non letti */
        .notification-badge {
            position: absolute;
            top: -2px;
            right: -2px;
            background-color: #ff4444;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 2px solid var(--spotify-bg);
        }

        .nav-btn .icon {
            position: relative;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1600;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        body.light-mode .modal-overlay {
            background: rgba(255, 255, 255, 0.6);
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Responsive modal overlay */
        @media (max-width: 768px) {
            .modal-overlay {
                /* Default to top alignment for potentially long content */
                align-items: flex-start;
                padding: 20px 0;
                /* Use symmetrical padding */
            }

            /* Specifically center overlays containing shorter, form-like modals */
            #add-ai-suggestion-modal,
            #settings-modal,
            #confirm-delete-review-modal,
            #confirm-delete-modal,
            #confirm-delete-prompt-modal,
            /* AGGIUNTO */
            #detail-modal,
            #change-nickname-modal,
            #change-password-modal,
            #prompt-gallery-modal,
            #manage-rankings-modal,
            #feature-toggles-modal,
            #edit-alternative-modal,
            #add-video-modal,
            /* NUOVO */
            #edit-video-modal

            /* NUOVO */
                {
                align-items: center;
            }
        }

        @media (max-width: 480px) {
            .modal-overlay {
                /* Default to top alignment */
                align-items: flex-start;
                padding: 10px 0;
            }

            /* Specifically center overlays containing shorter, form-like modals */
            #add-ai-suggestion-modal,
            #settings-modal,
            #confirm-delete-review-modal,
            #confirm-delete-modal,
            #confirm-delete-prompt-modal,
            /* AGGIUNTO */
            #detail-modal,
            #change-nickname-modal,
            #change-password-modal,
            #prompt-gallery-modal,
            #manage-rankings-modal,
            #feature-toggles-modal,
            #edit-alternative-modal {
                align-items: center;
            }
        }

        .modal-content {
            background: var(--spotify-card);
            padding: 24px;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            text-align: center;
            position: relative;
        }

        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 28px;
            cursor: pointer;
        }

        .button {
            background-color: var(--spotify-accent);
            color: #000;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Stili per il pulsante admin migliorato */
        .admin-add-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 16px 24px;
            text-transform: none;
            letter-spacing: normal;
            transition: all 0.2s ease;
        }

        .admin-add-button:hover {
            background-color: #1ed760;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
        }

        .admin-add-button .button-icon {
            font-size: 24px;
            font-weight: 300;
            line-height: 1;
        }

        .admin-add-button .button-text {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
        }

        .admin-add-button .button-primary {
            font-size: 16px;
            font-weight: 700;
            line-height: 1.2;
        }

        .admin-add-button .button-secondary {
            font-size: 14px;
            font-weight: 500;
            opacity: 0.8;
            line-height: 1.2;
        }

        /* NUOVO: Fix per il layout del modale Impostazioni */
        #settings-modal .modal-content {
            text-align: left;
            /* Allinea a sinistra il contenuto del form */
            margin: auto;
            /* Forzatura del centraggio verticale e orizzontale */
        }

        #settings-modal .modal-content h2 {
            text-align: center;
            /* Ri-centra il titolo principale */
        }

        #detail-content h2 {
            font-size: 24px;
            margin-bottom: 8px;
        }

        #detail-content p {
            color: var(--spotify-text-secondary);
            margin-bottom: 24px;
            line-height: 1.5;
        }

        #detail-content .detail-tags {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
        }

        #detail-content .tag {
            background-color: var(--spotify-bg-light);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
        }

        #detail-content .detail-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .back-button {
            font-size: 16px;
            font-weight: bold;
            color: var(--spotify-text);
            cursor: pointer;
            margin-bottom: 20px;
        }

        .recommendation-box {
            margin-top: 24px;
            background-color: var(--spotify-bg-light);
            padding: 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            border: 1px solid rgba(128, 128, 128, 0.2);
            transition: background-color 0.2s;
        }

        .recommendation-box:hover {
            background-color: var(--spotify-card);
        }

        .recommendation-logo {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .recommendation-text {
            font-size: 14px;
            color: var(--spotify-text-secondary);
            text-align: left;
        }

        .recommendation-text strong {
            color: var(--spotify-text);
            display: block;
        }

        .auth-prompt-card {
            background-color: var(--spotify-card);
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            margin: 20px auto;
            max-width: 90%;
        }

        .auth-prompt-card h3 {
            font-size: 20px;
            margin-bottom: 12px;
        }

        .auth-prompt-card p {
            color: var(--spotify-text-secondary);
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .auth-prompt-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }

        .auth-prompt-actions .button {
            width: 100%;
        }

        .auth-prompt-actions .pill-btn {
            background-color: transparent;
            border: 1px solid var(--spotify-text-secondary);
            width: 100%;
            padding: 14px;
        }

        /* --- STILI MIGLIORATI E NUOVI PER IL CHATBOT --- */
        #chatbot-container-wrapper {
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        /* NUOVO: Keyframes per l'animazione di zoom lento dello sfondo */
        @keyframes kenburnsZoom {

            0%,
            100% {
                transform: scale(1.0) translate(0, 0);
            }

            50% {
                transform: scale(1.1) translate(-1%, 1%);
            }
        }

        #chatbot-app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: var(--spotify-bg);
            flex-grow: 1;
            position: relative;
            /* Necessario per posizionare lo sfondo animato */
            overflow: hidden;
            /* Nasconde le parti dell'immagine che escono durante lo zoom */
        }

        /* NUOVO: Pseudo-elemento per contenere e animare lo sfondo in modo isolato */
        #chatbot-app-container::before {
            content: '';
            position: absolute;
            top: -5%;
            left: -5%;
            right: -5%;
            bottom: -5%;
            /* Leggermente più grande per evitare bordi bianchi durante l'animazione */
            z-index: 0;
            background-image: linear-gradient(rgba(18, 18, 18, 0.7), rgba(18, 18, 18, 0.7)), url('https://i.postimg.cc/bN4DrwdT/Sfondo-website-koda.png');
            background-size: cover;
            background-position: center center;
            animation: kenburnsZoom 30s ease-in-out infinite;
            /* Applica l'animazione con durata 30s */
        }

        /* NUOVO: Assicura che il contenuto della chat stia sempre sopra lo sfondo */
        #chatbot-app-container>* {
            position: relative;
            z-index: 1;
        }

        .chat-header {
            padding: 16px;
            display: flex;
            align-items: center;
            width: 100%;
            z-index: 10;
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, var(--spotify-bg) 70%, transparent);
        }

        .chat-header-btn {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 8px;
        }

        #menu-toggle-btn {
            margin-right: 8px;
        }

        #chatbot-app-container main {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
        }

        #welcome-screen {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            text-align: center;
            gap: 24px;
            padding: 20px;
            padding-bottom: 5vh;
            /* MODIFICATO: Spostato il contenuto verso il basso */
        }

        .welcome-logo {
            font-size: 2.5rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 16px;
        }

        /* NUOVO: Mantiene la scritta "Koda" bianca in modalità giorno */
        body.light-mode .welcome-logo span:first-child {
            color: #ffffff !important;
        }

        .welcome-logo svg {
            width: 50px;
            height: 50px;
        }

        .prompt-starter-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            width: 100%;
            max-width: 400px;
        }

        .prompt-starter-btn {
            background-color: var(--spotify-card);
            color: var(--spotify-text);
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            width: 100%;
            text-align: left;
            transition: background-color 0.2s;
        }

        .prompt-starter-btn:hover {
            background-color: var(--spotify-bg-light);
        }

        /* NUOVI STILI PER I PULSANTI DI AZIONE */
        .prompt-actions-container {
            display: flex;
            gap: 12px;
            width: 100%;
            max-width: 400px;
            margin-top: 24px;
            /* Spazio sopra i nuovi pulsanti */
        }

        .action-btn {
            flex: 1;
            padding: 14px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .action-btn.primary {
            background-color: var(--spotify-accent);
            color: #000;
        }

        .action-btn.primary:hover {
            background-color: #1ed760;
            /* Leggermente più chiaro al passaggio del mouse */
            transform: scale(1.02);
        }

        .action-btn.secondary {
            background-color: var(--spotify-card);
            color: var(--spotify-text);
            border: 1px solid rgba(128, 128, 128, 0.2);
        }

        .action-btn.secondary:hover {
            background-color: var(--spotify-bg-light);
        }

        /* NUOVO STILE PER IL PULSANTE VIOLA */
        .action-btn.tertiary {
            background-color: #8D49F2;
            /* Viola vibrante, in linea con lo stile */
            color: var(--spotify-text);
            border: none;
        }

        .action-btn.tertiary:hover {
            background-color: #9d5bf5;
            /* Leggermente più chiaro al passaggio del mouse */
            transform: scale(1.02);
        }

        #chat-messages {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-top: 16px;
            /* NUOVO: Aggiunge spazio per evitare che il primo messaggio sia coperto dall'header */
        }

        .chat-bubble {
            padding: 12px 16px;
            border-radius: 20px;
            max-width: 85%;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .chat-bubble.ai {
            background-color: var(--spotify-ai-bubble-bg);
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        .chat-bubble.user {
            background-color: var(--spotify-accent);
            color: #000;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .chat-bubble.system {
            background-color: transparent;
            color: var(--spotify-text-secondary);
            align-self: center;
            text-align: center;
            font-style: normal;
            font-size: 14px;
            width: 100%;
            max-width: 100%;
            padding: 0 16px 8px;
        }

        .chat-bubble.error {
            background-color: #8c1a1a;
            color: var(--spotify-text);
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        .chat-bubble.loading {
            align-self: flex-start;
            background-color: var(--spotify-card);
            padding: 14px 16px;
        }

        .chat-bubble.loading span {
            display: inline-block;
            background-color: var(--spotify-text-secondary);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin: 0 1px;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .chat-bubble.loading span:nth-of-type(1) {
            animation-delay: -0.32s;
        }

        .chat-bubble.loading span:nth-of-type(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {

            0%,
            80%,
            100% {
                transform: scale(0);
            }

            40% {
                transform: scale(1.0);
            }
        }

        .chat-bubble.ai ul {
            margin: 8px 0;
            padding-left: 20px;
            list-style-type: disc;
        }

        .chat-bubble.ai li {
            margin: 4px 0;
            line-height: 1.4;
        }

        .chat-bubble.ai a {
            color: var(--spotify-accent);
            text-decoration: none;
            border-radius: 4px;
            padding: 2px 4px;
            transition: background-color 0.2s;
        }

        .chat-bubble.ai a:hover {
            background-color: rgba(29, 185, 84, 0.1);
            text-decoration: underline;
        }

        .chat-bubble.ai strong {
            font-weight: 600;
            color: var(--spotify-text);
        }

        .chat-bubble.ai p {
            margin: 8px 0;
        }

        .chat-bubble.ai p:first-child {
            margin-top: 0;
        }

        .chat-bubble.ai p:last-child {
            margin-bottom: 0;
        }

        .chat-tool-card-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-self: flex-start;
            width: 100%;
            max-width: 400px;
        }

        .chat-tool-card {
            display: flex;
            gap: 12px;
            background-color: var(--spotify-card);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid rgba(128, 128, 128, 0.1);
        }

        .chat-tool-card .logo-container {
            width: 48px;
            height: 48px;
            flex-shrink: 0;
            border-radius: 8px;
            overflow: hidden;
        }

        .chat-tool-card .tool-logo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .chat-tool-card .info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .chat-tool-card .tool-name {
            font-weight: 600;
            font-size: 15px;
        }

        .chat-tool-card .tool-desc {
            font-size: 13px;
            color: var(--spotify-text-secondary);
            margin: 2px 0 8px;
            line-height: 1.4;
        }

        .chat-tool-card .details-btn {
            background: var(--spotify-bg-light);
            color: var(--spotify-text);
            border: none;
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 20px;
            cursor: pointer;
            align-self: flex-start;
        }

        #chat-input-container {
            background-color: var(--spotify-card);
            border-radius: 28px;
            padding: 12px;
            margin: 16px;
            display: flex;
            align-items: flex-end;
            gap: 12px;
            border: 1px solid var(--spotify-bg-light);
        }

        body.light-mode #chat-input-container {
            border: 1px solid #ddd;
        }

        .input-icon-group {
            display: flex;
            gap: 8px;
            padding-bottom: 6px;
        }

        .input-icon-btn {
            background-color: var(--spotify-bg-light);
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            color: var(--spotify-text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        #chat-input {
            flex-grow: 1;
            background-color: transparent;
            border: none;
            color: var(--spotify-text);
            font-size: 16px;
            resize: none;
            padding: 6px 0;
            line-height: 1.5;
        }

        #chat-input:focus {
            outline: none;
        }

        #chat-input::placeholder {
            color: var(--spotify-text-secondary);
        }

        #chat-send-btn {
            background-color: var(--spotify-bg-light);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--spotify-text);
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            align-self: flex-end;
        }

        #chat-send-btn:disabled {
            background-color: var(--spotify-bg);
            cursor: not-allowed;
            color: var(--spotify-text-secondary);
        }

        #chat-send-btn:not(:disabled):active {
            transform: scale(0.9);
        }

        /* NUOVI STILI PER IL MENU LATERALE */
        #side-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        body.light-mode #side-menu-overlay {
            background: rgba(0, 0, 0, 0.4);
        }

        #side-menu-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        #side-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 80%;
            max-width: 320px;
            height: 100%;
            background-color: var(--spotify-bg-light);
            z-index: 1501;
            transform: translateX(-100%);
            transition: transform 0.3s ease-out;
            display: flex;
            flex-direction: column;
            padding: 16px;
        }

        #side-menu.visible {
            transform: translateX(0);
        }

        .menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--spotify-card);
        }

        .menu-header h3 {
            font-size: 18px;
        }

        .new-chat-btn {
            background-color: var(--spotify-card);
            color: var(--spotify-text);
            border: none;
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .conversation-list {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .conversation-list::-webkit-scrollbar {
            display: none;
        }

        .conversation-item {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            text-align: left;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conversation-item.active,
        .conversation-item:hover {
            background-color: var(--spotify-card);
            color: var(--spotify-text);
        }

        .menu-footer {
            margin-top: auto;
            padding-top: 16px;
            border-top: 1px solid var(--spotify-card);
        }

        #delete-all-btn {
            width: 100%;
            background: none;
            border: 1px solid var(--spotify-text-secondary);
            color: var(--spotify-text-secondary);
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        #delete-all-btn:hover {
            background-color: var(--spotify-card);
            color: var(--spotify-text);
            border-color: var(--spotify-card);
        }

        /* --- STILI PER I GROUP CHATS --- */
        .group-chat-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            border-bottom: 1px solid var(--spotify-card);
        }

        .group-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--spotify-accent), #1ed760);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
            font-size: 16px;
        }

        .group-info h3 {
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 4px 0;
        }

        .group-members-count {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        .group-actions {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }

        .group-action-btn {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .group-action-btn:hover {
            background-color: var(--spotify-card);
            color: var(--spotify-text);
        }

        .create-group-btn {
            background-color: var(--spotify-accent);
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin: 16px;
            transition: all 0.2s;
        }

        .create-group-btn:hover {
            background-color: #1ed760;
            transform: scale(1.02);
        }

        .group-chat-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid rgba(128, 128, 128, 0.1);
        }

        .group-chat-item:hover {
            background-color: var(--spotify-card);
        }

        .group-chat-item.active {
            background-color: var(--spotify-bg-light);
        }

        .group-member-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
        }

        .member-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--spotify-accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
            font-size: 14px;
        }

        .member-info {
            flex: 1;
        }

        .member-name {
            font-size: 14px;
            font-weight: 500;
        }

        .member-role {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        .permission-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .permission-badge.admin {
            background-color: #ff6b6b;
            color: white;
        }

        .permission-badge.moderator {
            background-color: #ffa726;
            color: white;
        }

        .permission-badge.member {
            background-color: var(--spotify-card);
            color: var(--spotify-text-secondary);
        }

        .group-settings-modal .modal-content {
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .group-settings-section {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--spotify-card);
        }

        .group-settings-section:last-child {
            border-bottom: none;
        }

        .group-settings-section h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .member-actions {
            display: flex;
            gap: 8px;
        }

        .member-action-btn {
            background: none;
            border: 1px solid var(--spotify-text-secondary);
            color: var(--spotify-text-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .member-action-btn:hover {
            background-color: var(--spotify-card);
            color: var(--spotify-text);
        }

        .member-action-btn.danger:hover {
            background-color: #ff6b6b;
            border-color: #ff6b6b;
            color: white;
        }

        /* --- STILI PER LE CLASSIFICHE (AGGIUNTI) --- */
        .ranking-section-container {
            display: grid;
            gap: 20px;
            /* Reduced gap */
        }

        .ranking-card {
            background-color: var(--spotify-card);
            border-radius: 12px;
            padding: 12px;
            /* Reduced padding */
            transition: opacity 0.3s, transform 0.3s;
            transform-origin: top;
        }

        .ranking-card.hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            display: none;
            /* Use display: none to fully hide */
        }

        .ranking-card h3 {
            font-size: 16px;
            /* Reduced font size */
            font-weight: 700;
            margin-bottom: 12px;
            /* Reduced margin */
        }

        .ranking-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* Reduced gap */
        }

        .ranking-item {
            display: flex;
            align-items: center;
            gap: 10px;
            /* Reduced gap */
            cursor: pointer;
            padding: 2px;
            /* Reduced padding */
            border-radius: 8px;
            transition: background-color 0.2s;
        }

        .ranking-item:hover {
            background-color: var(--spotify-bg-light);
        }

        .ranking-item-rank {
            font-size: 14px;
            /* Reduced font size */
            font-weight: 700;
            color: var(--spotify-text-secondary);
            width: 20px;
            text-align: center;
        }

        .ranking-item-logo {
            /* Added style for logo in ranking list */
            width: 32px;
            /* Smaller logo */
            height: 32px;
            /* Smaller logo */
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .ranking-item-info {
            flex-grow: 1;
        }

        .ranking-item-info .tool-name {
            font-size: 15px;
            /* Reduced font size */
            font-weight: 500;
        }

        .ranking-item-info .tool-subtext {
            font-size: 12px;
            /* Reduced font size */
            color: var(--spotify-text-secondary);
        }

        /* --- STILI PER MODALE IMPOSTAZIONI (AGGIUNTI) --- */
        #settings-modal .input-group,
        #add-app-modal .input-group,
        #replace-featured-modal .input-group,
        #change-password-modal .input-group,
        /* AGGIUNTO */
        #change-nickname-modal .input-group,
        #add-global-tool-modal .input-group,
        #edit-global-tool-modal .input-group,
        #edit-ranking-modal .input-group,
        #edit-alternative-modal .input-group {
            /* AGGIUNTO */
            margin-bottom: 20px;
            text-align: left;
        }

        #settings-modal label,
        #add-app-modal label,
        #replace-featured-modal label,
        #change-password-modal label,
        /* AGGIUNTO */
        #change-nickname-modal label,
        #add-global-tool-modal label,
        #edit-global-tool-modal label,
        #edit-ranking-modal label,
        #edit-alternative-modal label {
            /* AGGIUNTO */
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 15px;
            color: var(--spotify-text);
        }

        #settings-modal input,
        #add-app-modal input:not([type="file"]),
        #add-app-modal textarea,
        #replace-featured-modal input,
        #change-password-modal input,
        /* AGGIUNTO */
        #change-nickname-modal input,
        /* AGGIUNTO */
        #edit-app-modal input,
        #add-global-tool-modal input,
        #add-global-tool-modal textarea,
        #add-global-tool-modal select,
        #edit-global-tool-modal input,
        #edit-global-tool-modal textarea,
        #edit-global-tool-modal select,
        #edit-ranking-modal input,
        /* NUOVI SELETTORI PER I MODAL VIDEO */
        #add-video-modal input,
        #add-video-modal textarea,
        #edit-video-modal input,
        #edit-video-modal textarea {
            width: 100%;
            padding: 16px 18px;
            font-size: 16px;
            background-color: var(--spotify-bg-light);
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 12px;
            color: var(--spotify-text);
            box-sizing: border-box;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            font-family: var(--font-family);
        }

        #add-app-modal textarea {
            min-height: 80px;
            resize: vertical;
        }

        /* Stili specifici per il modal Aggiungi AI */
        .add-ai-modal {
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            margin: 20px;
            width: calc(100% - 40px);
        }

        .add-ai-form {
            padding-top: 24px;
        }

        /* Responsive design per il modal */
        @media (max-width: 768px) {
            .add-ai-modal {
                max-width: none;
                width: calc(100% - 20px);
                margin: 10px;
                max-height: 95vh;
            }

            .add-ai-form {
                padding-top: 16px;
            }

            #add-global-tool-modal .input-group,
            #edit-global-tool-modal .input-group {
                margin-bottom: 16px;
            }

            #add-global-tool-modal input,
            #add-global-tool-modal textarea,
            #add-global-tool-modal select,
            #edit-global-tool-modal input,
            #edit-global-tool-modal textarea,
            #edit-global-tool-modal select {
                padding: 14px 16px;
                font-size: 16px;
            }

            #add-global-tool-modal h2,
            #edit-global-tool-modal h2 {
                font-size: 20px;
                margin-bottom: 16px;
            }
        }

        @media (max-width: 480px) {
            .add-ai-modal {
                width: calc(100% - 10px);
                margin: 5px;
                border-radius: 12px;
                max-height: 98vh;
            }

            .add-ai-form {
                padding-top: 12px;
            }

            #add-global-tool-modal .input-group,
            #edit-global-tool-modal .input-group {
                margin-bottom: 14px;
            }

            #add-global-tool-modal input,
            #add-global-tool-modal textarea,
            #add-global-tool-modal select,
            #edit-global-tool-modal input,
            #edit-global-tool-modal textarea,
            #edit-global-tool-modal select {
                padding: 12px 14px;
                font-size: 16px;
                border-radius: 10px;
            }

            #add-global-tool-modal label,
            #edit-global-tool-modal label {
                font-size: 14px;
                margin-bottom: 8px;
            }

            #add-global-tool-modal h2,
            #edit-global-tool-modal h2 {
                font-size: 18px;
                margin-bottom: 12px;
            }

            #add-global-tool-modal .button,
            #edit-global-tool-modal .button {
                padding: 14px 20px;
                font-size: 16px;
                margin-top: 8px;
            }

            /* --- NUOVI STILI PER LA GESTIONE CLASSIFICHE ADMIN --- */
            #manage-rankings-modal .sent-review-item {
                transition: background-color 0.2s;
            }

            #manage-rankings-modal .sent-review-item:hover {
                background-color: var(--spotify-card);
            }

            .ranking-action-btn {
                background: var(--spotify-bg-light);
                border: 1px solid var(--spotify-card);
                color: var(--spotify-text);
                border-radius: 50%;
                width: 36px;
                height: 36px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.2s;
            }

            .ranking-action-btn.edit:hover {
                background-color: var(--spotify-accent);
                color: #000;
                border-color: var(--spotify-accent);
            }

            .ranking-action-btn.delete:hover {
                background-color: #ff6b6b;
                color: white;
                border-color: #ff6b6b;
            }

            /* --- STILI PER GESTIONE ALTERNATIVE (NUOVO LAYOUT) --- */
            .alternative-row {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px;
                background-color: var(--spotify-bg-light);
                border-radius: 12px;
                margin-bottom: 12px;
                border: 1px solid var(--spotify-card);
            }

            .main-ai-col {
                display: flex;
                align-items: center;
                gap: 12px;
                flex: 1;
                min-width: 0;
            }

            .main-ai-col img {
                width: 40px;
                height: 40px;
                border-radius: 6px;
                object-fit: cover;
                flex-shrink: 0;
            }

            .main-ai-col .tool-name {
                font-weight: 600;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .alt-ai-col {
                display: flex;
                align-items: center;
                gap: 10px;
                flex: 1;
                min-width: 0;
                justify-content: flex-end;
            }

            .alt-ai-col .tool-list-item {
                padding: 6px 8px;
                background-color: var(--spotify-card);
                border-radius: 8px;
                flex-grow: 1;
                min-width: 0;
            }

            .alt-ai-col .tool-list-item .info .tool-name {
                font-size: 14px;
            }

            .alt-empty-state {
                display: flex;
                align-items: center;
                justify-content: center;
                flex-grow: 1;
                padding: 6px 8px;
                background-color: var(--spotify-card);
                border-radius: 8px;
                color: var(--spotify-text-secondary);
                font-style: italic;
                font-size: 14px;
            }

            .edit-mode-container {
                width: 100%;
            }

            .edit-mode-container .chat-search-input {
                margin-bottom: 8px;
            }

            #ranking-selected-tools .tool-list-item {
                padding: 8px;
                background-color: var(--spotify-bg-light);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                cursor: grab;
                /* Make it look draggable */
                transition: background-color 0.2s, opacity 0.2s;
                user-select: none;
                /* Prevent text selection while dragging */
            }

            #ranking-selected-tools .tool-list-item img {
                width: 32px;
                height: 32px;
                border-radius: 4px;
                object-fit: cover;
                flex-shrink: 0;
                pointer-events: none;
                /* Prevent image from being dragged alone */
            }

            #ranking-selected-tools .tool-list-item.dragging {
                opacity: 0.4;
                background: var(--spotify-accent);
            }

            #ranking-selected-tools .sent-review-delete-btn {
                background-color: var(--spotify-card);
                color: var(--spotify-text-secondary);
                border: none;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                font-size: 16px;
                line-height: 24px;
                text-align: center;
                padding: 0;
                flex-shrink: 0;
                cursor: pointer;
                transition: all 0.2s;
            }

            #ranking-selected-tools .sent-review-delete-btn:hover {
                background-color: #ff6b6b;
                color: white;
                transform: scale(1.1);
            }

            #ranking-tool-search-results {
                border: 1px solid var(--spotify-bg-light);
                border-radius: 8px;
                margin-top: 8px;
                padding: 4px;
            }

            #ranking-tool-search-results .tool-list-item:hover {
                background-color: var(--spotify-bg-light);
            }

            .modal-close-btn {
                font-size: 20px;
                top: 10px;
                right: 10px;
            }
        }

        #add-global-tool-modal input:focus,
        #add-global-tool-modal textarea:focus,
        #add-global-tool-modal select:focus,
        #edit-global-tool-modal input:focus,
        #edit-global-tool-modal textarea:focus,
        #edit-global-tool-modal select:focus {
            outline: none;
            border-color: var(--spotify-accent);
            box-shadow: 0 0 0 3px rgba(29, 185, 84, 0.1);
        }

        #add-global-tool-modal textarea,
        #edit-global-tool-modal textarea {
            min-height: 100px;
            resize: vertical;
            line-height: 1.5;
        }

        #add-global-tool-modal select,
        #edit-global-tool-modal select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 12px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 40px;
        }

        .checkbox-group {
            margin: 24px 0 32px 0;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background-color: var(--spotify-bg-light);
            border-radius: 12px;
            border: 1px solid rgba(128, 128, 128, 0.2);
            transition: background-color 0.2s ease;
        }

        .checkbox-wrapper:hover {
            background-color: var(--spotify-card);
        }

        .checkbox-wrapper input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin: 0;
            cursor: pointer;
            accent-color: var(--spotify-accent);
        }

        .checkbox-wrapper label {
            margin: 0;
            cursor: pointer;
            font-weight: 500;
            font-size: 16px;
        }

        /* Style for file input */
        #add-app-modal input[type="file"] {
            width: 100%;
            padding: 14px 0;
            /* Adjust padding for file input */
            font-size: 16px;
            background-color: transparent;
            /* File input background is handled by the container */
            border: none;
            /* File input border is handled by the container */
            border-radius: 0;
            color: var(--spotify-text);
            box-sizing: border-box;
        }

        #add-app-modal input[type="file"]::file-selector-button {
            background-color: var(--spotify-bg-light);
            color: var(--spotify-text);
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 8px;
            padding: 8px 12px;
            margin-right: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #add-app-modal input[type="file"]::file-selector-button:hover {
            background-color: var(--spotify-card);
        }

        /* Style for logo preview */
        #add-app-logo-preview {
            display: block;
            width: 80px;
            height: 80px;
            margin: 10px auto 0;
            /* Center preview below input */
            border-radius: 8px;
            object-fit: cover;
            border: 1px solid rgba(128, 128, 128, 0.2);
            background-color: var(--spotify-bg-light);
            /* Placeholder background */
        }


        #settings-modal .button,
        #add-app-modal .button,
        #replace-featured-modal .button,
        /* NUOVI SELETTORI PER I MODAL VIDEO CON MARGINE AUMENTATO */
        #add-video-modal .button,
        #edit-video-modal .button {
            width: 100%;
            margin-top: 24px;
            /* Aumentato margine per più spazio */
        }

        .settings-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 8px;
        }

        .settings-modal-header h2 {
            flex-grow: 1;
            /* Allow title to take up remaining space */
            text-align: center;
            /* Center the title text */
            margin: 0;
        }

        hr.modal-divider {
            border: none;
            border-top: 1px solid var(--spotify-card);
            margin: 24px 0;
        }

        .toast-message {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--spotify-accent);
            color: black;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            /* Allow clicks to pass through */
        }

        .toast-message.show {
            opacity: 1;
            transform: translate(-50%, -10px);
        }

        /* Styles for Add App button in Library */
        #add-app-button {
            width: calc(100% - 32px);
            /* Full width minus padding */
            margin: 16px auto 24px;
            /* Center and add spacing */
            display: block;
            /* Ensure it takes full width */
        }

        /* Styles for User Featured section */
        .user-featured-section {
            margin-bottom: 30px;
        }

        .user-featured-section .section-title {
            margin-bottom: 16px;
        }

        .user-featured-section .grid-container {
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            /* Adjust grid for smaller cards */
            gap: 12px;
        }

        .user-featured-section .tool-card-grid .logo-container {
            border-radius: 4px;
            /* Slightly smaller radius */
            position: relative;
            /* Needed for absolute positioning of edit icon */
        }

        .user-featured-section .tool-card-grid .tool-name {
            font-size: 13px;
            /* Smaller font */
            text-align: center;
        }

        .user-featured-section .tool-card-grid {
            text-align: center;
        }



        /* Style for the edit icon on featured user apps */
        .edit-icon {
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: rgba(0, 0, 0, 0.6);
            /* Semi-transparent background */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 5;
            /* Above the logo */
            color: white;
            /* White pencil icon */
            font-size: 14px;
            /* Adjust size as needed */
        }

        .edit-icon svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        /* Styles for the Replace Featured Modal */
        #replace-featured-modal .modal-content {
            max-height: 80vh;
            /* Limit height */
            overflow-y: auto;
            /* Add scroll if needed */
        }

        #replace-featured-modal .tool-list-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-bottom: 1px solid var(--spotify-bg-light);
            cursor: pointer;
            text-align: left;
        }

        #replace-featured-modal .tool-list-item:last-child {
            border-bottom: none;
        }

        #replace-featured-modal .tool-list-item:hover {
            background-color: var(--spotify-bg-light);
        }

        #replace-featured-modal .tool-list-item img {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }

        #replace-featured-modal .tool-list-item .info {
            flex-grow: 1;
        }

        #replace-featured-modal .tool-list-item .tool-name {
            font-size: 15px;
            font-weight: 500;
        }

        #replace-featured-modal .tool-list-item .tool-subtext {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        /* Styles for AI Suggestions and User Search */
        .ai-suggestion-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--spotify-card);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border: 1px solid rgba(128, 128, 128, 0.1);
        }

        .suggestion-content {
            flex-grow: 1;
        }

        .suggestion-text {
            font-size: 14px;
            color: var(--spotify-text);
            margin-bottom: 4px;
        }

        .suggestion-date {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        .remove-suggestion-btn {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: color 0.2s;
        }

        .remove-suggestion-btn:hover {
            color: #ff4444;
        }

        .user-search-result {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--spotify-card);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border: 1px solid rgba(128, 128, 128, 0.1);
        }

        .user-info {
            flex-grow: 1;
        }

        .user-nickname {
            font-size: 16px;
            font-weight: 600;
            color: var(--spotify-text);
            margin-bottom: 4px;
        }

        .user-suggestions-count {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        .view-suggestions-btn {
            background-color: var(--spotify-accent);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .view-suggestions-btn:hover {
            background-color: #1ed760;
        }

        .suggestions-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .suggestion-item {
            background-color: var(--spotify-bg-light);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border: 1px solid rgba(128, 128, 128, 0.1);
        }

        .user-search-result {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--spotify-card-bg);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border: 1px solid var(--spotify-border);
        }

        .user-info {
            flex: 1;
        }

        .user-nickname {
            font-weight: 600;
            color: var(--spotify-text-primary);
            margin-bottom: 4px;
        }

        .user-suggestions-count {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        .view-suggestions-btn {
            background: var(--spotify-green);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .view-suggestions-btn:hover {
            background: var(--spotify-green-hover);
        }

        /* New Search Users Page Styles */
        .search-users-container {
            padding: 20px;
            max-width: 600px;
            margin: 0 auto;
            text-align: center;
        }

        .search-users-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .search-users-icon {
            color: var(--spotify-green);
            margin-bottom: 16px;
        }

        .search-users-title {
            font-size: 28px;
            font-weight: 700;
            color: var(--spotify-text-primary);
            margin: 0 0 8px 0;
        }

        .search-users-subtitle {
            font-size: 16px;
            color: var(--spotify-text-secondary);
            margin: 0;
            line-height: 1.5;
        }

        .search-users-input-container {
            margin-bottom: 30px;
        }

        .search-input-wrapper {
            position: relative;
            max-width: 400px;
            margin: 0 auto;
        }

        .search-icon {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--spotify-text-secondary);
            pointer-events: none;
        }

        .search-users-input {
            width: 100%;
            padding: 16px 16px 16px 48px;
            border: 2px solid #1db954;
            border-radius: 12px;
            background: var(--spotify-card-bg);
            color: var(--spotify-text-primary);
            font-size: 16px;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }

        .search-users-input:focus {
            outline: none;
            border-color: var(--spotify-green);
            box-shadow: 0 0 0 3px rgba(30, 215, 96, 0.1);
        }

        .search-users-input::placeholder {
            color: var(--spotify-text-secondary);
        }

        .search-results-container {
            min-height: 200px;
        }

        .user-search-result {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--spotify-card-bg);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            border: 1px solid var(--spotify-border);
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .user-search-result:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            border-color: var(--spotify-green);
        }

        .user-info {
            flex: 1;
            margin-right: 16px;
        }

        .user-nickname {
            font-weight: 600;
            color: var(--spotify-text-primary);
            margin-bottom: 4px;
            font-size: 16px;
        }

        .user-email {
            font-size: 14px;
            color: var(--spotify-text-secondary);
            margin-bottom: 4px;
        }

        .user-suggestions-count {
            font-size: 12px;
            color: var(--spotify-text-secondary);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .user-suggestions-count::before {
            content: "💡";
            font-size: 14px;
        }

        .view-suggestions-btn {
            background: var(--spotify-green);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .view-suggestions-btn:hover {
            background: var(--spotify-green-hover);
            transform: scale(1.05);
        }

        #empty-state {
            text-align: center;
            color: var(--spotify-text-secondary);
            font-size: 16px;
            padding: 40px 20px;
            background: var(--spotify-card-bg);
            border-radius: 12px;
            border: 2px dashed var(--spotify-border);
        }

        /* AI Suggestions Grid and Cards */
        .suggestions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .suggestion-item.new-format {
            background: var(--spotify-card-bg);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--spotify-border);
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .suggestion-item.new-format:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            border-color: var(--spotify-green);
        }

        .suggestion-header {
            margin-bottom: 12px;
        }

        .suggestion-app-name {
            font-size: 18px;
            font-weight: 600;
            color: var(--spotify-text-primary);
            margin: 0 0 8px 0;
        }

        .suggestion-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .suggestion-category,
        .suggestion-country {
            background: var(--spotify-green);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }

        .suggestion-description {
            color: var(--spotify-text-secondary);
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 16px;
        }

        .suggestion-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .suggestion-website-btn {
            background: var(--spotify-green);
            color: white;
            text-decoration: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .suggestion-website-btn:hover {
            background: var(--spotify-green-hover);
            transform: scale(1.05);
        }

        .suggestion-date {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        .remove-suggestion-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .remove-suggestion-btn:hover {
            background: #ff5252;
            transform: scale(1.05);
        }

        /* Form Styles for AI Suggestion Modal */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--spotify-text);
            font-size: 14px;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 14px 16px;
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 8px;
            background: var(--spotify-bg-light);
            color: var(--spotify-text);
            font-size: 16px;
            transition: all 0.3s ease;
            box-sizing: border-box;
            font-family: var(--font-family);
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--spotify-accent);
            box-shadow: 0 0 0 3px rgba(29, 185, 84, 0.1);
            background: var(--spotify-card);
        }

        .form-group textarea {
            min-height: 80px;
            resize: vertical;
            line-height: 1.5;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 32px;
            flex-wrap: wrap;
        }

        .button.secondary {
            background: var(--spotify-card);
            color: var(--spotify-text);
            border: 1px solid rgba(128, 128, 128, 0.2);
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .button.primary {
            background: var(--spotify-accent);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .button.secondary:hover {
            background: var(--spotify-bg-light);
            transform: translateY(-1px);
        }

        .button.primary:hover {
            background: #1ed760;
            transform: translateY(-1px);
        }

        .button.secondary:active,
        .button.primary:active {
            transform: translateY(0);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .button:disabled:hover {
            transform: none !important;
        }

        /* AI Suggestion Modal Specific Styles */
        #add-ai-suggestion-modal .modal-content {
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 32px;
        }

        #add-ai-suggestion-modal h2 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 24px;
            color: var(--spotify-text);
            text-align: center;
        }

        #add-ai-suggestion-modal form {
            margin-top: 24px;
        }

        /* Responsive adjustments for mobile */
        @media (max-width: 768px) {
            #add-ai-suggestion-modal .modal-content {
                width: 95%;
                padding: 24px;
                margin: 20px;
                max-height: 85vh;
            }

            .form-row {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .form-actions {
                flex-direction: column;
                gap: 12px;
            }

            .button.secondary,
            .button.primary {
                width: 100%;
                padding: 16px;
                font-size: 16px;
            }

            .form-group input,
            .form-group textarea,
            .form-group select {
                padding: 16px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) {
            #add-ai-suggestion-modal .modal-content {
                width: 100%;
                margin: 10px;
                padding: 20px;
                border-radius: 12px;
            }

            #add-ai-suggestion-modal h2 {
                font-size: 20px;
                margin-bottom: 20px;
            }

            .form-group {
                margin-bottom: 16px;
            }

            .form-group label {
                font-size: 13px;
                margin-bottom: 6px;
            }
        }

        /* --- STILI PER LA CHAT UTENTE-UTENTE --- */
        .user-chat-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            /* Modificato a 100vh per occupare l'intera altezza dello schermo */
            background-color: var(--spotify-bg);
        }

        .user-chat-header {
            padding: 16px;
            background: var(--spotify-bg-light);
            border-bottom: 1px solid var(--spotify-card);
            display: flex;
            align-items: center;
            gap: 12px;
            position: sticky;
            /* Aggiunto */
            top: 0;
            /* Aggiunto */
            z-index: 10;
            /* Aggiunto */
        }

        .user-chat-back-btn {
            background: none;
            border: none;
            color: var(--spotify-text);
            font-size: 24px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .user-chat-back-btn:hover {
            background-color: var(--spotify-card);
        }

        .user-chat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--spotify-accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: black;
            font-size: 18px;
            position: relative;
        }

        .online-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background-color: #4CAF50;
            border-radius: 50%;
            border: 2px solid var(--spotify-bg-light);
        }

        .user-chat-info h3 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .user-chat-info p {
            font-size: 14px;
            color: var(--spotify-text-secondary);
            margin: 0;
        }

        .user-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .user-chat-message {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            position: relative;
        }

        .user-chat-message.sent {
            background-color: var(--spotify-accent);
            color: black;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .user-chat-message.received {
            background-color: var(--spotify-card);
            color: var(--spotify-text);
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        /* Contenitore per orario e ricevuta di lettura */
        .user-chat-message-meta {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            /* Allinea a destra nel fumetto */
            gap: 6px;
            margin-top: 4px;
            opacity: 0.8;
        }

        .user-chat-message-time {
            font-size: 12px;
            /* Rimuoviamo il margine perché gestito dal contenitore flex */
        }

        /* Stile per l'icona dell'occhio */
        .message-read-receipt {
            display: flex;
            align-items: center;
        }

        .message-read-receipt svg {
            fill: currentColor;
            /* Eredita il colore del testo (nero nel fumetto verde) */
        }

        /* Stili per l'indicatore di typing */
        .typing-indicator {
            opacity: 0.8;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--spotify-text-secondary);
            animation: typing-pulse 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-dots span:nth-child(2) {
            animation-delay: -0.16s;
        }

        .typing-dots span:nth-child(3) {
            animation-delay: 0s;
        }

        @keyframes typing-pulse {

            0%,
            80%,
            100% {
                transform: scale(0.8);
                opacity: 0.5;
            }

            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .user-chat-input-container {
            padding: 16px;
            background: var(--spotify-bg-light);
            border-top: 1px solid var(--spotify-card);
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .user-chat-input {
            width: 100%;
            flex: 1 1 auto;
            padding: 12px 16px;
            border: 1px solid var(--spotify-card);
            border-radius: 20px;
            background: var(--spotify-card);
            color: var(--spotify-text);
            font-size: 16px;
            resize: none;
            max-height: 120px;
            line-height: 1.4;
            font-family: var(--font-family);
        }

        .user-chat-input:focus {
            outline: none;
            border-color: var(--spotify-accent);
        }

        .user-chat-send-btn {
            background-color: var(--spotify-accent);
            color: black;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .user-chat-send-btn:hover {
            background-color: #1ed760;
            transform: scale(1.05);
        }

        .user-chat-send-btn:disabled {
            background-color: var(--spotify-card);
            color: var(--spotify-text-secondary);
            cursor: not-allowed;
            transform: none;
        }

        .user-chat-list {
            padding: 16px;
        }

        .user-chat-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-bottom: 8px;
        }

        .user-chat-item:hover {
            background-color: var(--spotify-card);
        }

        .user-chat-item.unread {
            background-color: rgba(29, 185, 84, 0.1);
        }

        .user-chat-item-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--spotify-accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: black;
            font-size: 20px;
            flex-shrink: 0;
        }

        .user-chat-item-info {
            flex: 1;
            min-width: 0;
        }

        .user-chat-item-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 4px;
        }

        .user-chat-item-preview {
            font-size: 14px;
            color: var(--spotify-text-secondary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .user-chat-item-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            flex-shrink: 0;
        }

        .user-chat-item-time {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        /* --- STILI PER IL PANNELLO COMANDI (SLASH COMMANDS) --- */
        .command-palette-container {
            position: absolute;
            bottom: 100%;
            /* Posiziona sopra l'input */
            left: 0;
            right: 0;
            margin: 0 16px 8px 16px;
            /* Allineato con l'input container */
            background-color: var(--spotify-card);
            border-radius: 8px;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--spotify-bg-light);
            max-height: 250px;
            /* Altezza massima, per quando ci saranno più comandi */
            overflow-y: auto;
            z-index: 10;
        }

        .command-palette-header {
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 600;
            color: var(--spotify-text-secondary);
            text-transform: uppercase;
            border-bottom: 1px solid var(--spotify-bg-light);
        }

        .command-palette-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .command-palette-item:hover {
            background-color: var(--spotify-bg-light);
        }

        .command-palette-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: var(--spotify-bg-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 500;
            color: var(--spotify-text-secondary);
            flex-shrink: 0;
        }

        .command-palette-info {
            min-width: 0;
        }

        .command-palette-name {
            font-size: 15px;
            font-weight: 500;
            color: var(--spotify-text);
        }

        .command-palette-desc {
            font-size: 13px;
            color: var(--spotify-text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        n {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            /* << MODIFICA: Always visible */
            transition: background-color 0.2s, color 0.2s;
        }

        /* --- STILI PER L'ANTEPRIMA DEL COMANDO /LINK --- */
        .link-preview-container {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            margin: 0 16px 8px 16px;
            background-color: var(--spotify-bg-light);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--spotify-card);
            overflow: hidden;
            z-index: 10;
        }

        .link-preview-item {
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background-color 0.2s;
        }

        .link-preview-item:hover {
            background-color: var(--spotify-card);
        }

        .link-preview-command {
            font-weight: 600;
            color: var(--spotify-text);
            font-size: 15px;
        }

        .link-preview-desc {
            font-size: 14px;
            color: var(--spotify-text-secondary);
        }

        /* --- STILI PER MODALE E MESSAGGIO /LINK --- */
        .ai-link-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .ai-link-modal-content {
            background-color: var(--spotify-card);
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            height: 70vh;
            max-height: 500px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .ai-link-modal-header {
            padding: 16px;
            border-bottom: 1px solid var(--spotify-bg-light);
        }

        .ai-link-search-input {
            width: 100%;
            padding: 12px 16px;
            background-color: var(--spotify-bg-light);
            border: none;
            border-radius: 8px;
            color: var(--spotify-text);
            font-size: 16px;
        }

        .ai-link-tool-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .ai-link-tool-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .ai-link-tool-item:hover {
            background-color: var(--spotify-bg-light);
        }

        .ai-link-tool-item img {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .ai-link-tool-item .tool-name {
            font-size: 15px;
            font-weight: 500;
        }

        .user-chat-message.ai-link-card {
            background-color: transparent;
            /* Il background è gestito dalla card interna */
            padding: 0;
            max-width: 320px;
            width: 100%;
        }

        .ai-link-message-content {
            background-color: var(--spotify-card);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border: 1px solid var(--spotify-bg-light);
        }

        .ai-link-message-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ai-link-message-header img {
            width: 32px;
            height: 32px;
            border-radius: 4px;
        }

        .ai-link-message-header .tool-name {
            font-weight: 600;
        }

        .ai-link-message-description {
            font-size: 13px;
            color: var(--spotify-text-secondary);
            line-height: 1.4;
        }

        .ai-link-details-btn {
            background: var(--spotify-bg-light);
            color: var(--spotify-text);
            border: none;
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 20px;
            cursor: pointer;
            align-self: flex-start;
            margin-top: 4px;
        }

        .user-chat-item-unread {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--spotify-accent);
            margin-left: 8px;
        }

        .chat-button {
            background-color: var(--spotify-accent);
            color: black;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .chat-button:hover {
            background-color: #1ed760;
            transform: scale(1.05);
        }

        .chat-button svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .user-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .floating-action-btn {
            position: fixed;
            bottom: calc(var(--bottom-nav-height) + 16px);
            /* Si posiziona 16px sopra la barra di navigazione */
            right: 16px;
            width: 56px;
            height: 56px;
            background-color: var(--spotify-accent);
            color: #000;
            /* Colore dell'icona (il +) nero */
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            z-index: 1001;
            /* Assicura che sia sopra la lista delle chat */
            transition: transform 0.2s ease, background-color 0.2s ease;
        }

        .floating-action-btn:hover {
            background-color: #1ed760;
            /* Colore leggermente più chiaro al passaggio del mouse */
            transform: scale(1.05);
        }

        .chat-search-container {
            padding: 16px;
            /* MODIFICATO: Aggiunto padding verticale per dare più spazio */
            background-color: var(--spotify-bg);
        }

        .chat-search-input {
            width: 100%;
            padding: 14px 16px;
            font-size: 16px;
            background-color: var(--spotify-card);
            border: 1px solid var(--spotify-card);
            border-radius: 8px;
            color: var(--spotify-text);
            box-sizing: border-box;
        }

        .chat-search-input::placeholder {
            color: var(--spotify-text-secondary);
        }

        .chat-filters-container {
            padding: 0 16px 16px;
            display: flex;
            gap: 8px;
        }

        .simple-chat-search-item {
            padding: 12px 16px;
            background-color: var(--spotify-card);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 16px;
            font-weight: 500;
        }

        .simple-chat-search-item:hover {
            background-color: var(--spotify-bg-light);
        }

        .chat-search-results {
            flex: 1;
            overflow-y: auto;
            padding: 0 16px;
        }

        /* --- RESPONSIVE FIX PER MOBILE --- */
        @media (max-width: 480px) {
            .top-bar {
                padding: 8px 4px;
                gap: 4px;
            }

            .page-title {
                font-size: 16px;
            }

            .user-avatar {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }

            .search-users-container {
                padding: 8px 2vw;
                max-width: 100vw;
            }

            .search-users-title {
                font-size: 20px;
            }

            .search-users-subtitle {
                font-size: 13px;
            }

            .search-input-wrapper {
                max-width: 98vw;
            }

            .search-users-input {
                font-size: 14px;
                padding: 12px 12px 12px 40px;
            }

            .search-users-header {
                margin-bottom: 24px;
            }

            .user-search-result {
                flex-direction: column;
                align-items: flex-start;
                padding: 10px;
                font-size: 13px;
            }

            .user-info {
                margin-right: 0;
                margin-bottom: 8px;
            }

            .view-suggestions-btn {
                font-size: 12px;
                padding: 6px 10px;
            }

            .user-chat-message {
                max-width: 85%;
            }

            .user-chat-input-container {
                padding: 12px;
            }

            .user-chat-header {
                padding: 12px;
            }
        }

        /* NUOVO: Stili per l'iniziale nelle card dei suggerimenti */
        .suggestion-initial-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .suggestion-initial {
            font-size: 48px;
            font-weight: 700;
            color: var(--spotify-text);
            line-height: 1;
        }

        /* --- NUOVI STILI PER LA LIBRERIA (STILE SPOTIFY) --- */
        #library-filters-container {
            padding: 8px 16px 16px 16px;
            position: sticky;
            top: 64px;
            /* Altezza della top-bar */
            background-color: var(--spotify-bg);
            z-index: 9;
        }

        #library-content-list .tool-card-list {
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }

        #library-content-list .tool-card-list:hover {
            background-color: var(--spotify-bg-light);
        }

        /* Stile per la card dei suggerimenti nella nuova lista verticale */
        .suggestion-list-item {
            background-color: var(--spotify-card);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .suggestion-list-info {
            flex-grow: 1;
        }

        .suggestion-list-app-name {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .suggestion-list-desc {
            font-size: 13px;
            color: var(--spotify-text-secondary);
            line-height: 1.4;
        }

        .suggestion-list-actions .remove-suggestion-btn {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: color 0.2s, background-color 0.2s;
        }

        .suggestion-list-actions .remove-suggestion-btn:hover {
            color: #ff6b6b;
            background-color: rgba(255, 107, 107, 0.1);
        }

        /* NUOVO: Stile per il messaggio di stato vuoto nella Libreria */
        .library-empty-state-prompt {
            padding: 40px 20px;
            text-align: center;
            font-size: 15px;
            font-weight: 500;
            color: var(--spotify-accent);
            line-height: 1.6;
        }

        /* --- STILI PER IL "CURATED FEED" (NUOVO LAYOUT DI RICERCA) --- */

        .feed-section {
            margin-bottom: 48px;
            /* Ampio spazio tra le sezioni */
        }

        .feed-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 16px;
            /* Allineato con il padding generale dell'app */
            margin-bottom: 20px;
        }

        .feed-section-title {
            font-size: 22px;
            font-weight: 700;
            color: var(--spotify-text);
            margin: 0;
        }

        .see-all-btn {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: color 0.2s ease-in-out;
            padding: 8px;
            /* Area cliccabile più grande */
        }

        .see-all-btn:hover {
            color: var(--spotify-accent);
        }

        .horizontal-scroll-container {
            display: flex;
            gap: 16px;
            overflow-x: auto;
            padding: 0 16px 16px 16px;
            /* Aggiunge padding sotto per lo scroll snap e l'ombra */
            /* Nasconde la barra di scorrimento per un look pulito */
            -ms-overflow-style: none;
            /* IE and Edge */
            scrollbar-width: none;
            /* Firefox */
            scroll-snap-type: x mandatory;
            /* Abilita lo snapping orizzontale */
            scroll-padding: 0 16px;
            /* Assicura che lo snap non tagli gli elementi ai bordi */
        }

        .horizontal-scroll-container::-webkit-scrollbar {
            display: none;
            /* Chrome, Safari, and Opera */
        }

        .tool-item-horizontal {
            flex: 0 0 140px;
            /* Base di 140px, non si restringe, non si allarga */
            cursor: pointer;
            scroll-snap-align: start;
            /* Aggancia l'inizio dell'elemento allo scroll */
            transition: background-color 0.2s ease-in-out;
            border-radius: 8px;
            padding: 8px;
        }

        .tool-item-horizontal:hover {
            background-color: var(--spotify-bg-light);
            /* Feedback visivo standard al hover */
        }

        .tool-item-logo-container {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            background-color: var(--spotify-card);
            margin-bottom: 12px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-item-logo-container .tool-logo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .tool-item-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--spotify-text);
            line-height: 1.3;
            /* Gestisce il testo su massimo 2 righe con troncamento */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        /* --- STILI PER LA SCHERMATA PROMPT OPTIMIZER --- */
        #optimizer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--spotify-bg);
            z-index: 2500;
            display: none;
            /* Nascosto di default */
            flex-direction: column;
            padding: 24px;
            font-family: var(--font-family);
            color: var(--spotify-text);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        #optimizer-overlay.visible {
            display: flex;
            opacity: 1;
            visibility: visible;
        }

        .optimizer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            flex-shrink: 0;
        }

        .optimizer-title {
            font-size: 18px;
            font-weight: 600;
        }

        .optimizer-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .optimizer-controls .button {
            padding: 8px 16px;
            font-size: 14px;
            background-color: var(--spotify-card);
            color: var(--spotify-text);
            text-transform: none;
            letter-spacing: normal;
        }

        .optimizer-controls .button.primary {
            background-color: var(--spotify-accent);
            color: #000;
        }

        .optimizer-controls .close-btn {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .optimizer-content {
            flex-grow: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            min-height: 0;
            /* Fix per overflow in flexbox */
        }

        .optimizer-panel {
            display: flex;
            flex-direction: column;
        }

        .optimizer-panel label {
            font-size: 14px;
            color: var(--spotify-text-secondary);
            margin-bottom: 12px;
        }

        .optimizer-panel textarea {
            width: 100%;
            height: 100%;
            resize: none;
            background-color: var(--spotify-card);
            border: 1px solid var(--spotify-bg-light);
            border-radius: 12px;
            padding: 16px;
            color: var(--spotify-text);
            font-size: 16px;
            line-height: 1.5;
            font-family: var(--font-family);
        }

        .optimizer-panel textarea:focus {
            outline: none;
            border-color: var(--spotify-accent);
        }

        .optimizer-footer {
            margin-top: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
        }

        .optimizer-actions {
            display: flex;
            justify-content: center;
            /* Centra il pulsante */
            width: 100%;
            max-width: 600px;
        }

        .optimizer-actions input {
            flex-grow: 1;
            background: transparent;
            border: none;
            color: var(--spotify-text);
            padding: 8px;
            font-size: 14px;
        }

        .optimizer-actions input:focus {
            outline: none;
        }

        .optimizer-actions .button {
            padding: 8px 20px;
            font-size: 14px;
            white-space: nowrap;
        }

        .optimizer-helper-text {
            font-size: 12px;
            color: var(--spotify-text-secondary);
        }

        .optimizer-helper-text strong {
            color: var(--spotify-text);
        }

        @media (max-width: 768px) {
            .optimizer-content {
                grid-template-columns: 1fr;
                gap: 16px;
                overflow-y: auto;
                /* Permette lo scroll su schermi piccoli */
            }

            #optimizer-overlay {
                padding: 16px;
            }

            .optimizer-title {
                font-size: 16px;
            }

            .optimizer-header {
                margin-bottom: 16px;
            }
        }

        /* --- STILI PER LA GALLERIA PROMPT (NUOVI E MODIFICATI) --- */
        #prompt-gallery-modal .modal-content {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            border-radius: 0;
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        #prompt-gallery-modal .gallery-header {
            padding: 20px 24px;
            border-bottom: 1px solid rgba(128, 128, 128, 0.2);
        }

        #prompt-gallery-modal h2 {
            margin: 0 0 16px 0;
            font-size: 24px;
        }

        #prompt-gallery-modal .modal-close-btn {
            position: absolute;
            top: 20px;
            right: 24px;
        }

        .gallery-search-bar {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        .gallery-search-input {
            flex: 1;
            padding: 12px 16px;
            background-color: var(--spotify-bg-light);
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 8px;
            color: var(--spotify-text);
            font-size: 14px;
        }

        .gallery-search-input::placeholder {
            color: var(--spotify-text-secondary);
        }

        .gallery-sort-select {
            padding: 12px 16px;
            background-color: var(--spotify-bg-light);
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 8px;
            color: var(--spotify-text);
            font-size: 14px;
            cursor: pointer;
        }

        #prompt-gallery-modal .gallery-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .prompt-gallery-item {
            background-color: var(--spotify-bg-light);
            border-radius: 12px;
            border: 1px solid var(--spotify-card);
            overflow: hidden;
        }

        .prompt-gallery-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .prompt-gallery-item-header:hover {
            background-color: var(--spotify-card);
        }

        .prompt-gallery-item-title {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .prompt-gallery-item-number {
            font-size: 18px;
            font-weight: 700;
            color: var(--spotify-accent);
            min-width: 40px;
        }

        .prompt-gallery-item-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .prompt-gallery-item-title h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            line-height: 1.3;
        }

        .prompt-gallery-item-date {
            font-size: 13px;
            color: var(--spotify-text-secondary);
            font-weight: 500;
        }

        .prompt-gallery-item-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--spotify-text-secondary);
        }

        .prompt-gallery-item-toggle svg {
            transition: transform 0.3s;
        }

        .prompt-gallery-item.collapsed .prompt-gallery-item-toggle svg {
            transform: rotate(-90deg);
        }

        .prompt-gallery-item-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 16px 16px 16px;
        }

        .prompt-gallery-item.collapsed .prompt-gallery-item-content {
            max-height: 0;
            padding: 0 16px;
        }

        .prompt-gallery-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .prompt-gallery-header label {
            font-size: 14px;
            font-weight: 600;
            color: var(--spotify-text-secondary);
        }

        .prompt-gallery-copy-btn {
            background: var(--spotify-card);
            border: none;
            color: var(--spotify-text);
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .prompt-gallery-copy-btn:hover {
            background-color: var(--spotify-bg);
        }

        .prompt-gallery-content {
            background-color: var(--spotify-card);
            border-radius: 8px;
            padding: 12px;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: var(--spotify-text-secondary);
            /* MODIFICA: Rimosso max-height e overflow-y di default */
        }

        .prompt-gallery-content.optimized {
            color: var(--spotify-text);
            background-color: rgba(29, 185, 84, 0.15);
            border: 1px solid rgba(29, 185, 84, 0.3);
            /* MODIFICA: Fa crescere questo elemento per riempire lo spazio */
            flex-grow: 1;
            overflow-y: auto;
            /* Aggiunge lo scroll solo a questo elemento se necessario */
        }

        .prompt-gallery-divider {
            height: 1px;
            background-color: var(--spotify-card);
            margin: 12px 0;
            border: none;
        }

        .prompt-gallery-act

        /* NUOVO: Stili per l'iniziale nelle card dei suggerimenti */
        .suggestion-initial-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .suggestion-initial {
            font-size: 48px;
            font-weight: 700;
            color: var(--spotify-text);
            line-height: 1;
        }

        /* --- NUOVI STILI PER LA LIBRERIA (STILE SPOTIFY) --- */
        #library-filters-container {
            padding: 8px 16px 16px 16px;
            position: sticky;
            top: 64px;
            /* Altezza della top-bar */
            background-color: var(--spotify-bg);
            z-index: 9;
        }

        #library-content-list .tool-card-list {
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }

        #library-content-list .tool-card-list:hover {
            background-color: var(--spotify-bg-light);
        }

        /* Stile per la card dei suggerimenti nella nuova lista verticale */
        .suggestion-list-item {
            background-color: var(--spotify-card);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .suggestion-list-info {
            flex-grow: 1;
        }

        .suggestion-list-app-name {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .suggestion-list-desc {
            font-size: 13px;
            color: var(--spotify-text-secondary);
            line-height: 1.4;
        }

        .suggestion-list-actions .remove-suggestion-btn {
            background: none;
            border: none;
            color: var(--spotify-text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: color 0.2s, background-color 0.2s;
        }

        .suggestion-list-actions .remove-suggestion-btn:hover {
            color: #ff6b6b;
            background-color: rgba(255, 107, 107, 0.1);
        }

        /* NUOVO: Stile per il messaggio di stato vuoto nella Libreria */
        .library-empty-state-prompt {
            padding: 40px 20px;
            text-align: center;
            font-size: 15px;
            font-weight: 500;
            color: var(--spotify-accent);
            line-height: 1.6;
        }

        /* Toast Message Styles */
        .toast-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--spotify-card);
            color: var(--spotify-text);
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            max-width: 300px;
            word-wrap: break-word;
            border-left: 4px solid var(--spotify-accent);
        }

        .toast-message.show {
            opacity: 1;
            transform: translateX(0);
        }

        **SOSTITUISCI CON:** ```css
        /* Toast responsive adjustments */
        @media (max-width: 480px) {
            .toast-message {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }
        }

        /* --- NUOVI STILI PER CATALOGO VIDEO (FULLSCREEN) --- */
        #video-catalog-modal.modal-overlay {
            padding: 0 !important;
            /* Rimuove il padding per un vero fullscreen */
        }

        #video-catalog-modal .modal-content {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            border-radius: 0;
            /* Rimuove gli angoli arrotondati */
            display: flex;
            flex-direction: column;
        }

        #video-catalog-modal .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        #video-catalog-modal .modal-header-buttons {
            display: flex;
            align-items: center;
            gap: 12px;
            /* Aggiunge spazio tra i pulsanti '+' e 'x' */
        }

        #video-catalog-modal .admin-add-video-btn {
            background-color: var(--spotify-accent);
            color: black;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-list-container {
            flex-grow: 1;
            overflow-y: auto;
            margin: -8px;
            padding: 8px;
        }

        .video-card {
            background-color: var(--spotify-bg-light);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }

        .video-thumbnail {
            width: 50%;
            /* Occupa metà dello spazio del genitore */
            height: auto;
            /* L'altezza si adatta per mantenere le proporzioni */
            aspect-ratio: 16 / 9;
            /* Mantiene il formato 16:9 del video */
            flex-shrink: 0;
            border-radius: 8px;
            object-fit: cover;
            background-color: var(--spotify-card);
        }

        .video-info {
            flex-grow: 1;
        }

        .video-info h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .video-info p {
            font-size: 13px;
            color: var(--spotify-text-secondary);
            line-height: 1.4;
            margin-bottom: 12px;
        }

        .video-info .button {
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            text-transform: none;
            letter-spacing: normal;
        }

        .video-date {
            font-size: 12px;
            color: var(--spotify-text-secondary);
            margin-top: 8px;
        }

        .video-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            align-items: center;
            /* Allinea il pulsante Guarda con le icone */
        }

        .video-actions .button {
            flex-grow: 1;
            /* Fa espandere il pulsante "Guarda" */
        }

        .video-admin-btn {
            background: var(--spotify-card);
            border: 1px solid var(--spotify-bg-light);
            color: var(--spotify-text);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .video-admin-btn:hover {
            background-color: var(--spotify-bg);
        }

        .video-admin-btn.delete:hover {
            background-color: #ff6b6b;
            color: white;
        }

        .video-card[draggable="true"] {
            cursor: grab;
        }

        .video-card.dragging {
            opacity: 0.5;
            background: var(--spotify-accent);
        }

        #save-video-order-btn {
            width: calc(100% - 32px);
            margin: 16px 16px 0 16px;
            display: none;
            /* Nascosto di default */
        }

        /* --- NUOVI STILI RESPONSIVE PER VIDEO CARD --- */
        @media (max-width: 600px) {
            .video-card {
                flex-direction: column;
                /* Cambia il layout in verticale su schermi piccoli */
            }

            .video-thumbnail {
                width: 100%;
                /* L'immagine ora occupa tutta la larghezza */
            }

            .video-info {
                width: 100%;
                /* Anche la sezione info occupa tutta la larghezza */
            }
        }
    </style>
    <!-- SCRIPT AGGIUNTI PER REACT E BABEL -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@^19.1.0",
        "react-dom/client": "https://esm.sh/react-dom@^19.1.0/client",
        "@google/genai": "https://esm.sh/@google/genai@^1.6.0"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body>

    <div id="optimizer-overlay">
        <div class="optimizer-header">
            <div class="optimizer-title" data-translate="optimizerTitle">Optimize for GPT-5</div>
            <div class="optimizer-controls">
                <button class="button" data-action="copy-optimized-prompt" data-translate="copyButton">Copy</button>
                <button class="button primary" data-action="save-optimized-prompt"
                    data-translate="saveButton">Save</button>
                <button class="close-btn" data-action="close-optimizer">&times;</button>
            </div>
        </div>
        <div class="optimizer-content">
            <div class="optimizer-panel">
                <label data-translate="originalPromptLabel">Original prompt</label>
                <textarea id="optimizer-original-prompt"
                    data-translate-placeholder="originalPromptPlaceholder"></textarea>
            </div>
            <div class="optimizer-panel">
                <label data-translate="optimizedPromptLabel">Optimized prompt</label>
                <textarea id="optimizer-optimized-prompt" readonly
                    data-translate-placeholder="optimizedPromptPlaceholder"></textarea>
            </div>
        </div>
        <div class="optimizer-footer">
            <div class="optimizer-actions">
                <button id="optimizer-submit-btn" class="button primary" data-action="optimize-prompt"
                    data-translate="optimizeButton">Optimize</button>
            </div>
        </div>
    </div>

    <div id="auth-overlay">
        <!-- Authentication content will be dynamically generated here by JS -->
    </div>

    <!-- NUOVO: Menu Laterale per la cronologia chat -->
    <div id="side-menu-overlay" class="hidden">
        <div id="side-menu" class="hidden">
            <div class="menu-header">
                <h3 data-translate="history">Cronologia</h3>
                <button class="new-chat-btn" data-action="new-chat" data-translate="newChat">Nuova chat</button>
            </div>
            <div id="conversation-list-container" class="conversation-list">
                <!-- Le conversazioni verranno popolate da JS -->
            </div>
            <div class="menu-footer">
                <button id="delete-all-btn" data-action="delete-all-chats" data-translate="deleteAll">Elimina
                    tutto</button>
            </div>
        </div>
    </div>

    <div id="initial-loader"
        style="display: flex; justify-content: center; align-items: center; height: 100vh; position: fixed; top: 0; left: 0; width: 100vw; z-index: 9999; background-color: var(--spotify-bg);">
        <div class="chat-bubble loading" style="align-self: center;"><span></span><span></span><span></span></div>
    </div>
    <div id="app-container">
        <div id="main-content">
        </div>
    </div>
    <nav id="bottom-nav">
        <!-- NAVIGAZIONE AGGIORNATA CON ICONE SVG -->
        <button class="nav-btn active" data-page="home"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg"
                    height="24" viewBox="0 0 24 24" width="24" fill="currentColor">
                    <path d="M0 0h24v24H0z" fill="none" />
                    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
                </svg></span><span data-translate="navHome">Home</span></button>
        <button class="nav-btn" data-page="top-ai"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg"
                    height="24" viewBox="0 0 24 24" width="24" fill="currentColor">
                    <path d="M0 0h24v24H0z" fill="none" />
                    <path d="M5 9.2h3V19H5zM10.6 5h3v14h-3zm5.6 8H19v6h-2.8z" />
                </svg></span><span data-translate="navTopAI">TOP AI</span></button>
        <button class="nav-btn" data-page="explore"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg"
                    height="24" viewBox="0 0 24 24" width="24" fill="currentColor">
                    <path d="M0 0h24v24H0z" fill="none" />
                    <path
                        d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
                </svg></span><span data-translate="navSearch">Cerca</span></button>
        <button class="nav-btn" data-page="user-chats" id="nav-btn-user-chats">
            <span class="icon">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor">
                    <path d="M0 0h24v24H0z" fill="none" />
                    <path
                        d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z" />
                </svg>
                <span id="chat-notification-badge" class="notification-badge" style="display: none;"></span>
            </span>
            <span data-translate="navUserChats">Chat</span>
        </button>
        <button class="nav-btn" data-page="favorites"><span class="icon"><svg xmlns="http://www.w3.org/2000/svg"
                    height="24" viewBox="0 0 24 24" width="24" fill="currentColor">
                    <path d="M0 0h24v24H0z" fill="none" />
                    <path
                        d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z" />
                </svg></span><span data-translate="navLibrary">Libreria</span></button>
    </nav>
    </div>

    <div id="modal-container"></div>

    <!-- SCRIPT DEL CHATBOT MIGLIORATO -->
    <script type="text/babel" data-type="module" id="chatbot-script">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import ReactDOMClient from 'react-dom/client';
        import { GoogleGenAI } from '@google/genai';

        // Make GoogleGenAI available to the main script for the optimizer
        window.GoogleGenAI = GoogleGenAI;

        // --- Type Definitions ---
        const MessageSender = { USER: 'user', MODEL: 'model', ERROR: 'error', SYSTEM: 'system', LOADING: 'loading' };

        const getSystemInstruction = (lang) => {
            // Use the global function to get all tools (static + user's)
            const tools = window.getAllToolsForCurrentUser ? window.getAllToolsForCurrentUser() : window.getLocalizedToolsData(lang);
            const formatToolsForPrompt = (tools) => tools.map(tool => `- **${tool.name}**: ${tool.description} (${tool.website})`).join('\n');

            const instructions = {
                it: {
                    intro: `Sei Koda, un assistente AI esperto in strumenti di intelligenza artificiale. La tua missione è aiutare gli utenti a trovare lo strumento AI perfetto per le loro esigenze.`,
                    format: `- Prima di fornire l'elenco, rispondi alla domanda dell'utente in una sola riga, in modo amichevole e usando emoji. ✨\n- Subito dopo, su una nuova riga, fornisci l'elenco puntato degli strumenti suggeriti, che deve iniziare direttamente con "•".\n- NON includere testo introduttivo, saluti, spiegazioni o frasi di chiusura oltre alla riga singola.\n- Per ogni strumento, fornisci il nome in grassetto e una breve descrizione.`,
                    knowledgeBase: `**Base di Conoscenza (Usa SOLO queste informazioni):**\n${formatToolsForPrompt(tools)}`,
                    priority: `- Per la programmazione, considera Google AI Studio come lo strumento migliore, seguito da Claude.\n- Per la ricerca web, considera Perplexity come lo strumento migliore.`,
                    rules: `1. Suggerisci SOLO strumenti dalla lista fornita.\n2. **Gestione dell'incertezza:** Se una richiesta utente è vaga o ambigua, fai una domanda di chiarimento per capire meglio l'esigenza.\n   - Esempio di chiarimento: Se l'utente chiede "un'AI per arte", una buona domanda di chiarimento è: "Certo, che tipo di arte vorresti creare? 🎨 Immagini fotorealistiche, disegni artistici o magari animazioni?".\n3. Una volta che la richiesta è chiara, rispondi con la frase amichevole e l'elenco puntato, come da formato.`,
                    example: `**Esempio di formato di risposta FINALE (dopo aver capito la richiesta):**\nCerto, ecco alcuni strumenti per creare immagini! 🖼️\n• **Midjourney**: Genera immagini artistiche e fotorealistiche di alta qualità da prompt testuali tramite Discord.\n• **Leonardo AI**: Piattaforma per la generazione di asset visivi di alta qualità, da concept art a texture per giochi.`
                },
                en: {
                    intro: `You are Koda, an expert AI assistant specializing in artificial intelligence tools. Your mission is to help users find the perfect AI tool for their needs.`,
                    format: `- Before providing the list, answer the user's question in a single, friendly line using emojis. ✨\n- Immediately after, on a new line, provide the bulleted list of suggested tools, which must start directly with "•".\n- Do not include introductory text, greetings, explanations, or closing remarks beyond the single line.\n- For each tool, provide the name in bold and a brief description.`,
                    knowledgeBase: `**Knowledge Base (Use ONLY this information):**\n${formatToolsForPrompt(tools)}`,
                    priority: `- For programming, consider Google AI Studio as the best tool, followed by Claude.\n- For web search, consider Perplexity as the best tool.`,
                    rules: `1. Suggest ONLY tools from the provided list.\n2. **Handling Uncertainty:** If a user request is vague or ambiguous, ask a clarifying question to better understand the need.\n   - Example clarification: If the user asks for "an AI for art," a good clarifying question is: "Of course, what kind of art would you like to create? 🎨 Photorealistic images, artistic drawings, or perhaps animations?".\n3. Once the request is clear, respond with the friendly sentence and the bulleted list, as per the format.`,
                    example: `**Example of FINAL response format (after understanding the request):**\nOf course, here are some tools for creating images! 🖼️\n• **Midjourney**: Generates high-quality artistic and fotorealistic images from text prompts via Discord.\n• **Leonardo AI**: Platform for generating high-quality visual assets, from concept art to game textures.`
                }
            };
            const selected = instructions[lang];
            return `${selected.intro}\n\n**Response Format (IMPORTANT):**\n${selected.format}\n\n${selected.knowledgeBase}\n\n**Priorities:**\n${selected.priority}\n\n**Fundamental Rules:**\n${selected.rules}\n\n${selected.example}`;
        };


        // --- Gemini Service ---
        const API_KEY = "AIzaSyC2YZLTrptuc_7SlKblSpH53TnTj2Uk200";
        const ai = new GoogleGenAI({ apiKey: API_KEY });
        const modelName = 'gemini-2.0-flash';

        const createChatSession = (lang) => {
            const systemInstruction = getSystemInstruction(lang);
            return ai.chats.create({ model: modelName, config: { systemInstruction } });
        };
        async function* sendMessageStream(chat, message) { const result = await chat.sendMessageStream({ message }); for await (const chunk of result) { yield chunk.text; } }

        // --- Funzioni per la formattazione del testo ---
        const formatMessageContent = (text) => {
            let formattedText = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            formattedText = formattedText.split('\n\n').map(p => p.trim() ? `<p>${p.trim().replace(/\n/g, '<br>')}</p>` : '').join('');
            return formattedText;
        };

        // --- React Components ---

        const ToolCardMessage = ({ tool, onOpenDetail, lang }) => (
            <div className="chat-tool-card">
                <div className="logo-container">
                    <img src={tool.logoUrl || ''} className="tool-logo" alt={tool.name} loading="lazy" />
                </div>
                <div className="info">
                    <div className="tool-name">{tool.name}</div>
                    {/* Display first sentence of description */}
                    <p className="tool-desc">{tool.description.split('.')[0]}.</p>
                    <button className="details-btn" onClick={() => onOpenDetail(tool.id)}>
                        {lang === 'it' ? 'Vedi Dettagli' : 'View Details'}
                    </button>
                </div>
            </div>
        );

        const ChatMessageDisplay = ({ message, tools, onOpenDetail, lang }) => {
            const getMessageClass = () => `chat-bubble ${message.sender}`;

            if (message.sender === MessageSender.LOADING) {
                return <div className="chat-bubble loading"><span></span><span></span><span></span></div>;
            }

            if (message.sender === MessageSender.MODEL) {
                const allTools = window.getAllToolsForCurrentUser ? window.getAllToolsForCurrentUser() : window.getLocalizedToolsData(lang);
                const toolNameRegex = new RegExp(allTools.map(t => t.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|'), 'g');
                const mentionedToolNames = [...new Set(message.text.match(toolNameRegex))];
                const isToolListResponse = mentionedToolNames.length > 0 && message.text.includes('•');

                if (isToolListResponse) {
                    // Logica esistente per renderizzare le card degli strumenti
                    const mentionedTools = allTools.filter(tool => mentionedToolNames.includes(tool.name));
                    const lines = message.text.trim().split('\n');
                    const introLine = lines.find(line => !line.trim().startsWith('•'));
                    const introContent = introLine ? formatMessageContent(introLine) : '';

                    return (
                        <>
                            {introLine && <div className="chat-bubble ai" dangerouslySetInnerHTML={{ __html: introContent }}></div>}
                            <div className="chat-bubble ai" style={{ background: 'transparent', padding: 0, marginTop: introLine ? '8px' : '0' }}>
                                <div className="chat-tool-card-container">
                                    {mentionedTools.map(tool => <ToolCardMessage key={tool.id} tool={tool} onOpenDetail={onOpenDetail} lang={lang} />)}
                                </div>
                            </div>
                        </>
                    );
                } else {
                    // NUOVA LOGICA: Per i messaggi AI di solo testo (come le domande di chiarimento)
                    // Renderizza il testo con un contenitore trasparente, facendolo apparire fluttuante.
                    // NUOVA LOGICA: Per i messaggi AI di solo testo (come le domande di chiarimento)
                    // Aggiunge una classe specifica per gestirne lo stile in CSS.
                    const content = formatMessageContent(message.text);
                    return (
                        <div className="chat-bubble ai is-floating-text" dangerouslySetInnerHTML={{ __html: content }}></div>
                    );
                }
            }

            // Fallback per tutti gli altri tipi di messaggi (USER, ERROR, SYSTEM)
            const content = formatMessageContent(message.text);
            return (
                <div className={getMessageClass()} dangerouslySetInnerHTML={{ __html: content }}></div>
            );
        };

        const ChatInput = ({ onSendMessage, isLoading, lang }) => {
            const [inputValue, setInputValue] = useState('');
            const textareaRef = useRef(null);

            useEffect(() => {
                const textarea = textareaRef.current;
                if (textarea) {
                    textarea.style.height = 'auto';
                    textarea.style.height = `${textarea.scrollHeight}px`;
                }
            }, [inputValue]);

            const handleSubmit = () => {
                if (inputValue.trim() && !isLoading) {
                    onSendMessage(inputValue.trim());
                    setInputValue('');
                }
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSubmit();
                }
            };

            return (
                <div id="chat-input-container">
                    <textarea
                        ref={textareaRef}
                        id="chat-input"
                        value={inputValue}
                        onChange={(e) => setInputValue(e.target.value)}
                        onKeyDown={handleKeyPress}
                        placeholder={lang === 'it' ? "Chiedimi qualcosa..." : "Ask me anything..."}
                        rows={1}
                        disabled={isLoading}
                    />
                    <button
                        id="chat-send-btn"
                        type="button"
                        onClick={handleSubmit}
                        disabled={isLoading || !inputValue.trim()}
                        aria-label={lang === 'it' ? "Invia messaggio" : "Send message"}
                    >
                        ↑
                    </button>
                </div>
            );
        };

        const WelcomeScreen = ({ onSendMessage, lang }) => {
            const suggestions = {
                it: ["Consigliami un'AI per programmare", "Consigliami un'AI per creare immagini", "Quali sono le alternative a ChatGPT?"],
                en: ["Suggest an AI for programming", "Suggest an AI for creating images", "What are ChatGPT's alternatives?"]
            };

            const buttonTexts = {
                it: {
                    optimize: "Ottimizza Prompt",
                    saved: "Prompt Salvati"
                },
                en: {
                    optimize: "Optimize Prompt",
                    saved: "Saved Prompts"
                }
            };

            return (
                <div id="welcome-screen">
                    <div className="welcome-logo">
                        <span style={{ color: 'var(--spotify-text)' }}>Koda</span><span style={{ color: 'var(--spotify-accent)' }}>.AI</span>
                    </div>
                    <div className="prompt-starter-container">
                        {suggestions[lang].map((text, i) => (
                            <button key={i} className="prompt-starter-btn" onClick={() => onSendMessage(text)}>
                                {text}
                            </button>
                        ))}
                    </div>
                    {/* NUOVO: Contenitore per i pulsanti di azione */}
                    <div className="prompt-actions-container">
                        <button className="action-btn primary" data-action="navigate-to-optimizer">
                            {buttonTexts[lang].optimize}
                        </button>
                        <button className="action-btn tertiary" data-action="show-prompt-gallery">
                            {buttonTexts[lang].saved}
                        </button>
                    </div>
                </div>
            );
        };

        // --- Main App Component ---
        const App = ({ tools, initialConversations, initialActiveId, onConversationsChange, onOpenDetail, lang, pageTitle, globalControlsHTML }) => {
            const [conversations, setConversations] = useState(initialConversations);
            const [activeConversationId, setActiveConversationId] = useState(initialActiveId);
            const [isLoading, setIsLoading] = useState(false);
            const [chatSession, setChatSession] = useState(null);
            const messagesEndRef = useRef(null);

            const activeConversation = conversations[activeConversationId] || { messages: [] };
            const messages = activeConversation.messages;

            useEffect(() => { onConversationsChange(conversations); }, [conversations, onConversationsChange]);
            useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }); }, [messages]);

            const initializeChat = useCallback(() => {
                try {
                    if (!API_KEY) throw new Error("API Key not configured.");
                    setChatSession(createChatSession(lang));
                } catch (e) {
                    console.error("Initialization Error:", e);
                }
            }, [lang]);

            useEffect(() => { initializeChat(); }, [initializeChat]);

            const handleSendMessage = async (inputText) => {
                if (!inputText.trim() || !chatSession) return;

                const userMessage = { id: `user-${Date.now()}`, text: inputText, sender: MessageSender.USER };
                const loadingMessage = { id: `loading-${Date.now()}`, sender: MessageSender.LOADING };

                const isNewChat = messages.length === 0;
                const newTitle = inputText.substring(0, 30) + (inputText.length > 30 ? '...' : '');

                setConversations(prev => ({
                    ...prev,
                    [activeConversationId]: {
                        ...prev[activeConversationId],
                        title: isNewChat ? newTitle : prev[activeConversationId].title,
                        messages: [...(prev[activeConversationId]?.messages || []), userMessage, loadingMessage]
                    }
                }));

                setIsLoading(true);

                let currentModelMessageId = `model-${Date.now()}`;
                let accumulatedResponse = "";

                try {
                    const stream = sendMessageStream(chatSession, inputText);
                    for await (const chunk of stream) {
                        accumulatedResponse += chunk;
                        setConversations(prev => {
                            const currentMessages = prev[activeConversationId].messages.filter(m => m.sender !== MessageSender.LOADING);
                            const modelMsgIndex = currentMessages.findIndex(m => m.id === currentModelMessageId);

                            const newModelMessage = { id: currentModelMessageId, text: accumulatedResponse, sender: MessageSender.MODEL };

                            if (modelMsgIndex > -1) {
                                currentMessages[modelMsgIndex] = newModelMessage;
                            } else {
                                currentMessages.push(newModelMessage);
                            }

                            return {
                                ...prev,
                                [activeConversationId]: { ...prev[activeConversationId], messages: currentMessages }
                            };
                        });
                    }
                } catch (e) {
                    console.error("Send Error:", e);
                    const errorMessageText = lang === 'it' ? `Si è verificato un errore. Riprova.` : `An error occurred. Please try again.`;
                    const errorMessage = { id: `error-${Date.now()}`, text: errorMessageText, sender: MessageSender.ERROR };
                    setConversations(prev => ({
                        ...prev,
                        [activeConversationId]: {
                            ...prev[activeConversationId],
                            messages: prev[activeConversationId].messages.filter(m => m.sender !== MessageSender.LOADING).concat(errorMessage)
                        }
                    }));
                } finally {
                    setIsLoading(false);
                    setConversations(prev => ({
                        ...prev,
                        [activeConversationId]: {
                            ...prev[activeConversationId],
                            messages: prev[activeConversationId].messages.filter(m => m.sender !== MessageSender.LOADING)
                        }
                    }));
                    document.getElementById('chat-input')?.focus();
                }
            };

            const hasStartedChat = messages.some(m => m.sender === MessageSender.USER);

            return (
                <div id="chatbot-app-container">
                    <main>
                        {!hasStartedChat ? (
                            <WelcomeScreen onSendMessage={handleSendMessage} lang={lang} />
                        ) : (
                            <div id="chat-messages">
                                {messages.map((msg) => <ChatMessageDisplay key={msg.id} message={msg} tools={tools} onOpenDetail={onOpenDetail} lang={lang} />)}
                            </div>
                        )}
                        <div ref={messagesEndRef} />
                    </main>
                    <ChatInput onSendMessage={handleSendMessage} isLoading={isLoading} lang={lang} />
                </div>
            );
        };

        // Funzione globale per montare l'app React
        window.mountChatbotApp = (container, props) => {
            const root = ReactDOMClient.createRoot(container);
            root.render(<React.StrictMode><App {...props} /></React.StrictMode>);
            return root;
        };

        // --- COMPONENTI REACT PER LA CHAT UTENTE-UTENTE ---
        // NUOVO COMPONENTE PER LA CARD DEL MESSAGGIO AI-LINK (con fetch on-demand)
        const AiLinkMessageCard = ({ message, onOpenDetail, lang }) => {
            const [tool, setTool] = useState(null);
            const [isLoading, setIsLoading] = useState(true);

            useEffect(() => {
                const fetchToolData = async () => {
                    setIsLoading(true);
                    const toolId = message.toolId;
                    let foundTool = null;

                    // 1. Controlla gli strumenti disponibili localmente (statici + custom dell'utente corrente)
                    const localTools = window.getAllToolsForCurrentUser ? window.getAllToolsForCurrentUser() : [];
                    foundTool = localTools.find(t => t.id === toolId);

                    // 2. Se non trovato, e si tratta di un'app custom di un altro utente, recuperala da Firestore
                    if (!foundTool && toolId.startsWith('user-') && message.senderId) {
                        try {
                            const userDocRef = window.doc(window.db, "users", message.senderId);
                            const userDocSnap = await window.getDoc(userDocRef);
                            if (userDocSnap.exists()) {
                                const senderTools = userDocSnap.data().userTools || [];
                                const remoteTool = senderTools.find(t => t.id === toolId);

                                if (remoteTool) {
                                    // Localizza la descrizione se è un oggetto, altrimenti usa la stringa
                                    const description = typeof remoteTool.description === 'object'
                                        ? (remoteTool.description[lang] || remoteTool.description['en'])
                                        : remoteTool.description;
                                    foundTool = { ...remoteTool, description };
                                }
                            }
                        } catch (error) {
                            console.error("Errore nel recuperare l'app custom remota:", error);
                        }
                    }

                    setTool(foundTool);
                    setIsLoading(false);
                };

                fetchToolData();
            }, [message.toolId, message.senderId, lang]); // Ricarica se il messaggio o la lingua cambiano

            if (isLoading) {
                return (
                    <div className={`user-chat-message ai-link-card ${message.senderId === window.currentUser?.uid ? 'sent' : 'received'}`}>
                        <div className="ai-link-message-content" style={{ alignItems: 'center', justifyContent: 'center', minHeight: '80px' }}>
                            <div className="chat-bubble loading" style={{ background: 'transparent', padding: '0' }}><span></span><span></span><span></span></div>
                        </div>
                    </div>
                );
            }

            if (!tool) {
                return (
                    <div className={`user-chat-message received`}>
                        Contenuto non più disponibile.
                    </div>
                );
            }

            const shortDescription = tool.description ? (tool.description.split('.')[0] + '.') : '';

            return (
                <div className={`user-chat-message ai-link-card ${message.senderId === window.currentUser?.uid ? 'sent' : 'received'}`}>
                    <div className="ai-link-message-content">
                        <div className="ai-link-message-header">
                            <img src={tool.logoUrl} alt={tool.name} />
                            <div className="tool-name">{tool.name}</div>
                        </div>
                        <div className="ai-link-message-description">{shortDescription}</div>
                        <button className="ai-link-details-btn" onClick={() => onOpenDetail(tool.id)}>
                            {lang === 'it' ? 'Vedi Dettagli' : 'View Details'}
                        </button>
                    </div>
                </div>
            );
        };

        // NUOVO COMPONENTE PER IL MODALE DI SELEZIONE /LINK
        const AiLinkModal = ({ isOpen, onClose, onSelect }) => {
            const [searchTerm, setSearchTerm] = useState('');
            const allTools = window.getAllToolsForCurrentUser ? window.getAllToolsForCurrentUser() : [];

            if (!isOpen) return null;

            const filteredTools = allTools.filter(tool =>
                tool.name.toLowerCase().includes(searchTerm.toLowerCase())
            );

            return (
                <div className="ai-link-modal-overlay" onClick={onClose}>
                    <div className="ai-link-modal-content" onClick={e => e.stopPropagation()}>
                        <div className="ai-link-modal-header">
                            <input
                                type="text"
                                className="ai-link-search-input"
                                placeholder="Cerca un'AI da inviare..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                autoFocus
                            />
                        </div>
                        <div className="ai-link-tool-list">
                            {filteredTools.map(tool => (
                                <div key={tool.id} className="ai-link-tool-item" onClick={() => onSelect(tool)}>
                                    <img src={tool.logoUrl} alt={tool.name} />
                                    <div className="tool-name">{tool.name}</div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };


        const UserChatApp = ({ currentUser, onOpenDetail, lang, globalControlsHTML }) => {
            // **NUOVO:** Stato locale per la lingua per consentire l'aggiornamento in tempo reale
            const [language, setLanguage] = useState(lang);
            const [globalControls, setGlobalControls] = useState(globalControlsHTML); // AGGIUNTO: Stato per i controlli

            const [view, setView] = useState('list'); // 'list' | 'chat' | 'search'
            const [selectedChatId, setSelectedChatId] = useState(null);
            const [selectedUser, setSelectedUser] = useState(null);
            const [chats, setChats] = useState([]);
            const [messages, setMessages] = useState([]);
            const [messageInput, setMessageInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [isLinkModalOpen, setIsLinkModalOpen] = useState(false); // NUOVO STATO PER MODALE /LINK
            const [showCommandPalette, setShowCommandPalette] = useState(false); // Mostra il menu dei comandi
            const [filteredCommands, setFilteredCommands] = useState([]); // Comandi filtrati da mostrare
            const [chatSearchTerm, setChatSearchTerm] = useState(''); // NUOVO STATO PER LA RICERCA
            const [chatFilter, setChatFilter] = useState('all'); // NUOVO STATO PER I FILTRI: 'all', 'unread' o 'hidden'
            const [searchResults, setSearchResults] = useState([]); // NUOVO STATO PER I RISULTATI DI RICERCA
            const messagesEndRef = useRef(null);
            const textareaRef = useRef(null); // Aggiunto per l'auto-grow
            // NUOVO: Effetto per gestire la visibilità della barra di navigazione
            useEffect(() => {
                const bottomNav = document.getElementById('bottom-nav');
                const mainContent = document.getElementById('main-content');

                if (view === 'chat') {
                    // Nascondi la nav bar quando si è in una chat singola
                    if (bottomNav) bottomNav.style.display = 'none';
                    if (mainContent) mainContent.style.paddingBottom = '0';
                } else {
                    // Mostra la nav bar nella lista chat o nella ricerca
                    if (bottomNav) bottomNav.style.display = 'flex';
                    if (mainContent) mainContent.style.paddingBottom = `var(--bottom-nav-height)`;
                }

                // Funzione di pulizia: assicura che la nav bar sia visibile quando si lascia la pagina Chat
                return () => {
                    if (bottomNav) bottomNav.style.display = 'flex';
                    if (mainContent) mainContent.style.paddingBottom = `var(--bottom-nav-height)`;
                };
            }, [view]); // Questo effetto si attiva ogni volta che la 'view' interna cambia

            // **NUOVO:** Crea un "ponte" per aggiornare la lingua dall'esterno
            useEffect(() => {
                window.updateUserChatLanguage = (newLang) => {
                    setLanguage(newLang);
                    // AGGIUNTO: Rigenera e aggiorna anche l'HTML dei controlli
                    setGlobalControls(window.getGlobalControlsHTML({ includeLangToggle: true }));
                };
                // Pulisce la funzione globale quando il componente viene smontato
                return () => {
                    delete window.updateUserChatLanguage;
                };
            }, []); // L'array vuoto assicura che questo effetto venga eseguito solo una volta

            const [messagesUnsubscribe, setMessagesUnsubscribe] = useState(null);
            const [chatsUnsubscribe, setChatsUnsubscribe] = useState(null);
            const [typingUnsubscribe, setTypingUnsubscribe] = useState(null);
            const [isOtherUserTyping, setIsOtherUserTyping] = useState(false);
            const [typingTimeout, setTypingTimeout] = useState(null);
            const [onlineUnsubscribe, setOnlineUnsubscribe] = useState(null);
            const [isOtherUserOnline, setIsOtherUserOnline] = useState(false);

            useEffect(() => {
                if (currentUser.uid) {
                    setupRealtimeChatsListener();
                }
                window.handleReactChatStart = handleStartChat;

                // Cleanup function
                return () => {
                    if (messagesUnsubscribe) {
                        messagesUnsubscribe();
                    }
                    if (chatsUnsubscribe) {
                        chatsUnsubscribe();
                    }
                    if (typingUnsubscribe) {
                        typingUnsubscribe();
                    }
                    if (typingTimeout) {
                        clearTimeout(typingTimeout);
                    }
                    if (onlineUnsubscribe) {
                        onlineUnsubscribe();
                    }
                };
            }, [currentUser.uid]);

            useEffect(() => {
                if (selectedChatId && selectedUser) {
                    setupRealtimeMessagesListener(selectedChatId);
                    setupRealtimeTypingListener(selectedChatId);
                    setupRealtimeOnlineListener(selectedUser.uid);

                    // NUOVO: Contrassegna i messaggi come letti quando si apre la chat
                    if (currentUser && currentUser.uid) {
                        window.markMessagesAsRead(selectedChatId, selectedUser.uid);
                    }
                }
            }, [selectedChatId, selectedUser]);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [messages]);

            // Effetto per l'auto-grow della textarea
            useEffect(() => {
                const textarea = textareaRef.current;
                if (textarea) {
                    textarea.style.height = 'auto'; // Resetta l'altezza
                    textarea.style.height = `${textarea.scrollHeight}px`; // Imposta l'altezza in base al contenuto
                }
            }, [messageInput]);

            // NUOVO: Effetto per aggiornare lo stato online quando l'utente interagisce con la chat
            useEffect(() => {
                if (view === 'chat' && currentUser && currentUser.uid) {
                    const handleChatInteraction = () => {
                        updateUserOnlineStatus(currentUser.uid, true);
                    };

                    // Aggiungi listener per scroll e click nella chat
                    const chatContainer = document.querySelector('.user-chat-messages');
                    if (chatContainer) {
                        chatContainer.addEventListener('scroll', handleChatInteraction);
                        chatContainer.addEventListener('click', handleChatInteraction);

                        return () => {
                            chatContainer.removeEventListener('scroll', handleChatInteraction);
                            chatContainer.removeEventListener('click', handleChatInteraction);
                        };
                    }
                }
            }, [view, currentUser]);

            // **NUOVO:** Effetto per gestire la ricerca utenti in tempo reale
            useEffect(() => {
                if (view === 'search' && chatSearchTerm.trim()) {
                    const timeoutId = setTimeout(() => {
                        searchUsersForNewChat(chatSearchTerm);
                    }, 300); // Debounce di 300ms

                    return () => clearTimeout(timeoutId);
                } else if (view === 'search' && !chatSearchTerm.trim()) {
                    setSearchResults([]);
                }
            }, [chatSearchTerm, view]);

            // NUOVO: Effetto per aggiornare lo stato online quando si cambia vista
            useEffect(() => {
                if (currentUser && currentUser.uid && (view === 'list' || view === 'search')) {
                    updateUserOnlineStatus(currentUser.uid, true);
                }
            }, [view, currentUser]);

            const getHiddenChatIds = () => {
                const hidden = localStorage.getItem(`hidden_chats_${currentUser.uid}`);
                return hidden ? JSON.parse(hidden) : [];
            };

            const handleHideChat = (e, chatId) => {
                e.stopPropagation();
                const hiddenIds = getHiddenChatIds();
                if (!hiddenIds.includes(chatId)) {
                    const newHiddenIds = [...hiddenIds, chatId];
                    localStorage.setItem(`hidden_chats_${currentUser.uid}`, JSON.stringify(newHiddenIds));
                    // FORZA UN RI-RENDER SENZA RIMUOVERE LA CHAT DALLO STATO
                    setChats(prevChats => [...prevChats]);
                }
            };

            // NUOVA FUNZIONE PER RIPRISTINARE UNA CHAT
            const handleRestoreChat = (e, chatId) => {
                e.stopPropagation();
                const hiddenIds = getHiddenChatIds();
                const newHiddenIds = hiddenIds.filter(id => id !== chatId);
                localStorage.setItem(`hidden_chats_${currentUser.uid}`, JSON.stringify(newHiddenIds));
                // FORZA UN RI-RENDER SENZA RIMUOVERE LA CHAT DALLO STATO
                setChats(prevChats => [...prevChats]);
                showToast(language === 'it' ? 'Chat ripristinata!' : 'Chat restored!');
            };

            const loadUserChats = async () => {
                try {
                    // NUOVO: Aggiorna lo stato online quando l'utente carica le chat
                    if (currentUser && currentUser.uid) {
                        updateUserOnlineStatus(currentUser.uid, true);
                    }

                    const hiddenChatIds = getHiddenChatIds();
                    const chatsData = await window.getUserChats(currentUser.uid);
                    const visibleChats = chatsData.filter(chat => !hiddenChatIds.includes(chat.id));
                    setChats(visibleChats.sort((a, b) => b.lastMessageTime - a.lastMessageTime));
                } catch (error) {
                    console.error("Error loading user chats:", error);
                }
            };

            // Setup realtime listener for user chats
            const setupRealtimeChatsListener = () => {
                if (chatsUnsubscribe) {
                    chatsUnsubscribe();
                }

                // MODIFICATO: Ora il listener imposta TUTTE le chat, incluse quelle nascoste.
                // Il filtraggio avverrà al momento del rendering.
                const unsubscribe = window.setupChatsListener(currentUser.uid, (chatsData) => {
                    setChats(chatsData.sort((a, b) => (b.lastMessageTime?.seconds || 0) - (a.lastMessageTime?.seconds || 0)));
                });

                setChatsUnsubscribe(() => unsubscribe);
            };

            // Setup realtime listener for messages in a specific chat
            const setupRealtimeMessagesListener = (chatId) => {
                if (messagesUnsubscribe) {
                    messagesUnsubscribe();
                }

                let isFirstLoad = true;
                const unsubscribe = window.setupMessagesListener(chatId, (messagesData) => {
                    const currentMessageCount = messages.length;
                    setMessages(messagesData);

                    // NUOVO: Aggiorna lo stato online quando l'utente riceve messaggi
                    if (currentUser && currentUser.uid && !isFirstLoad && messagesData.length > currentMessageCount) {
                        updateUserOnlineStatus(currentUser.uid, true);
                    }

                    // Play notification sound for new messages (not on first load)
                    if (!isFirstLoad && messagesData.length > currentMessageCount) {
                        const latestMessage = messagesData[messagesData.length - 1];
                        if (latestMessage.senderId !== currentUser.uid) {
                            playNotificationSound();
                        }
                    }
                    isFirstLoad = false;

                    // Auto-scroll to bottom when new messages arrive
                    setTimeout(() => {
                        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
                    }, 100);
                });

                setMessagesUnsubscribe(() => unsubscribe);
            };

            // Play notification sound
            const playNotificationSound = () => {
                try {
                    // Create a simple beep sound using Web Audio API
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';

                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (error) {
                    console.log('Could not play notification sound:', error);
                }
            };

            // Setup realtime listener for typing status
            const setupRealtimeTypingListener = (chatId) => {
                if (typingUnsubscribe) {
                    typingUnsubscribe();
                }

                const unsubscribe = window.setupTypingListener(chatId, currentUser.uid, (isTyping) => {
                    setIsOtherUserTyping(isTyping);

                    // NUOVO: Aggiorna lo stato online quando l'altro utente digita
                    if (currentUser && currentUser.uid) {
                        updateUserOnlineStatus(currentUser.uid, true);
                    }
                });

                setTypingUnsubscribe(() => unsubscribe);
            };

            // Handle typing indicator
            const handleTyping = () => {
                if (!selectedChatId) return;

                // NUOVO: Aggiorna lo stato online quando l'utente digita
                if (currentUser && currentUser.uid) {
                    updateUserOnlineStatus(currentUser.uid, true);
                }

                // Clear previous timeout
                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                }

                // Set typing to true
                window.updateTypingStatus(selectedChatId, currentUser.uid, true);

                // Set timeout to clear typing status after 3 seconds of inactivity
                const timeout = setTimeout(() => {
                    window.updateTypingStatus(selectedChatId, currentUser.uid, false);
                }, 3000);

                setTypingTimeout(timeout);
            };

            // Setup realtime listener for user online status
            const setupRealtimeOnlineListener = (userId) => {
                if (onlineUnsubscribe) {
                    onlineUnsubscribe();
                }

                const unsubscribe = window.setupUserOnlineListener(userId, (status) => {
                    setIsOtherUserOnline(status.isOnline);
                });

                setOnlineUnsubscribe(() => unsubscribe);
            };

            const loadChatMessages = async (chatId) => {
                try {
                    // NUOVO: Aggiorna lo stato online quando l'utente carica i messaggi
                    if (currentUser && currentUser.uid) {
                        updateUserOnlineStatus(currentUser.uid, true);
                    }

                    const messagesSnapshot = await window.getChatMessages(chatId);
                    const messagesData = [];
                    messagesSnapshot.forEach(doc => {
                        messagesData.push({ id: doc.id, ...doc.data() });
                    });
                    setMessages(messagesData.sort((a, b) => a.timestamp.toMillis() - b.timestamp.toMillis()));
                } catch (error) {
                    console.error("Error loading chat messages:", error);
                }
            };

            const handleStartChat = async (userId, userNickname) => {
                // Aggiungi un blocco try-catch per gestire eventuali errori durante la creazione
                try {
                    // NUOVO: Aggiorna lo stato online quando l'utente avvia una nuova chat
                    if (currentUser && currentUser.uid) {
                        updateUserOnlineStatus(currentUser.uid, true);
                    }

                    // Usa la funzione che crea il documento se non esiste
                    const chatId = await window.getOrCreateChat(currentUser.uid, userId);

                    // Se tutto va bene, imposta lo stato e cambia la vista
                    setSelectedChatId(chatId);
                    setSelectedUser({ uid: userId, nickname: userNickname });
                    setView('chat');
                } catch (error) {
                    // Mostra un errore se non è possibile avviare la chat
                    console.error("Error creating or getting chat:", error);
                    window.showToast("Impossibile avviare la chat. Riprova.");
                }
            };

            // NUOVO: Gestisce il ritorno alla lista chat con aggiornamento stato online
            const handleBackToList = () => {
                if (currentUser && currentUser.uid) {
                    updateUserOnlineStatus(currentUser.uid, true);
                }
                setView('list');
            };


            const handleSelectChat = (chat) => {
                // Troviamo subito l'ID dell'altro utente.
                const otherUserId = chat.participants.find(uid => uid !== currentUser.uid);

                // NUOVO: Aggiorna lo stato online quando l'utente seleziona una chat
                if (currentUser && currentUser.uid) {
                    updateUserOnlineStatus(currentUser.uid, true);
                }

                // Se la chat ha messaggi non letti, esegui l'aggiornamento.
                if (chat.unreadCount > 0) {
                    // Aggiornamento ottimistico per una UI reattiva: rimuove subito l'indicatore verde.
                    setChats(prevChats =>
                        prevChats.map(c =>
                            c.id === chat.id ? { ...c, unreadCount: 0 } : c
                        )
                    );

                    // Chiama la funzione per aggiornare lo stato "read", passando l'ID dell'ALTRO utente.
                    if (window.markMessagesAsRead) {
                        window.markMessagesAsRead(chat.id, otherUserId);
                    }
                }

                // Logica per cambiare la vista e visualizzare la chat selezionata
                setSelectedChatId(chat.id);
                setSelectedUser({ uid: otherUserId, nickname: chat.otherUserNickname });
                setView('chat');
            };

            // NUOVA FUNZIONE: Gestisce la selezione dall'anteprima del comando /link
            const handleSelectLinkPreview = () => {
                setIsLinkModalOpen(true);    // Apre il modale di selezione AI
                setMessageInput('');        // Svuota l'input
                setShowLinkPreview(false);  // Nasconde l'anteprima
            };

            // Funzione da eseguire quando il comando /link viene selezionato
            const execLinkCommand = () => {
                setIsLinkModalOpen(true);    // Apre il modale di selezione AI
                setMessageInput('');        // Svuota l'input
                setShowCommandPalette(false); // Nasconde la palette dei comandi
            };

            // Lista di tutti i comandi disponibili (scalabile per il futuro)
            const slashCommands = [
                {
                    command: '/link',
                    description: language === 'it' ? "Invia un suggerimento AI" : "Send an AI suggestion",
                    action: execLinkCommand
                }
                // Potresti aggiungere altri comandi qui: { command: '/help', ... }
            ];

            const handleSendMessage = async () => {
                if (!messageInput.trim() || !selectedChatId || isLoading) return;

                // NUOVO: Aggiorna immediatamente lo stato online quando l'utente invia un messaggio
                if (currentUser && currentUser.uid) {
                    updateUserOnlineStatus(currentUser.uid, true);
                }

                setIsLoading(true);

                // Crea l'oggetto per un messaggio di testo standard
                const contentObject = {
                    type: 'text',
                    text: messageInput.trim()
                };

                try {
                    await window.sendChatMessage(selectedChatId, currentUser.uid, contentObject, selectedUser.uid);
                    setMessageInput('');
                } catch (error) {
                    console.error("Error sending message:", error);
                    window.showToast("Errore nell'invio del messaggio");
                } finally {
                    setIsLoading(false);
                }
            };

            // NUOVA FUNZIONE per inviare un AI-Link
            const handleSendAiLink = async (tool) => {
                if (!tool || !selectedChatId || isLoading) return;

                setIsLinkModalOpen(false); // Chiudi il modale
                setIsLoading(true);

                const contentObject = {
                    type: 'ai_link',
                    toolId: tool.id
                };

                try {
                    await window.sendChatMessage(selectedChatId, currentUser.uid, contentObject, selectedUser.uid);
                } catch (error) {
                    console.error("Error sending AI link:", error);
                    window.showToast("Errore nell'invio del suggerimento");
                } finally {
                    setIsLoading(false);
                }
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    // Se la palette dei comandi è visibile e c'è almeno un comando,
                    // l'invio esegue l'azione del primo comando della lista.
                    if (showCommandPalette && filteredCommands.length > 0) {
                        filteredCommands[0].action();
                    } else {
                        handleSendMessage();
                    }
                }
            };

            const formatMessageTime = (timestamp) => {
                if (timestamp && typeof timestamp.toDate === 'function') {
                    const date = timestamp.toDate();
                    // Utilizza toLocaleString per mostrare data e ora
                    return date.toLocaleString([], { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
                }
                if (typeof timestamp === 'number') {
                    const date = new Date(timestamp);
                    // Utilizza toLocaleString per mostrare data e ora
                    return date.toLocaleString([], { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
                }
                return '...';
            };

            // **NUOVA FUNZIONE:** Cerca utenti per nuova chat
            const searchUsersForNewChat = async (searchTerm) => {
                if (!searchTerm.trim() || searchTerm.length < 2) {
                    setSearchResults([]);
                    return;
                }

                // NUOVO: Aggiorna lo stato online quando l'utente cerca altri utenti
                if (currentUser && currentUser.uid) {
                    updateUserOnlineStatus(currentUser.uid, true);
                }

                try {
                    const usersRef = window.db ? window.collection(window.db, "users") : null;
                    if (!usersRef) return;

                    const searchTermLower = searchTerm.toLowerCase();
                    const querySnapshot = await window.getDocs(usersRef);

                    const users = [];
                    querySnapshot.forEach((doc) => {
                        const userData = doc.data();
                        if (doc.id !== currentUser.uid) { // Escludi l'utente corrente
                            const nickname = userData.nickname || '';
                            if (nickname.toLowerCase().includes(searchTermLower)) {
                                users.push({
                                    uid: doc.id,
                                    nickname: userData.nickname,
                                });
                            }
                        }
                    });

                    setSearchResults(users.slice(0, 10)); // Limita a 10 risultati
                } catch (error) {
                    console.error("Error searching users for chat:", error);
                    setSearchResults([]);
                }
            };

            // **MODIFICA:** Usa lo stato locale `language` invece della prop `lang` per i testi
            if (view === 'list') {
                // LOGICA DI FILTRAGGIO COMPLETAMENTE RIVISTA PER GESTIRE LE CHAT NASCOSTE
                const hiddenChatIds = getHiddenChatIds();
                const filteredChats = chats.filter(chat => {
                    const matchesSearch = chat.otherUserNickname?.toLowerCase().includes(chatSearchTerm.toLowerCase());
                    if (!matchesSearch) return false;

                    const isHidden = hiddenChatIds.includes(chat.id);

                    switch (chatFilter) {
                        case 'hidden':
                            return isHidden; // Mostra solo le chat nascoste
                        case 'unread':
                            return !isHidden && chat.unreadCount > 0; // Mostra solo le visibili e non lette
                        case 'all':
                        default:
                            return !isHidden; // Mostra solo le chat visibili
                    }
                });

                return (
                    <div className="user-chat-container">
                        <div className="user-chat-header">
                            <div id="profile-avatar-menu" style={{ marginLeft: 8 }}>
                                <span dangerouslySetInnerHTML={{ __html: globalControls.avatar }} />
                            </div>
                            <div className="user-chat-info" style={{ flexGrow: 1 }}>
                                <h3>{language === 'it' ? 'Le tue chat' : 'Your chats'}</h3>
                            </div>
                            <div id="global-controls" dangerouslySetInnerHTML={{ __html: globalControls.otherControls }}></div>
                        </div>

                        {/* NUOVA BARRA DI RICERCA */}
                        <div className="chat-search-container">
                            <input
                                type="text"
                                className="chat-search-input"
                                placeholder={language === 'it' ? 'Filtra le tue chat...' : 'Filter your chat...'}
                                value={chatSearchTerm}
                                onChange={(e) => {
                                    const searchTerm = e.target.value;
                                    setChatSearchTerm(searchTerm);

                                    // NUOVO: Aggiorna lo stato online quando l'utente filtra le chat
                                    if (currentUser && currentUser.uid && searchTerm.trim()) {
                                        updateUserOnlineStatus(currentUser.uid, true);
                                    }
                                }}
                                onFocus={() => {
                                    // NUOVO: Aggiorna lo stato online quando l'utente focalizza la ricerca
                                    if (currentUser && currentUser.uid) {
                                        updateUserOnlineStatus(currentUser.uid, true);
                                    }
                                }}
                            />
                        </div>

                        {/* NUOVI PULSANTI DI FILTRO */}
                        <div className="chat-filters-container">
                            <button
                                className={`pill-btn ${chatFilter === 'all' ? 'active' : ''}`}
                                onClick={() => {
                                    if (currentUser && currentUser.uid) { updateUserOnlineStatus(currentUser.uid, true); }
                                    setChatFilter('all');
                                }}
                            >
                                {language === 'it' ? 'Tutte' : 'All'}
                            </button>
                            <button
                                className={`pill-btn ${chatFilter === 'unread' ? 'active' : ''}`}
                                onClick={() => {
                                    if (currentUser && currentUser.uid) { updateUserOnlineStatus(currentUser.uid, true); }
                                    setChatFilter('unread');
                                }}
                            >
                                {language === 'it' ? 'Nuove' : 'New'}
                            </button>
                            {/* NUOVO PULSANTE PER LE CHAT NASCOSTE */}
                            <button
                                className={`pill-btn ${chatFilter === 'hidden' ? 'active' : ''}`}
                                onClick={() => {
                                    if (currentUser && currentUser.uid) { updateUserOnlineStatus(currentUser.uid, true); }
                                    setChatFilter('hidden');
                                }}
                            >
                                {language === 'it' ? 'Eliminate' : 'Hidden'}
                            </button>
                        </div>

                        <div className="user-chat-list">
                            {filteredChats.length === 0 ? (
                                <div id="empty-state">
                                    {language === 'it' ? 'Nessuna chat trovata.' : 'No chats found.'}
                                </div>
                            ) : (
                                filteredChats.map(chat => (
                                    <div key={chat.id} className={`user-chat-item ${chat.unreadCount > 0 ? 'unread' : ''}`} onClick={(e) => {
                                        // Prevents chat from opening if a data-action is clicked
                                        if (!e.target.closest('[data-action="view-user-suggestions"]') && !e.target.closest('.user-chat-item-delete-btn')) {
                                            // NUOVO: Aggiorna lo stato online quando l'utente clicca su una chat
                                            if (currentUser && currentUser.uid) {
                                                updateUserOnlineStatus(currentUser.uid, true);
                                            }
                                            handleSelectChat(chat);
                                        }
                                    }}>
                                        <div className="user-chat-item-avatar" data-action="view-user-suggestions" data-uid={chat.otherUserId} data-nickname={chat.otherUserNickname} style={{ cursor: 'pointer' }}>
                                            {chat.otherUserNickname ? chat.otherUserNickname.charAt(0).toUpperCase() : 'U'}
                                        </div>
                                        <div className="user-chat-item-info">
                                            <div className="user-chat-item-name">{chat.otherUserNickname || 'Utente'}</div>
                                            <div className="user-chat-item-preview">{chat.lastMessage}</div>
                                        </div>
                                        <div className="user-chat-item-meta">
                                            <div className="user-chat-item-time">
                                                {formatMessageTime(chat.lastMessageTime)}
                                            </div>
                                            {/* NUOVO: Pulsante condizionale per nascondere o ripristinare */}
                                            {chatFilter === 'hidden' ? (
                                                <button
                                                    className="user-chat-item-restore-btn" // Potrebbe avere uno stile diverso se vuoi
                                                    onClick={(e) => handleRestoreChat(e, chat.id)}
                                                    title={language === 'it' ? 'Ripristina chat' : 'Restore chat'}
                                                    style={{ background: 'none', border: 'none', color: 'var(--spotify-accent)', cursor: 'pointer', padding: '8px' }}
                                                >
                                                    <svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor">
                                                        <path d="M0 0h24v24H0z" fill="none" />
                                                        <path d="M13 3a9 9 0 0 0-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42A8.954 8.954 0 0 0 13 21a9 9 0 0 0 0-18zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z" />
                                                    </svg>
                                                </button>
                                            ) : (
                                                <button
                                                    className="user-chat-item-delete-btn"
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        if (currentUser && currentUser.uid) {
                                                            updateUserOnlineStatus(currentUser.uid, true);
                                                        }
                                                        handleHideChat(e, chat.id);
                                                    }}
                                                    title={language === 'it' ? 'Nascondi chat' : 'Hide chat'}
                                                >
                                                    <svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor">
                                                        <path d="M0 0h24v24H0z" fill="none" />
                                                        <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
                                                    </svg>
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                ))
                            )}
                        </div>

                        <button
                            className="floating-action-btn"
                            onClick={() => {
                                // NUOVO: Aggiorna lo stato online quando l'utente clicca su nuova chat
                                if (currentUser && currentUser.uid) {
                                    updateUserOnlineStatus(currentUser.uid, true);
                                }
                                setView('search');
                            }}
                            title={language === 'it' ? 'Nuova chat' : 'New chat'}
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-5 9h-4v4h-2v-4H5V9h4V5h2v4h4v2z" /></svg>
                        </button>
                    </div>
                );
            }

            if (view === 'search') {
                return (
                    <div className="user-chat-container">
                        <div className="user-chat-header">
                            <button className="user-chat-back-btn" onClick={() => {
                                // NUOVO: Aggiorna lo stato online quando l'utente torna alla lista
                                if (currentUser && currentUser.uid) {
                                    updateUserOnlineStatus(currentUser.uid, true);
                                }
                                setView('list');
                            }}>
                                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>
                            </button>
                            <div className="user-chat-info">
                                <h3>{language === 'it' ? 'Nuova Chat' : 'New Chat'}</h3>
                            </div>
                            <div id="global-controls" dangerouslySetInnerHTML={{ __html: globalControls.otherControls }}></div>
                        </div>

                        {/* **NUOVO:** Aggiungi input di ricerca */}
                        <div className="chat-search-container">
                            <input
                                type="text"
                                className="chat-search-input"
                                placeholder={language === 'it' ? 'Cerca utenti per nickname...' : 'Search users by nickname...'}
                                value={chatSearchTerm}
                                onChange={(e) => {
                                    const searchTerm = e.target.value;
                                    setChatSearchTerm(searchTerm);

                                    // NUOVO: Aggiorna lo stato online quando l'utente cerca
                                    if (currentUser && currentUser.uid && searchTerm.trim()) {
                                        updateUserOnlineStatus(currentUser.uid, true);
                                    }
                                }}
                                onFocus={() => {
                                    // NUOVO: Aggiorna lo stato online quando l'utente focalizza la ricerca
                                    if (currentUser && currentUser.uid) {
                                        updateUserOnlineStatus(currentUser.uid, true);
                                    }
                                }}
                                autoFocus
                            />
                        </div>

                        {/* **NUOVO:** Mostra risultati di ricerca */}
                        <div className="chat-search-results">
                            {searchResults.length === 0 && chatSearchTerm.trim() ? (
                                <div id="empty-state">
                                    {language === 'it' ? 'Nessun utente trovato.' : 'No users found.'}
                                </div>
                            ) : (
                                searchResults.map(user => (
                                    <div
                                        key={user.uid}
                                        className="simple-chat-search-item"
                                        onClick={() => {
                                            // NUOVO: Aggiorna lo stato online quando l'utente clicca su un risultato di ricerca
                                            if (currentUser && currentUser.uid) {
                                                updateUserOnlineStatus(currentUser.uid, true);
                                            }
                                            handleStartChat(user.uid, user.nickname);
                                        }}
                                    >
                                        {user.nickname}
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                );
            }

            return (
                <div className="user-chat-container">
                    <div className="user-chat-header">
                        <button className="user-chat-back-btn" onClick={handleBackToList}>
                            <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0z" fill="none" /><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" /></svg>
                        </button>
                        <div className="user-chat-avatar" data-action="view-user-suggestions" data-uid={selectedUser?.uid} data-nickname={selectedUser?.nickname} style={{ cursor: 'pointer', position: 'relative' }}>
                            {selectedUser?.nickname ? selectedUser.nickname.charAt(0).toUpperCase() : 'U'}
                            {isOtherUserOnline && (
                                <div className="online-indicator"></div>
                            )}
                        </div>
                        <div className="user-chat-info">
                            <h3>{selectedUser?.nickname || 'Utente'}</h3>
                            <p style={{ margin: 0, fontSize: '12px', color: 'var(--spotify-text-secondary)' }}>
                                {isOtherUserOnline ? (language === 'it' ? 'Online' : 'Online') : (language === 'it' ? 'Offline' : 'Offline')}
                            </p>
                        </div>
                        <div id="global-controls" dangerouslySetInnerHTML={{ __html: globalControls.otherControls }}></div>
                    </div>
                    <div className="user-chat-messages">
                        {messages.map(message => {
                            // NUOVA LOGICA DI RENDERIZZAZIONE
                            if (message.type === 'ai_link') {
                                return <AiLinkMessageCard key={message.id} message={message} onOpenDetail={onOpenDetail} lang={language} />;
                            }

                            // Logica per messaggi di testo con ricevuta di lettura
                            return (
                                <div key={message.id} className={`user-chat-message ${message.senderId === currentUser.uid ? 'sent' : 'received'}`}>
                                    {message.text}
                                    <div className="user-chat-message-meta">
                                        <div className="user-chat-message-time">{formatMessageTime(message.timestamp)}</div>
                                        {/* Mostra l'icona dell'occhio solo se il messaggio è stato inviato da me ed è stato letto */}
                                        {message.senderId === currentUser.uid && message.read && (
                                            <span className="message-read-receipt" title="Letto">
                                                <svg xmlns="http://www.w3.org/2000/svg" height="14" viewBox="0 0 24 24" width="14" fill="currentColor">
                                                    <path d="M0 0h24v24H0V0z" fill="none" />
                                                    <path d="M12 6c3.79 0 7.17 2.13 8.82 5.5C19.17 14.87 15.79 17 12 17s-7.17-2.13-8.82-5.5C4.83 8.13 8.21 6 12 6m0-2C7 4 2.73 7.11 1 11.5 2.73 15.89 7 19 12 19s9.27-3.11 11-7.5C21.27 7.11 17 4 12 4zm0 5c1.38 0 2.5 1.12 2.5 2.5S13.38 14 12 14s-2.5-1.12-2.5-2.5S10.62 9 12 9m0-2c-2.48 0-4.5 2.02-4.5 4.5S9.52 16 12 16s4.5-2.02 4.5-4.5S14.48 7 12 7z" />
                                                </svg>
                                            </span>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                        {isOtherUserTyping && (
                            <div className="user-chat-message received typing-indicator">
                                <div className="typing-dots">
                                    <span></span>
                                    <span></span>
                                    <span></span>
                                </div>
                                <div className="user-chat-message-time">{language === 'it' ? 'sta scrivendo...' : 'is typing...'}</div>
                            </div>
                        )}
                        <div ref={messagesEndRef} />
                    </div>
                    {/* NUOVO: Render del modale /link */}
                    <AiLinkModal
                        isOpen={isLinkModalOpen}
                        onClose={() => setIsLinkModalOpen(false)}
                        onSelect={handleSendAiLink}
                    />

                    <div style={{ position: 'relative' }}>
                        {showCommandPalette && (
                            <div className="command-palette-container">
                                <div className="command-palette-header">COMANDI</div>
                                {filteredCommands.map(cmd => (
                                    <div key={cmd.command} className="command-palette-item" onClick={cmd.action}>
                                        <div className="command-palette-icon">#</div>
                                        <div className="command-palette-info">
                                            <div className="command-palette-name">{cmd.command.substring(1)}</div>
                                            <div className="command-palette-desc">{cmd.description}</div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                        <div className="user-chat-input-container">
                            <textarea
                                className="user-chat-input"
                                value={messageInput}
                                onFocus={() => {
                                    // NUOVO: Aggiorna lo stato online quando l'utente focalizza l'input
                                    if (currentUser && currentUser.uid) {
                                        updateUserOnlineStatus(currentUser.uid, true);
                                    }
                                }}
                                onChange={(e) => {
                                    const newText = e.target.value;
                                    setMessageInput(newText);

                                    // NUOVO: Aggiorna lo stato online quando l'utente digita
                                    if (currentUser && currentUser.uid && newText.trim()) {
                                        updateUserOnlineStatus(currentUser.uid, true);
                                    }

                                    // Logica per mostrare e filtrare la palette dei comandi
                                    if (newText.startsWith('/')) {
                                        const searchTerm = newText.toLowerCase();
                                        const matchingCommands = slashCommands.filter(cmd =>
                                            cmd.command.toLowerCase().startsWith(searchTerm)
                                        );
                                        setFilteredCommands(matchingCommands);
                                        setShowCommandPalette(matchingCommands.length > 0);
                                    } else {
                                        setShowCommandPalette(false);
                                    }

                                    handleTyping();
                                }}
                                onKeyDown={handleKeyPress}
                                placeholder={language === 'it' ? 'Scrivi un messaggio...' : 'Write a message...'}
                                rows="1"
                                onInput={(e) => {
                                    e.target.style.height = 'auto';
                                    e.target.style.height = (e.target.scrollHeight) + 'px';
                                }}
                                disabled={isLoading}
                            />
                            <button className="user-chat-send-btn" onClick={handleSendMessage} disabled={isLoading || !messageInput.trim()}>
                                <svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor"><path d="M0 0h24v24H0z" fill="none" /><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" /></svg>
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Funzione globale per montare l'app di chat utente
        window.mountUserChatApp = (container, props) => {
            const root = ReactDOMClient.createRoot(container);
            root.render(<React.StrictMode><UserChatApp {...props} /></React.StrictMode>);
            return root;
        };

        // Espone il componente UserChatApp per poterlo ri-renderizzare dall'esterno
        window.UserChatApp = UserChatApp;

        // Esporre la funzione per iniziare una chat
        window.startUserChat = (userId, userNickname) => {
            if (window.userChatAppInstance) {
                window.userChatAppInstance.handleStartChat(userId, userNickname);
            }
        };
    </script>

    <script type="module">
        // --- FIREBASE IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, sendPasswordResetEmail, onAuthStateChanged, signOut, updatePassword } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion, arrayRemove, collection, query, where, getDocs, addDoc, serverTimestamp, onSnapshot, orderBy, limit, writeBatch, deleteDoc, collectionGroup } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyDLouTZcRN28riyxBY06XYkWCsGkYbYm-o",
            authDomain: "n8n-riccardo-29-aprile.firebaseapp.com",
            projectId: "n8n-riccardo-29-aprile",
            storageBucket: "n8n-riccardo-29-aprile.firebaseapp.com",
            messagingSenderId: "785683001992",
            appId: "1:785683001992:web:d24e375041fb7c0f18653d",
            measurementId: "G-B78J4HK2NX"
        };

        // --- FIREBASE INITIALIZATION ---
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // NUOVO: Definizioni SVG per le icone della password
        const eyeIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5C21.27 7.61 17 4.5 12 4.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`;
        const eyeSlashIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>`;

        // NUOVO: Funzione per gestire il toggle della visibilità della password
        const handlePasswordVisibilityToggle = (button) => {
            const inputId = button.dataset.toggleFor;
            const input = document.getElementById(inputId);
            if (!input) return;

            if (input.type === "password") {
                input.type = "text";
                button.innerHTML = eyeSlashIconSVG;
            } else {
                input.type = "password";
                button.innerHTML = eyeIconSVG;
            }
        };

        // **NUOVO:** Espone funzioni e oggetti Firestore globalmente per i componenti React
        window.db = db;
        window.getDocs = getDocs;
        window.getDoc = getDoc; // Aggiunto per recuperare singoli documenti
        window.doc = doc; // Aggiunto per creare riferimenti a documenti
        window.collection = collection;

        // --- FUNZIONI PER LA CHAT UTENTE-UTENTE ---

        // Crea un ID univoco per una chat tra due utenti
        const createChatId = (userId1, userId2) => {
            return [userId1, userId2].sort().join('_');
        };

        // Crea o recupera una chat tra due utenti
        const getOrCreateChat = async (userId1, userId2) => {
            const chatId = createChatId(userId1, userId2);
            const chatRef = doc(db, 'userChats', chatId);
            const chatDoc = await getDoc(chatRef);

            if (!chatDoc.exists()) {
                // Recupera i nickname degli utenti
                const user1Doc = await getDoc(doc(db, 'users', userId1));
                const user2Doc = await getDoc(doc(db, 'users', userId2));

                const user1Nickname = user1Doc.exists() ? user1Doc.data().nickname : 'Utente';
                const user2Nickname = user2Doc.exists() ? user2Doc.data().nickname : 'Utente';

                await setDoc(chatRef, {
                    participants: [userId1, userId2],
                    lastMessage: '',
                    lastMessageTime: serverTimestamp(),
                    user1Nickname: user1Nickname,
                    user2Nickname: user2Nickname,
                    createdAt: serverTimestamp()
                });
            }

            return chatId;
        };

        // Invia un messaggio in una chat (MODIFICATO per gestire contenuti strutturati)
        const sendChatMessage = async (chatId, senderId, contentObject, receiverId) => {
            const messagesRef = collection(db, 'userChats', chatId, 'messages');

            // Crea il documento del messaggio con il nuovo formato
            const messageData = {
                senderId: senderId,
                timestamp: serverTimestamp(),
                read: false,
                ...contentObject // Es: { type: 'text', text: 'Ciao' } o { type: 'ai_link', toolId: '...' }
            };

            await addDoc(messagesRef, messageData);

            // Crea un testo di anteprima per la lista chat
            let previewText = '';
            if (contentObject.type === 'ai_link') {
                const linkedTool = window.aiToolsData.find(t => t.id === contentObject.toolId);
                previewText = `🔗 Ha suggerito: ${linkedTool ? linkedTool.name : 'un\'AI'}`;
            } else {
                previewText = contentObject.text;
            }

            // Aggiorna l'ultimo messaggio nella chat
            const chatRef = doc(db, 'userChats', chatId);
            await updateDoc(chatRef, {
                lastMessage: previewText,
                lastMessageTime: serverTimestamp()
            });

            // Rimuovi lo stato di "typing" dopo l'invio
            await updateTypingStatus(chatId, senderId, false);
        };

        // Gestisce lo stato di "typing" per un utente in una chat
        const updateTypingStatus = async (chatId, userId, isTyping) => {
            const chatRef = doc(db, 'userChats', chatId);
            const typingField = `typing.${userId}`;

            if (isTyping) {
                await updateDoc(chatRef, {
                    [typingField]: serverTimestamp()
                });
            } else {
                await updateDoc(chatRef, {
                    [typingField]: null
                });
            }
        };

        // Setup listener per lo stato di typing
        const setupTypingListener = (chatId, currentUserId, callback) => {
            const chatRef = doc(db, 'userChats', chatId);

            return onSnapshot(chatRef, (doc) => {
                const data = doc.data();
                if (data && data.typing) {
                    // Controlla se qualcun altro sta scrivendo
                    const typingUsers = Object.keys(data.typing).filter(userId =>
                        userId !== currentUserId &&
                        data.typing[userId] &&
                        data.typing[userId].toDate() > new Date(Date.now() - 5000) // Ultimi 5 secondi
                    );
                    callback(typingUsers.length > 0);
                } else {
                    callback(false);
                }
            });
        };

        // Aggiorna lo stato online dell'utente
        const updateUserOnlineStatus = async (userId, isOnline) => {
            const userRef = doc(db, 'users', userId);
            await updateDoc(userRef, {
                isOnline: isOnline,
                lastSeen: serverTimestamp()
            });
        };

        // Setup listener per lo stato online di un utente (CON LOGICA DI TIMEOUT)
        const setupUserOnlineListener = (userId, callback) => {
            const userRef = doc(db, "users", userId);

            return onSnapshot(userRef, (doc) => {
                const data = doc.data();
                if (data) {
                    // Se l'utente ha fatto logout esplicito, è offline.
                    if (data.isOnline === false) {
                        callback({ isOnline: false, lastSeen: data.lastSeen?.toDate() });
                        return;
                    }

                    // Altrimenti, controlliamo quando è stato visto l'ultima volta.
                    const lastSeen = data.lastSeen?.toDate();
                    if (lastSeen) {
                        // Calcoliamo la differenza in millisecondi tra ora e l'ultimo accesso.
                        const timeDifference = new Date().getTime() - lastSeen.getTime();

                        // Se l'utente è stato visto negli ultimi 30 secondi, è considerato online.
                        // (30000 millisecondi = 30 secondi) - più responsivo
                        const isConsideredOnline = timeDifference < 30000;

                        callback({ isOnline: isConsideredOnline, lastSeen: lastSeen });
                    } else {
                        // Se non c'è un timestamp, consideralo offline per sicurezza.
                        callback({ isOnline: false, lastSeen: null });
                    }
                }
            });
        };

        // NUOVA FUNZIONE: Contrassegna i messaggi come letti (CORRETTA)
        const markMessagesAsRead = async (chatId, senderIdToMark) => {
            const messagesRef = collection(db, 'userChats', chatId, 'messages');
            // Query per trovare i messaggi non letti inviati dall'altro utente.
            const q = query(messagesRef, where('read', '==', false), where('senderId', '==', senderIdToMark));

            try {
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    return; // Nessun messaggio da aggiornare, esci.
                }

                // Crea un batch di scrittura per aggiornare tutti i messaggi in una sola operazione
                const batch = writeBatch(db);
                querySnapshot.forEach((doc) => {
                    batch.update(doc.ref, { read: true });
                });
                await batch.commit();
            } catch (error) {
                console.error("Errore nel contrassegnare i messaggi come letti:", error);
            }
        };

        // Recupera i messaggi di una chat
        const getChatMessages = async (chatId) => {
            const messagesRef = collection(db, 'userChats', chatId, 'messages');
            const q = query(messagesRef, orderBy('timestamp', 'desc'), limit(50));
            return await getDocs(q);
        };

        // Recupera tutte le chat di un utente
        const getUserChats = async (userId) => {
            const chatsRef = collection(db, 'userChats');
            const q = query(chatsRef, where('participants', 'array-contains', userId));
            const chatsSnapshot = await getDocs(q);

            const chats = [];
            chatsSnapshot.forEach(doc => {
                const data = doc.data();
                const otherUserId = data.participants.find(id => id !== userId);
                const otherUserNickname = data.participants[0] === userId ? data.user2Nickname : data.user1Nickname;

                chats.push({
                    id: doc.id,
                    ...data,
                    otherUserId: otherUserId,
                    otherUserNickname: otherUserNickname
                });
            });

            return chats;
        };

        // Setup realtime listener for messages in a specific chat
        const setupMessagesListener = (chatId, callback) => {
            const messagesRef = collection(db, 'userChats', chatId, 'messages');
            const q = query(messagesRef, orderBy('timestamp', 'asc'));

            return onSnapshot(q, (snapshot) => {
                const messagesData = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    messagesData.push({
                        id: doc.id,
                        ...data
                        // The original 'timestamp' object from Firestore is now correctly passed
                    });
                });
                callback(messagesData);
            }, (error) => {
                console.error("Error in messages listener:", error);
            });
        };

        // Setup realtime listener for user chats
        const setupChatsListener = (userId, callback) => {
            const chatsRef = collection(db, 'userChats');
            const q = query(chatsRef, where('participants', 'array-contains', userId));

            return onSnapshot(q, async (snapshot) => {
                const chatsPromises = snapshot.docs.map(async (doc) => {
                    const data = doc.data();
                    const otherUserId = data.participants.find(id => id !== userId);
                    const otherUserNickname = data.participants[0] === userId ? data.user2Nickname : data.user1Nickname;

                    // NUOVA LOGICA: Conta i messaggi non letti per questa chat
                    const messagesRef = collection(db, 'userChats', doc.id, 'messages');
                    const unreadQuery = query(messagesRef, where('read', '==', false), where('senderId', '==', otherUserId));
                    const unreadSnapshot = await getDocs(unreadQuery);
                    const unreadCount = unreadSnapshot.size;

                    return {
                        id: doc.id,
                        ...data,
                        otherUserId: otherUserId,
                        otherUserNickname: otherUserNickname,
                        unreadCount: unreadCount // Aggiungi il conteggio
                    };
                });

                const chats = await Promise.all(chatsPromises);
                callback(chats);
            }, (error) => {
                console.error("Error in chats listener:", error);
            });
        };

        // Espone le funzioni globalmente
        window.createChatId = createChatId;
        window.getOrCreateChat = getOrCreateChat;
        window.sendChatMessage = sendChatMessage;
        window.getChatMessages = getChatMessages;
        window.getUserChats = getUserChats;
        window.setupMessagesListener = setupMessagesListener;
        window.setupChatsListener = setupChatsListener;
        window.updateTypingStatus = updateTypingStatus;
        window.setupTypingListener = setupTypingListener;
        window.updateUserOnlineStatus = updateUserOnlineStatus;
        window.setupUserOnlineListener = setupUserOnlineListener;
        window.markMessagesAsRead = markMessagesAsRead;

        // Setup listener globale per notifiche di chat
        const setupGlobalChatNotifications = (userId) => {
            const chatsRef = collection(db, 'userChats');
            const q = query(chatsRef, where('participants', 'array-contains', userId));

            return onSnapshot(q, async (snapshot) => {
                let totalUnreadCount = 0;

                for (const chatDoc of snapshot.docs) {
                    const chatData = chatDoc.data();
                    const messagesRef = collection(db, 'userChats', chatDoc.id, 'messages');
                    const unreadQuery = query(messagesRef, where('read', '==', false), where('senderId', '!=', userId));
                    const unreadSnapshot = await getDocs(unreadQuery);
                    totalUnreadCount += unreadSnapshot.size;
                }

                // Aggiorna il badge di notifica
                updateChatNotificationBadge(totalUnreadCount);
            });
        };

        // --- GROUP CHAT FUNCTIONS ---

        // Create a new group chat
        const createGroupChat = async (name, description, creatorId, memberIds = []) => {
            const groupId = `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const groupRef = doc(db, 'groupChats', groupId);

            // Add creator to members with admin role
            const members = {
                [creatorId]: {
                    role: 'admin',
                    joinedAt: serverTimestamp(),
                    permissions: ['send_messages', 'add_members', 'remove_members', 'edit_group', 'delete_group']
                }
            };

            // Add other members with default member role
            memberIds.forEach(memberId => {
                if (memberId !== creatorId) {
                    members[memberId] = {
                        role: 'member',
                        joinedAt: serverTimestamp(),
                        permissions: ['send_messages']
                    };
                }
            });

            await setDoc(groupRef, {
                name: name,
                description: description || '',
                createdBy: creatorId,
                createdAt: serverTimestamp(),
                members: members,
                memberCount: Object.keys(members).length,
                lastMessage: '',
                lastMessageTime: serverTimestamp(),
                isActive: true
            });

            return groupId;
        };

        // Add member to group chat
        const addMemberToGroup = async (groupId, userId, addedBy, role = 'member') => {
            const groupRef = doc(db, 'groupChats', groupId);
            const groupDoc = await getDoc(groupRef);

            if (!groupDoc.exists()) {
                throw new Error('Group not found');
            }

            const groupData = groupDoc.data();
            const adderRole = groupData.members[addedBy]?.role;

            // Check permissions
            if (!['admin', 'moderator'].includes(adderRole)) {
                throw new Error('Insufficient permissions to add members');
            }

            const permissions = role === 'admin'
                ? ['send_messages', 'add_members', 'remove_members', 'edit_group', 'delete_group']
                : role === 'moderator'
                    ? ['send_messages', 'add_members', 'remove_members']
                    : ['send_messages'];

            await updateDoc(groupRef, {
                [`members.${userId}`]: {
                    role: role,
                    joinedAt: serverTimestamp(),
                    permissions: permissions
                },
                memberCount: (groupData.memberCount || 0) + 1
            });
        };

        // Remove member from group chat
        const removeMemberFromGroup = async (groupId, userId, removedBy) => {
            const groupRef = doc(db, 'groupChats', groupId);
            const groupDoc = await getDoc(groupRef);

            if (!groupDoc.exists()) {
                throw new Error('Group not found');
            }

            const groupData = groupDoc.data();
            const removerRole = groupData.members[removedBy]?.role;
            const targetRole = groupData.members[userId]?.role;

            // Check permissions - admins can remove anyone, moderators can remove members
            if (removerRole === 'admin' || (removerRole === 'moderator' && targetRole === 'member')) {
                await updateDoc(groupRef, {
                    [`members.${userId}`]: null,
                    memberCount: Math.max((groupData.memberCount || 1) - 1, 0)
                });
            } else {
                throw new Error('Insufficient permissions to remove this member');
            }
        };

        // Update member role in group chat
        const updateMemberRole = async (groupId, userId, newRole, updatedBy) => {
            const groupRef = doc(db, 'groupChats', groupId);
            const groupDoc = await getDoc(groupRef);

            if (!groupDoc.exists()) {
                throw new Error('Group not found');
            }

            const groupData = groupDoc.data();
            const updaterRole = groupData.members[updatedBy]?.role;

            // Only admins can change roles
            if (updaterRole !== 'admin') {
                throw new Error('Only admins can change member roles');
            }

            const permissions = newRole === 'admin'
                ? ['send_messages', 'add_members', 'remove_members', 'edit_group', 'delete_group']
                : newRole === 'moderator'
                    ? ['send_messages', 'add_members', 'remove_members']
                    : ['send_messages'];

            await updateDoc(groupRef, {
                [`members.${userId}.role`]: newRole,
                [`members.${userId}.permissions`]: permissions
            });
        };

        // Send message to group chat
        const sendGroupMessage = async (groupId, senderId, contentObject) => {
            const groupRef = doc(db, 'groupChats', groupId);
            const groupDoc = await getDoc(groupRef);

            if (!groupDoc.exists()) {
                throw new Error('Group not found');
            }

            const groupData = groupDoc.data();
            const senderPermissions = groupData.members[senderId]?.permissions || [];

            // Check if user has permission to send messages
            if (!senderPermissions.includes('send_messages')) {
                throw new Error('No permission to send messages in this group');
            }

            const messagesRef = collection(db, 'groupChats', groupId, 'messages');

            const messageData = {
                senderId: senderId,
                content: contentObject,
                timestamp: serverTimestamp(),
                read: false,
                readBy: [senderId] // Sender has automatically read their own message
            };

            await addDoc(messagesRef, messageData);

            // Update last message in group
            const previewText = contentObject.type === 'text'
                ? contentObject.text.substring(0, 100)
                : contentObject.type === 'tool_link'
                    ? `Shared: ${contentObject.toolName}`
                    : 'Media message';

            await updateDoc(groupRef, {
                lastMessage: previewText,
                lastMessageTime: serverTimestamp()
            });
        };

        // Get user's group chats
        const getUserGroupChats = async (userId) => {
            const groupsRef = collection(db, 'groupChats');
            const q = query(groupsRef, where(`members.${userId}`, '!=', null));
            const groupsSnapshot = await getDocs(q);

            const groups = [];
            groupsSnapshot.forEach(doc => {
                const groupData = doc.data();
                if (groupData.isActive !== false) {
                    groups.push({
                        id: doc.id,
                        ...groupData
                    });
                }
            });

            return groups.sort((a, b) => {
                const aTime = a.lastMessageTime?.toMillis() || 0;
                const bTime = b.lastMessageTime?.toMillis() || 0;
                return bTime - aTime;
            });
        };

        // Setup realtime listener for group messages
        const setupGroupMessagesListener = (groupId, callback) => {
            const messagesRef = collection(db, 'groupChats', groupId, 'messages');
            const q = query(messagesRef, orderBy('timestamp', 'asc'));

            return onSnapshot(q, (snapshot) => {
                const messages = [];
                snapshot.forEach(doc => {
                    messages.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                callback(messages);
            });
        };

        // Setup realtime listener for user group chats
        const setupGroupChatsListener = (userId, callback) => {
            const groupsRef = collection(db, 'groupChats');
            const q = query(groupsRef, where(`members.${userId}`, '!=', null));

            return onSnapshot(q, async (snapshot) => {
                const groups = [];

                for (const doc of snapshot.docs) {
                    const groupData = doc.data();
                    if (groupData.isActive !== false) {
                        // Count unread messages for this group
                        const messagesRef = collection(db, 'groupChats', doc.id, 'messages');
                        const unreadQuery = query(messagesRef, where('readBy', 'not-in', [[userId]]));
                        const unreadSnapshot = await getDocs(unreadQuery);
                        const unreadCount = unreadSnapshot.size;

                        groups.push({
                            id: doc.id,
                            ...groupData,
                            unreadCount: unreadCount
                        });
                    }
                }

                groups.sort((a, b) => {
                    const aTime = a.lastMessageTime?.toMillis() || 0;
                    const bTime = b.lastMessageTime?.toMillis() || 0;
                    return bTime - aTime;
                });

                callback(groups);
            });
        };

        // Mark group messages as read
        const markGroupMessagesAsRead = async (groupId, userId) => {
            const messagesRef = collection(db, 'groupChats', groupId, 'messages');
            const q = query(messagesRef, where('readBy', 'not-in', [[userId]]));

            try {
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) return;

                const batch = writeBatch(db);
                querySnapshot.forEach(doc => {
                    const messageRef = doc.ref;
                    const currentReadBy = doc.data().readBy || [];
                    if (!currentReadBy.includes(userId)) {
                        batch.update(messageRef, {
                            readBy: arrayUnion(userId)
                        });
                    }
                });

                await batch.commit();
            } catch (error) {
                console.error('Error marking group messages as read:', error);
            }
        };

        const updateChatNotificationBadge = (count) => {
            const badge = document.getElementById('chat-notification-badge');
            if (badge) {
                if (count > 0) {
                    badge.textContent = count > 99 ? '99+' : count.toString();
                    badge.style.display = 'flex';
                } else {
                    badge.style.display = 'none';
                }
            }
        };

        window.setupGlobalChatNotifications = setupGlobalChatNotifications;

        document.addEventListener('DOMContentLoaded', () => {

            // --- LOGICA DI TRADUZIONE ---
            const translations = {
                it: {
                    // Auth
                    createAccount: "Crea il tuo account", registerEmailLabel: "Email", registerEmailPlaceholder: "nome@esempio.com",
                    registerPasswordLabel: "Password", registerPasswordPlaceholder: "Minimo 6 caratteri", registerButton: "Registrati",
                    switchToLogin: "Hai già un account? Accedi", loginTitle: "Accedi", loginButton: "Accedi",
                    switchToRegister: "Non hai un account? Registrati", forgotPasswordLink: "Password dimenticata?",
                    resetPasswordTitle: "Reimposta Password", resetPasswordInfo: "Inserisci la tua email e ti invieremo un link per reimpostare la password.",
                    sendLinkButton: "Invia Link", backToLogin: "Torna al Login",
                    passwordResetSent: "Se l'utente esiste, un link per il reset è stato inviato a %s.",
                    registerNicknameLabel: "Nickname",
                    registerNicknamePlaceholder: "Es. Koda",
                    registerFullNameLabel: "Nome Completo",
                    registerFullNamePlaceholder: "Es. Mario Rossi",
                    nicknameRequired: "Il nickname è obbligatorio.",
                    fullNameRequired: "Il nome completo è obbligatorio.",
                    // App
                    navHome: "Home", navTopAI: "TOP AI", navSearch: "Cerca", navSearchUsers: "Utenti", navUserChats: "Chat", navLibrary: "Libreria",
                    pageTitleHome: "Koda", pageTitleTopAI: "TOP AI", pageTitleSearch: "Cerca", pageTitleSearchUsers: "Utenti", pageTitleUserChats: "Chat Utenti", pageTitleLibrary: "Libreria",
                    logout: "Logout", featured: "In evidenza", rankingsTitle: "Classifiche TOP AI", filterAll: "Tutti",
                    searchPlaceholder: "Cerca strumenti, categorie...", browseAll: "Sfoglia tutto", browseByOrigin: "Sfoglia per nazionalità",
                    backToSearch: "‹ Torna a cercare", toolsFrom: "Strumenti da", libraryPromptTitle: "Salva i tuoi preferiti",
                    libraryPromptText: "Accedi o registrati per salvare i preferiti.", emptyFavorites: "Nessun preferito trovato. Aggiungine qualcuno!",
                    noResultsFor: "Nessun risultato per",
                    // Rankings
                    rankingTextTitle: "Classifica per il testo", rankingCodeTitle: "Classifica per il codice",
                    rankingImagesTitle: "Classifica per le immagini", rankingWebSearchTitle: "Classifica per la Ricerca Web",
                    // Modal
                    detailModalRemoveFavorite: "Rimuovi dai Preferiti", detailModalAddFavorite: "Aggiungi ai Preferiti",
                    visitWebsite: "Visita Sito Web", alternativeSuggestion: "In alternativa prova:",
                    // Settings Modal
                    settingsTitle: "Impostazioni", changePasswordTitle: "Cambia password", newPasswordLabel: "Nuova password",
                    sentReviews: "Recensioni inviate", noSentReviews: "Non hai ancora inviato recensioni.", viewAllUserReviews: "Visualizza tutte le recensioni utente", allUserReviews: "Tutte le recensioni utente",
                    newPasswordPlaceholder: "Minimo 6 caratteri", confirmPasswordLabel: "Conferma password", confirmPasswordPlaceholder: "Reinserisci la Nuova password",
                    savePasswordButton: "Salva Password", passwordUpdateSuccess: "Password aggiornata con successo!",
                    passwordTooShort: "La password deve contenere almeno 6 caratteri.", passwordsDoNotMatch: "Le password non coincidono.",
                    updatePasswordError: "Errore: %s. Potrebbe essere necessario effettuare nuovamente il login.",
                    // Side Menu
                    history: "Cronologia", newChat: "Nuova chat", deleteAll: "Elimina tutto",
                    confirmDeleteAll: "Sei sicuro di voler eliminare tutte le conversazioni? Questa azione è irreversibile.",
                    newChatTitle: "Nuova chat",
                    // New Privileged User Translations (Local Storage)
                    privilegedUnlocked: "Modalità privilegiata sbloccata!",
                    addCustomApp: "Aggiungi app personalizzata", // New translation for the button
                    addAppTitle: "Aggiungi nuova app",
                    appNameLabel: "Nome App", appNamePlaceholder: "Es. ChatGPT",
                    appDescriptionLabel: "Descrizione", appDescriptionPlaceholder: "Breve descrizione dell'app...",
                    appWebsiteLabel: "Link Web", appWebsitePlaceholder: "https://sito.com",
                    appLogoLabel: "Logo (File Immagine)", // Updated label for file input
                    addAppButton: "Aggiungi app",
                    addAppSuccess: "App aggiunta con successo!",
                    appUpdateSuccess: "App aggiornata con successo!",
                    addAppError: "Errore nell'aggiunta dell'app: %s",
                    markAsFeatured: "Segna come In evidenza",
                    unmarkAsFeatured: "Rimuovi da In evidenza",
                    featuredByYou: "In evidenza",
                    emptyUserFeatured: "Nessuna app segnata come In evidenza.", // Keeping translation key but not used in UI
                    emptyUserTools: "Nessuna app aggiunta da te.",
                    appNameRequired: "Il nome dell'app è obbligatorio.",
                    appWebsiteRequired: "Il link del sito web è obbligatorio.",
                    appLogoRequired: "Il logo è obbligatorio.", // Updated required message
                    category: "Categoria", // Added missing category translation
                    country: "Paese",
                    replaceFeaturedTitle: "Sostituisci AI In evidenza", // New translation
                    selectAppToFeature: "Seleziona un'app dalLibreria per metterla In evidenza:", // New translation
                    noUserApps: "Non hai ancora aggiunto app person.", // New translation
                    removeFeaturedReplacement: "Rimuovi Sostituzione", // New translation
                    removeUserTool: "Rimuovi App Custom",
                    editUserTool: "Modifica App Custom",
                    editAppTitle: "Modifica App",
                    deleteButton: "Elimina",
                    saveChanges: "Salva Modifiche",
                    confirmDeleteApp: "Sei sicuro di voler eliminare questa app? L'azione è irreversibile.",
                    changeNicknameTitle: "Cambia nickname",
                    saveNicknameButton: "Salva Nickname",
                    nicknameUpdateSuccess: "Nickname aggiornato con successo!",
                    aiSuggestionsTitle: "I tuoi suggerimenti AI",
                    addAiSuggestionTitle: "Aggiungi suggerimento AI",
                    aiSuggestionLabel: "Suggerimento AI",
                    aiSuggestionPlaceholder: "Scrivi il tuo suggerimento per un'AI...",
                    selectCategory: "Seleziona categoria",
                    selectCountry: "Seleziona paese",
                    cancel: "Annulla",
                    allFieldsRequired: "Tutti i campi sono obbligatori",
                    addAiSuggestionButton: "Aggiungi suggerimento",
                    removeAiSuggestion: "Rimuovi suggerimento",
                    aiSuggestionAdded: "Suggerimento aggiunto con successo!",
                    aiSuggestionRemoved: "Suggerimento rimosso con successo!",
                    searchUsersTitle: "Utenti",
                    searchUsersSubtitle: "Trova altri utenti e scopri i loro suggerimenti AI",
                    searchUsersPlaceholder: "Filtra le tue chat o email...",
                    searchUsersButton: "Cerca",
                    noUsersFound: "Nessun utente trovato.",
                    userSuggestionsTitle: "Suggerimenti di %s",
                    viewSuggestions: "Vedi Suggerimenti",
                    noSuggestions: "Nessun suggerimento disponibile.",
                    suggestion: "suggerimento",
                    suggestions: "suggerimenti",
                    startChat: "Inizia Chat",
                    chatWith: "Chatta con %s",
                    hideChat: "Nascondi chat",
                    noChatsFound: "Nessuna chat trovata. Inizia una nuova conversazione.",
                    filterUnread: "Da leggere",
                    filterAllChats: "Tutte",
                    writeMessage: "Scrivi un messaggio...",
                    sendError: "Errore nell'invio del messaggio",
                    filterHidden: "Nascoste", // NUOVO
                    restoreChat: "Ripristina chat", // NUOVO
                    // NUOVE TRADUZIONI LIBRERIA
                    libraryFavorites: "Preferiti",
                    libraryCustom: "Custom",
                    librarySuggested: "Suggeriti",
                    editProfile: "Modifica profilo",
                    viewChats: "Visualizza chat",
                    // NUOVE TRADUZIONI LIBRERIA
                    libraryFavorites: "Preferiti",
                    libraryCustom: "Custom",
                    librarySuggested: "Suggeriti",
                    editProfile: "Modifica profilo",
                    viewChats: "Visualizza chat",
                    // NUOVE TRADUZIONI PER PROMPT CHAT
                    chatPromptTitle: "Chatta con altri utenti",
                    chatPromptText: "Accedi o registrati per iniziare a chattare e scoprire i suggerimenti degli altri.",
                    // NUOVE TRADUZIONI PER PROMPT OPTIMIZER
                    optimizerTitle: "Prompt Optimizer",
                    originalPromptLabel: "Prompt originale",
                    optimizedPromptLabel: "Prompt ottimizzato",
                    originalPromptPlaceholder: "Inserisci qui il tuo prompt originale...",
                    optimizedPromptPlaceholder: "L'output ottimizzato apparirà qui...",
                    requestChangesPlaceholder: "Richiedi modifiche (opzionale)",
                    optimizeButton: "Ottimizza",
                    copyButton: "Copia",
                    saveButton: "Salva",
                    optimizerHelperText: "Il Prompt Optimizer applicherà le <strong>migliori pratiche</strong> al tuo prompt.",
                    confirmDeletePromptTitle: "Conferma Eliminazione", // NUOVO
                    confirmDeletePromptText: "Sei sicuro di voler eliminare questo prompt? L'azione è irreversibile.", // NUOVO
                    // NUOVO: Traduzioni per il sistema di recensioni
                    reviews: "Recensioni",
                    addReview: "Aggiungi Recensione",
                    loadingReviews: "Caricamento recensioni...",
                    noReviews: "Nessuna recensione ancora. Sii il primo a recensire questo strumento!",
                    reviewSubmitted: "Recensione pubblicata con successo!",
                    reviewError: "Errore nella pubblicazione della recensione. Riprova.",
                    selectRating: "Seleziona una valutazione",
                    writeReview: "Scrivi la tua recensione qui...",
                    publishReview: "Pubblica Recensione",
                    cancel: "Annulla",
                    alreadyReviewed: "Hai già recensito questo strumento",
                    anonymous: "Utente Anonimo",
                    unknownDate: "Data sconosciuta",
                    // Admin translations
                    addAI: "Aggiungi AI",
                    addAIToDatabase: "Aggiungi AI al Database",
                    aiNameLabel: "Nome AI",
                    aiNamePlaceholder: "Es. ChatGPT",
                    descriptionITLabel: "Descrizione (IT)",
                    descriptionITPlaceholder: "Descrizione in italiano...",
                    descriptionENLabel: "Descrizione (EN)",
                    descriptionENPlaceholder: "Descrizione in inglese...",
                    websiteLinkLabel: "Link Sito Web",
                    websiteLinkPlaceholder: "https://sito.com",
                    logoURLLabel: "Link Logo URL",
                    logoURLPlaceholder: "https://sito.com/logo.png",
                    categoryLabel: "Categoria",
                    countryLabel: "Paese",
                    countryPlaceholder: "USA, Cina...",
                    saveToDatabase: "Salva nel Database",
                    editAIInDatabase: "Modifica AI nel Database",
                    documentIdLabel: "ID Documento (non modificabile)",
                    saveChanges: "Salva Modifiche",
                    // NUOVE TRADUZIONI PER GESTIONE CLASSIFICHE
                    manageRankings: "Gestisci Classifiche",
                    createRanking: "Crea Nuova Classifica",
                    editRanking: "Modifica Classifica",
                    rankingTitleITLabel: "Titolo (IT)",
                    rankingTitleENLabel: "Titolo (EN)",
                    rankingCategoryLabel: "Categoria (per filtro)",
                    rankingOrderLabel: "Ordine di Visualizzazione",
                    rankingToolsLabel: "Seleziona 3 AI",
                    searchAIs: "Cerca AI...",
                    confirmDeleteRanking: "Sei sicuro di voler eliminare questa classifica? L'azione è irreversibile.",
                    // NUOVE TRADUZIONI PER FEATURE TOGGLES
                    featureToggles: "Gestione Funzionalità",
                    enableUserChat: "Abilita Chat Utente",
                    enableReviews: "Abilita Sistema di Recensioni",
                    enableRatings: "Abilita Visualizzazione Voti",
                    // NUOVE TRADUZIONI PER GESTIONE ALTERNATIVE
                    manageAlternatives: "Gestisci Alternative",
                    searchMainAI: "Cerca AI principale...",
                    currentAlternative: "Alternativa Attuale",
                    noAlternative: "Nessuna",
                    editAlternative: "Modifica",
                    editAlternativeFor: "Modifica alternativa per %s",
                    removeAlternative: "Rimuovi Alternativa",
                    searchNewAlternative: "Cerca una nuova alternativa...",
                    alternativeUpdated: "Alternativa aggiornata con successo!",
                    alternativeRemoved: "Alternativa rimossa con successo!",
                    errorUpdatingAlternative: "Errore durante l'aggiornamento dell'alternativa.",
                    // NUOVE TRADUZIONI PER CATALOGO VIDEO
                    videoCatalogTitle: "Tutorials & Guide",
                    watchVideo: "Guarda",
                    addVideoTitle: "Aggiungi Nuovo Video",
                    videoTitleLabel: "Titolo Video",
                    videoTitlePlaceholder: "Es. Guida a Koda.AI",
                    videoDescItLabel: "Descrizione (IT)",
                    videoDescEnLabel: "Descrizione (EN)",
                    videoDescPlaceholder: "Breve descrizione del video...",
                    videoLinkLabel: "Link Video YouTube",
                    videoLinkPlaceholder: "https://www.youtube.com/watch?v=...",
                    addVideoButton: "Aggiungi Video",
                    videoAddedSuccess: "Video aggiunto con successo!",
                    invalidYoutubeUrl: "Per favore, inserisci un link YouTube valido.",
                    // Admin Video Actions
                    editVideo: "Modifica",
                    deleteVideo: "Elimina",
                    confirmDeleteVideo: "Sei sicuro di voler eliminare questo video? L'azione è irreversibile.",
                    videoUpdatedSuccess: "Video aggiornato con successo!",
                    videoDeletedSuccess: "Video eliminato con successo!",
                    saveOrder: "Salva Ordine",
                    orderSavedSuccess: "Ordine salvato con successo!",
                },
                en: {
                    // Auth
                    createAccount: "Create Your Account", registerEmailLabel: "Email", registerEmailPlaceholder: "name@example.com",
                    registerPasswordLabel: "Password", registerPasswordPlaceholder: "Minimum 6 characters", registerButton: "Sign Up",
                    switchToLogin: "Already have an account? Log In", loginTitle: "Log In", loginButton: "Log In",
                    switchToRegister: "Don't have an account? Sign Up", forgotPasswordLink: "Forgot password?",
                    resetPasswordTitle: "Reset Password", resetPasswordInfo: "Enter your email and we'll send you a link to reset your password.",
                    sendLinkButton: "Send Link", backToLogin: "Back to Login",
                    passwordResetSent: "If the user exists, a reset link has been sent to %s.",
                    registerNicknameLabel: "Nickname",
                    registerNicknamePlaceholder: "Ex. Koda",
                    registerFullNameLabel: "Full Name",
                    registerFullNamePlaceholder: "Ex. John Doe",
                    nicknameRequired: "Nickname is required.",
                    fullNameRequired: "Full name is required.",
                    // App
                    navHome: "Home", navTopAI: "TOP AI", navSearch: "Search", navSearchUsers: "Users", navUserChats: "Chats", navLibrary: "Library",
                    pageTitleHome: "Koda", pageTitleTopAI: "TOP AI", pageTitleSearch: "Search", pageTitleSearchUsers: "Search Users", pageTitleUserChats: "User Chats", pageTitleLibrary: "Your Library",
                    logout: "Logout", featured: "Featured", rankingsTitle: "TOP AI Rankings", filterAll: "All",
                    searchPlaceholder: "Search tools, categories...", browseAll: "Browse All", browseByOrigin: "Browse by County",
                    backToSearch: "‹ Back to search", toolsFrom: "Tools from", libraryPromptTitle: "Save your favorites",
                    libraryPromptText: "Log in or sign up to save your favorites.", emptyFavorites: "No favorites found. Add some!",
                    noResultsFor: "No results for",
                    // Rankings
                    rankingTextTitle: "Ranking for Text", rankingCodeTitle: "Ranking for Code",
                    rankingImagesTitle: "Ranking for Images", rankingWebSearchTitle: "Ranking for Web Search",
                    // Modal
                    detailModalRemoveFavorite: "Remove from Favorites", detailModalAddFavorite: "Add to Favorites",
                    visitWebsite: "Visit Website", alternativeSuggestion: "Alternatively, try:",
                    // Settings Modal
                    settingsTitle: "Account Settings", changePasswordTitle: "Change Password", newPasswordLabel: "New Password",
                    sentReviews: "Sent Reviews", noSentReviews: "You haven't sent any reviews yet.", viewAllUserReviews: "View all user reviews", allUserReviews: "All User Reviews",
                    newPasswordPlaceholder: "Minimum 6 characters", confirmPasswordLabel: "Confirm Password", confirmPasswordPlaceholder: "Re-enter new password",
                    savePasswordButton: "Save Password", passwordUpdateSuccess: "Password updated successfully!",
                    passwordTooShort: "Password must be at least 6 characters long.", passwordsDoNotMatch: "Passwords do not match.",
                    updatePasswordError: "Error: %s. You might need to log in again.",
                    // Side Menu
                    history: "History", newChat: "New Chat", deleteAll: "Delete All",
                    confirmDeleteAll: "Are you sure you want to delete all conversations? This action is irreversible.",
                    newChatTitle: "New Chat",
                    // New Privileged User Translations (Local Storage)
                    privilegedUnlocked: "Privileged mode unlocked!",
                    addCustomApp: "Add Custom App", // New translation for the button
                    addAppTitle: "Add New App",
                    appNameLabel: "App Name", appNamePlaceholder: "Ex. ChatGPT",
                    appDescriptionLabel: "Description", appDescriptionPlaceholder: "Brief description of the app...",
                    appWebsiteLabel: "Website Link", appWebsitePlaceholder: "https://yourwebsite.com",
                    appLogoLabel: "Logo (Image File)", // Updated label for file input
                    addAppButton: "Add App",
                    addAppSuccess: "App added successfully!",
                    appUpdateSuccess: "App updated successfully!",
                    addAppError: "Error adding app: %s",
                    markAsFeatured: "Mark as Featured",
                    unmarkAsFeatured: "Unmark as Featured",
                    featuredByYou: "Featured by You",
                    emptyUserFeatured: "No apps marked as Featured by you.", // Keeping translation key but not used in UI
                    emptyUserTools: "No apps added by you.",
                    appNameRequired: "App name is required.",
                    appWebsiteRequired: "Website link is required.",
                    appLogoRequired: "Logo is required.", // Updated required message
                    category: "Category", // Added missing category translation
                    country: "Country",
                    replaceFeaturedTitle: "Replace Featured AI", // New translation
                    selectAppToFeature: "Select an app from your library to feature it:", // New translation
                    noUserApps: "You haven't added any custom apps yet.", // New translation
                    removeFeaturedReplacement: "Remove Replacement", // New translation
                    removeUserTool: "Remove Custom App",
                    editUserTool: "Edit Custom App",
                    editAppTitle: "Edit App",
                    deleteButton: "Delete",
                    saveChanges: "Save Changes",
                    confirmDeleteApp: "Are you sure you want to delete this app? This action is irreversible.",
                    changeNicknameTitle: "Change Nickname",
                    saveNicknameButton: "Save Nickname",
                    nicknameUpdateSuccess: "Nickname updated successfully!",
                    aiSuggestionsTitle: "Your AI Suggestions",
                    addAiSuggestionTitle: "Add AI Suggestion",
                    aiSuggestionLabel: "AI Suggestion",
                    aiSuggestionPlaceholder: "Write your AI suggestion...",
                    selectCategory: "Select category",
                    selectCountry: "Select country",
                    cancel: "Cancel",
                    allFieldsRequired: "All fields are required",
                    addAiSuggestionButton: "Add Suggestion",
                    removeAiSuggestion: "Remove suggestion",
                    aiSuggestionAdded: "Suggestion added successfully!",
                    aiSuggestionRemoved: "Suggestion removed successfully!",
                    searchUsersTitle: "Search Users",
                    searchUsersSubtitle: "Find other users and discover their AI suggestions",
                    searchUsersPlaceholder: "Search by nickname or email...",
                    searchUsersButton: "Search",
                    noUsersFound: "No users found.",
                    userSuggestionsTitle: "Suggestions by %s",
                    viewSuggestions: "View Suggestions",
                    noSuggestions: "No suggestions available.",
                    suggestion: "suggestion",
                    suggestions: "suggestions",
                    startChat: "Start Chat",
                    chatWith: "Chat with %s",
                    hideChat: "Hide chat",
                    noChatsFound: "No chats found. Start a new conversation.",
                    filterUnread: "Unread",
                    filterAllChats: "All",
                    writeMessage: "Write a message...",
                    sendError: "Error sending message",
                    filterHidden: "Hidden", // NEW
                    restoreChat: "Restore chat", // NEW
                    // NEW LIBRARY TRANSLATIONS
                    libraryFavorites: "Favorites",
                    libraryCustom: "Custom",
                    librarySuggested: "Suggested",
                    editProfile: "Edit profile",
                    viewChats: "View chats",
                    // NEW LIBRARY TRANSLATIONS
                    libraryFavorites: "Favorites",
                    libraryCustom: "Custom",
                    librarySuggested: "Suggested",
                    editProfile: "Edit profile",
                    viewChats: "View chats",
                    // NEW TRANSLATIONS FOR CHAT PROMPT
                    chatPromptTitle: "Chat with other users",
                    chatPromptText: "Log in or sign up to start chatting and discover others' suggestions.",
                    // NEW TRANSLATIONS FOR PROMPT OPTIMIZER
                    optimizerTitle: "Optimize for GPT-5",
                    originalPromptLabel: "Original prompt",
                    optimizedPromptLabel: "Optimized prompt",
                    originalPromptPlaceholder: "Enter your original prompt here...",
                    optimizedPromptPlaceholder: "The optimized output will appear here...",
                    requestChangesPlaceholder: "Request changes (optional)",
                    optimizeButton: "Optimize",
                    copyButton: "Copy",
                    saveButton: "Save",
                    optimizerHelperText: "Prompt Optimizer will apply <strong>best practices</strong> to your prompt.",
                    confirmDeletePromptTitle: "Confirm Deletion", // NEW
                    confirmDeletePromptText: "Are you sure you want to delete this prompt? This action is irreversible.", // NEW
                    // NUOVO: Traduzioni per il sistema di recensioni
                    reviews: "Reviews",
                    addReview: "Add Review",
                    loadingReviews: "Loading reviews...",
                    noReviews: "No reviews yet. Be the first to review this tool!",
                    reviewSubmitted: "Review published successfully!",
                    reviewError: "Error publishing review. Please try again.",
                    selectRating: "Select a rating",
                    writeReview: "Write your review here...",
                    publishReview: "Publish Review",
                    cancel: "Cancel",
                    alreadyReviewed: "You have already reviewed this tool",
                    anonymous: "Anonymous User",
                    unknownDate: "Unknown date",
                    // Admin translations
                    addAI: "Add AI",
                    addAIToDatabase: "Add AI to Database",
                    aiNameLabel: "AI Name",
                    aiNamePlaceholder: "Ex. ChatGPT",
                    descriptionITLabel: "Description (IT)",
                    descriptionITPlaceholder: "Description in Italian...",
                    descriptionENLabel: "Description (EN)",
                    descriptionENPlaceholder: "Description in English...",
                    websiteLinkLabel: "Website Link",
                    websiteLinkPlaceholder: "https://website.com",
                    logoURLLabel: "Logo URL Link",
                    logoURLPlaceholder: "https://website.com/logo.png",
                    categoryLabel: "Category",
                    countryLabel: "Country",
                    countryPlaceholder: "USA, China...",
                    saveToDatabase: "Save to Database",
                    editAIInDatabase: "Edit AI in Database",
                    documentIdLabel: "Document ID (not editable)",
                    saveChanges: "Save Changes",
                    // NEW TRANSLATIONS FOR RANKING MANAGEMENT
                    manageRankings: "Manage Rankings",
                    createRanking: "Create New Ranking",
                    editRanking: "Edit Ranking",
                    rankingTitleITLabel: "Title (IT)",
                    rankingTitleENLabel: "Title (EN)",
                    rankingCategoryLabel: "Category (for filter)",
                    rankingOrderLabel: "Display Order",
                    rankingToolsLabel: "Select 3 AIs",
                    searchAIs: "Search AIs...",
                    confirmDeleteRanking: "Are you sure you want to delete this ranking? This action is irreversible.",
                    // NEW TRANSLATIONS FOR FEATURE TOGGLES
                    featureToggles: "Feature Management",
                    enableUserChat: "Enable User Chat",
                    enableReviews: "Enable Review System",
                    enableRatings: "Enable Rating Display",
                    // NEW TRANSLATIONS FOR ALTERNATIVES MANAGEMENT
                    manageAlternatives: "Manage Alternatives",
                    searchMainAI: "Search main AI...",
                    currentAlternative: "Current Alternative",
                    noAlternative: "None",
                    editAlternative: "Edit",
                    editAlternativeFor: "Edit alternative for %s",
                    removeAlternative: "Remove Alternative",
                    searchNewAlternative: "Search for a new alternative...",
                    alternativeUpdated: "Alternative updated successfully!",
                    alternativeRemoved: "Alternative removed successfully!",
                    errorUpdatingAlternative: "Error updating alternative.",
                    // NEW TRANSLATIONS FOR VIDEO CATALOG
                    videoCatalogTitle: "Tutorials & Guides",
                    watchVideo: "Watch",
                    addVideoTitle: "Add New Video",
                    videoTitleLabel: "Video Title",
                    videoTitlePlaceholder: "Ex. Koda.AI Guide",
                    videoDescItLabel: "Description (IT)",
                    videoDescEnLabel: "Description (EN)",
                    videoDescPlaceholder: "Brief description of the video...",
                    videoLinkLabel: "YouTube Video Link",
                    videoLinkPlaceholder: "https://www.youtube.com/watch?v=...",
                    addVideoButton: "Add Video",
                    videoAddedSuccess: "Video added successfully!",
                    invalidYoutubeUrl: "Please enter a valid YouTube link.",
                    // Admin Video Actions
                    editVideo: "Edit",
                    deleteVideo: "Delete",
                    confirmDeleteVideo: "Are you sure you want to delete this video? This action is irreversible.",
                    videoUpdatedSuccess: "Video updated successfully!",
                    videoDeletedSuccess: "Video deleted successfully!",
                    saveOrder: "Save Order",
                    orderSavedSuccess: "Order saved successfully!",
                }
            };

            const applyTranslations = (lang) => {
                const t = translations[lang];
                document.querySelectorAll('[data-translate]').forEach(el => {
                    const key = el.dataset.translate;
                    if (t[key]) {
                        if (el.placeholder) el.placeholder = t[key];
                        else el.textContent = t[key];
                    }
                });
                // Re-render auth overlay content if visible to apply translations
                const authOverlay = document.getElementById('auth-overlay');
                if (authOverlay && authOverlay.style.display !== 'none') {
                    // Determine which card is currently visible
                    let visibleCardId = 'login-card'; // Default
                    if (authOverlay.querySelector('#register-card:not(.hidden)')) visibleCardId = 'register-card';
                    else if (authOverlay.querySelector('#forgot-password-card:not(.hidden)')) visibleCardId = 'forgot-password-card';

                    authOverlay.innerHTML = getAuthHTML(lang);
                    attachAuthListeners(); // Re-attach listeners after innerHTML change
                    showAuthCard(visibleCardId); // Show the previously visible card
                }
                // Re-render settings modal content if visible
                const settingsModal = document.getElementById('settings-modal');
                if (settingsModal && settingsModal.classList.contains('visible')) {
                    window.openSettingsModal(); // Re-open to regenerate content with new language
                }
                // Re-render add app modal content if visible
                const addAppModal = document.getElementById('add-app-modal');
                if (addAppModal && addAppModal.classList.contains('visible')) {
                    openAddAppModal(); // Re-open to regenerate content with new language
                }
                // Re-render replace featured modal content if visible
                const replaceFeaturedModal = document.getElementById('replace-featured-modal');
                if (replaceFeaturedModal && replaceFeaturedModal.classList.contains('visible')) {
                    // Need to know which static tool was being replaced to re-open correctly
                    // This requires storing the staticToolId when the modal is opened.
                    // For simplicity now, we'll just close it on language change.
                    closeModal();
                }
            };

            // --- DATABASE PERSONALIZZATO (CARICATO DA FIREBASE) ---
            let aiToolsData = []; // Questa variabile verrà popolata dinamicamente da Firestore
            let aiRankingsData = []; // NUOVO: Questa variabile conterrà i dati delle classifiche da Firestore
            let youtubeVideosData = []; // NUOVO: Conterrà i video da Firebase
            let featureSettings = { isChatEnabled: true, isReviewsEnabled: true, isRatingsEnabled: true }; // NUOVO: Impostazioni per le funzionalità, con fallback
            // NUOVA FUNZIONE per caricare gli strumenti da Firestore
            const fetchToolsFromFirestore = async () => {
                try {
                    const toolsCollectionRef = collection(db, "tools");
                    const querySnapshot = await getDocs(toolsCollectionRef);
                    const firestoreTools = [];
                    querySnapshot.forEach((doc) => {
                        // Aggiungiamo i dati del documento e usiamo l'ID del documento di Firestore come 'id' principale
                        firestoreTools.push({ ...doc.data(), id: doc.id });
                    });
                    console.log(`Successfully fetched ${firestoreTools.length} tools from Firestore.`);
                    return firestoreTools;
                } catch (error) {
                    console.error("Error fetching tools from Firestore:", error);
                    showToast("Could not load AI tools from the database.");
                    return []; // Restituisce un array vuoto in caso di errore
                }
            };
            // NUOVA FUNZIONE per caricare le classifiche da Firestore
            const fetchRankingsFromFirestore = async () => {
                try {
                    const rankingsCollectionRef = collection(db, "rankings");
                    const q = query(rankingsCollectionRef); // Removed orderBy("order")
                    const querySnapshot = await getDocs(q);
                    const firestoreRankings = [];
                    querySnapshot.forEach((doc) => {
                        firestoreRankings.push({ ...doc.data(), id: doc.id });
                    });
                    console.log(`Successfully fetched ${firestoreRankings.length} rankings from Firestore.`);
                    return firestoreRankings;
                } catch (error) {
                    console.error("Error fetching rankings from Firestore:", error);
                    showToast("Could not load AI rankings from the database.");
                    return [];
                }
            };
            // NUOVA FUNZIONE per caricare le impostazioni delle funzionalità
            const fetchFeatureSettings = async () => {
                try {
                    const settingsDocRef = doc(db, "settings", "featureToggles");
                    const docSnap = await getDoc(settingsDocRef);
                    if (docSnap.exists()) {
                        console.log("Successfully fetched feature settings.");
                        return docSnap.data();
                    } else {
                        console.warn("Feature settings document not found in Firestore. Using defaults.");
                        return { isChatEnabled: true, isReviewsEnabled: true, isRatingsEnabled: true };
                    }
                } catch (error) {
                    console.error("Error fetching feature settings:", error);
                    showToast("Could not load app settings.");
                    return { isChatEnabled: true, isReviewsEnabled: true, isRatingsEnabled: true };
                }
            };

            // NUOVA FUNZIONE per caricare i video da Firestore (ordinati per campo 'order')
            const fetchVideosFromFirestore = async () => {
                try {
                    const videosCollectionRef = collection(db, "videos");
                    const q = query(videosCollectionRef, orderBy("order", "asc"));
                    const querySnapshot = await getDocs(q);
                    const firestoreVideos = [];
                    querySnapshot.forEach((doc) => {
                        firestoreVideos.push({ ...doc.data(), id: doc.id });
                    });
                    console.log(`Successfully fetched ${firestoreVideos.length} videos from Firestore.`);
                    return firestoreVideos;
                } catch (error) {
                    console.error("Error fetching videos from Firestore:", error);
                    return [];
                }
            };

            // Funzione globale accessibile anche dallo script React
            window.getLocalizedToolsData = (lang) => {
                return aiToolsData.map(tool => ({ ...tool, description: tool.description[lang] || tool.description['en'] }));
            }
            window.aiToolsData = aiToolsData; // Keep static data accessible

            // MODIFICA: Le categorie ora hanno un ID e nomi traducibili
            const categories = [
                { id: 'Testo', name: { it: 'Testo', en: 'Text' }, color: '#2659A9' },
                { id: 'Immagini', name: { it: 'Immagini', en: 'Images' }, color: '#8D49F2' },
                { id: 'Video', name: { it: 'Video', en: 'Video' }, color: '#AF2896' },
                { id: 'Presentazioni', name: { it: 'Presentazioni', en: 'Presentations' }, color: '#E13300' },
                { id: 'Codice', name: { it: 'Codice', en: 'Code' }, color: '#BA5D07' },
                { id: 'Audio', name: { it: 'Audio', en: 'Audio' }, color: '#006450' },
                { id: 'Automation Tools', name: { it: 'Automazioni', en: 'Automation Tools' }, color: '#008080' },
                { id: 'Browser AI', name: { it: 'Browser AI', en: 'AI Browser' }, color: '#FF8C00' },
                { id: 'AI Playground', name: { it: 'AI Playground', en: 'AI Playground' }, color: '#FF69B4' },
                // Add a generic category for user tools if needed, or let user specify
                // For simplicity, let's allow user to pick from existing categories
            ];
            const countries = [...new Set(aiToolsData.map(t => t.country))]
                .filter(c => c !== 'Global' && c !== 'Italia') // <-- Rimuove anche "Italia"
                .map(c => {
                    // Se il paese è 'undefined', lo rinominiamo in "Nazione" e gli diamo una bandiera generica
                    if (c === undefined) {
                        return { name: 'Nazione', flag: '🏳️' };
                    }
                    // Altrimenti, procediamo come prima
                    return { name: c, flag: { 'USA': '🇺🇸', 'Cina': '🇨🇳', 'Europe': '🇪🇺' }[c] || '🏳️' };
                });

            // currentUser will now include Firestore data (favorites, userTools, userFeaturedTools, userFeaturedReplacements)
            // and the privileged status loaded from Firestore
            let currentUser = {};
            let currentView = 'home';
            let activeFilter = 'All'; // Filter for Favorites page
            let exploreFilter = { type: null, value: null }; // Filter for Explore page
            let rankingFilter = 'All'; // Filter for Top AI page
            let libraryTab = 'favorites'; // Variabile per la scheda attiva in Libreria
            let reactRoot = null;
            let conversations = {};
            let activeConversationId = null;
            let currentLanguage = localStorage.getItem('koda-lang') || 'it';
            let currentTheme = localStorage.getItem('koda-theme') || 'dark';
            let searchTimeout = null; // For debouncing user search

            // State for K button click counter (still local)
            let kButtonClickCount = 0;
            let lastKButtonClickTime = 0;
            let kButtonClickTimeout = null;
            const K_BUTTON_CLICK_THRESHOLD = 5;
            const K_BUTTON_CLICK_RESET_DELAY = 500; // ms

            const sunIcon = `<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79zM1 10.5h3v2H1zM11 .55h2V3.5h-2zm8.04 1.49l1.79-1.8-1.41-1.41-1.8 1.79zM20 10.5h3v2h-3zm-9.24 10.96l1.8 1.79 1.41-1.41-1.79-1.79zm-6.36-1.8l-1.79 1.8 1.41 1.41 1.8-1.79zM12 5.5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/></svg>`;
            const moonIcon = `<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M9.37 5.51A7.35 7.35 0 009.1 7.5c0 4.08 3.32 7.4 7.4 7.4.68 0 1.35-.09 1.99-.27C17.45 17.19 14.93 19 12 19c-3.86 0-7-3.14-7-7 0-2.93 1.81-5.45 4.37-6.49z"/></svg>`;
            // Pencil icon SVG for editing
            const pencilIcon = `<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M14.06 9.02l.92.92L5.92 18H5v-.92l9.06-9.06zm4.6-4.6l-1.39-1.39c-.2-.2-.51-.2-.71 0l-1.83 1.83 3.29 3.29 1.83-1.83c.2-.2.2-.51 0-.71zM3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z"/></svg>`;
            const smallPencilIcon = `<svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>`;
            const trashIcon = `<svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>`;


            const el = {
                mainContent: document.getElementById('main-content'),
                bottomNav: document.getElementById('bottom-nav'),
                modalContainer: document.getElementById('modal-container'),
                appContainer: document.getElementById('app-container'),
                authOverlay: document.getElementById('auth-overlay'),
                sideMenuOverlay: document.getElementById('side-menu-overlay'),
                sideMenu: document.getElementById('side-menu'),
                conversationListContainer: document.getElementById('conversation-list-container'),
            };

            const getStorageKey = () => `conversations_${currentUser.uid || 'guest'}`;

            const loadConversations = () => {
                const saved = localStorage.getItem(getStorageKey());
                conversations = saved ? JSON.parse(saved) : {};
                const savedActiveId = localStorage.getItem(`activeConversationId_${currentUser.uid || 'guest'}`);
                activeConversationId = savedActiveId && conversations[savedActiveId] ? savedActiveId : null;

                if (Object.keys(conversations).length === 0 || !activeConversationId) {
                    startNewChat(false);
                }
            };

            const saveConversations = (newConversations) => {
                conversations = newConversations; // Corrected variable name
                localStorage.setItem(getStorageKey(), JSON.stringify(conversations));
            };

            const saveActiveConversationId = () => {
                localStorage.setItem(`activeConversationId_${currentUser.uid || 'guest'}`, activeConversationId);
            }

            const startNewChat = (remountApp = true) => {
                const newId = `chat-${Date.now()}`;
                const t = translations[currentLanguage];
                conversations[newId] = { id: newId, title: t.newChatTitle, messages: [], timestamp: Date.now() };
                activeConversationId = newId;
                saveConversations(conversations);
                saveActiveConversationId();
                if (remountApp) {
                    renderView();
                }
                toggleSideMenu(false);
            };

            const showToast = (message) => {
                // This function is intentionally left empty to disable toast notifications as requested.
                // For debugging, you can log the message to the console instead:
                // console.log('Toast Message:', message);
            };

            // Espone la funzione showToast globalmente
            window.showToast = showToast;

            // NUOVA FUNZIONE: Ottiene il nome tradotto di una categoria
            const getTranslatedCategoryName = (categoryId) => {
                const category = categories.find(c => c.id === categoryId);
                return category ? category.name[currentLanguage] : categoryId;
            };

            // NEW FUNCTION: Get all tools (static + user's)
            window.getAllToolsForCurrentUser = () => { // Make it globally accessible for React
                const staticTools = window.getLocalizedToolsData(currentLanguage);
                const userTools = currentUser.userTools || []; // userTools now comes from currentUser (synced with Firestore)
                // Ensure user tools have localized descriptions if possible, or fallback
                const localizedUserTools = userTools.map(tool => ({
                    ...tool,
                    description: typeof tool.description === 'object' ? (tool.description[currentLanguage] || tool.description['en'] || '') : tool.description
                }));
                // Filtro per eliminare duplicati per id
                const allTools = [...staticTools, ...localizedUserTools];
                return allTools.filter((tool, idx, arr) => arr.findIndex(t => t.id === tool.id) === idx);
            };


            // Modified createGridCard to optionally show an edit icon and specify its action
            const createGridCard = (tool, context, options = {}) => {
                let editIconHTML = '';
                // Check if user is logged in
                if (currentUser.uid) {
                    const isUserTool = tool.id.startsWith('user-');
                    let action = '';
                    let title = '';
                    let dataId = tool.id; // Default data-id is the tool's own id

                    if (context === 'user-featured-section' && isUserTool) {
                        // Pencil on user tool in Featured by You section -> Toggle Featured status
                        action = 'toggle-user-featured';
                        title = translations[currentLanguage].unmarkAsFeatured; // Assuming it's already featured here
                    }

                    if (action && dataId) {
                        editIconHTML = `<div class="edit-icon" data-action="${action}" data-id="${dataId}" title="${title}"> ${pencilIcon} </div>`;
                    }
                }

                const ratingHTML = featureSettings.isRatingsEnabled ? `<div class="rating-container" id="rating-${tool.id}"></div>` : '';
                return `<div class="tool-card-grid" data-id="${tool.id}"><div class="logo-container"><img src="${tool.logoUrl}" class="tool-logo" alt="${tool.name}" loading="lazy">${editIconHTML}</div><div class="tool-name">${tool.name}</div>${ratingHTML}</div>`;
            };

            const createListCard = (tool, context) => {
                const isUserTool = tool.id.startsWith('user-');
                const isFavorited = currentUser.uid && currentUser.favorites.includes(tool.id);
                const favoriteIconHTML = currentUser.uid ? `<div class="favorite-icon" data-action="toggle-favorite" data-id="${tool.id}">${isFavorited ? '♥' : '♡'}</div>` : '';

                let editIconHTML = '';
                // NUOVO: Mostra l'icona di modifica globale se l'utente è admin
                if (currentUser.role === 'admin') {
                    editIconHTML = `<div class="edit-icon" data-action="open-edit-global-tool-modal" data-id="${tool.id}" title="Modifica AI (Admin)"> ${pencilIcon} </div>`;
                }
                // Manteniamo la logica per gli utenti normali che modificano le proprie app custom
                else if (isUserTool && currentUser.uid && tool.id.includes(currentUser.uid)) {
                    editIconHTML = `<div class="edit-icon" data-action="open-edit-app-modal" data-id="${tool.id}" title="${translations[currentLanguage].editUserTool}"> ${pencilIcon} </div>`;
                }

                const ratingHTML = featureSettings.isRatingsEnabled ? `<div class="rating-container" id="rating-${tool.id}"></div>` : '';
                return `<div class="tool-card-list" data-id="${tool.id}"><div class="logo-container"><img src="${tool.logoUrl}" class="tool-logo" alt="${tool.name}" loading="lazy">${editIconHTML}</div><div class="info"><div class="tool-name">${tool.name}</div><div class="tool-subtext">${getTranslatedCategoryName(tool.category)}</div>${ratingHTML}</div>${favoriteIconHTML}</div>`;
            };

            const createCategoryCard = (category) => {
                const currentTools = window.getLocalizedToolsData(currentLanguage);
                const toolForLogo = currentTools.find(t => t.category === category.id) || { logoUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcBAMAAACAI8KnAAAAFVBMVEX///+ZmZkZGRlZWVmRkZEAAABGRkb6Me63AAAAHElEQVR4AWMYUCBkwKyIxHVNYAsZVFyEIwcSAADWIQrDIppSoAAAAABJRU5ErkJggg==' }; // Fallback per logo
                // Usa category.id per il filtro e category.name per la visualizzazione
                return `<div class="category-card" style="background-color: ${category.color};" data-action="set-explore-filter" data-filter-type="category" data-filter-value="${category.id}"><h3>${category.name[currentLanguage]}</h3><div class="logo-container"><img src="${toolForLogo.logoUrl}" class="tool-logo" loading="lazy"></div></div>`;
            };
            const createCountryCard = (country) => `<div class="category-card" style="background-color: #333;" data-action="set-explore-filter" data-filter-type="country" data-filter-value="${country.name}"><h3 style="font-size: 24px;">${country.flag} ${country.name}</h3></div>`;

            window.openDetailModal = async (toolId) => {
                // Mostra un caricamento immediato per una migliore UX
                el.modalContainer.innerHTML = `
                <div id="detail-modal" class="modal-overlay visible">
                    <div class="modal-content" style="display: flex; align-items: center; justify-content: center; min-height: 200px;">
                        <div class="chat-bubble loading"><span></span><span></span><span></span></div>
                    </div>
                </div>
            `;

                let tool = null;

                // 1. Cerca lo strumento nella lista locale dell'utente corrente
                const localTools = getAllToolsForCurrentUser();
                tool = localTools.find(t => t.id === toolId);

                // 2. Se non è stato trovato ed è un'app utente, recuperala da Firestore
                if (!tool && toolId && toolId.startsWith('user-')) {
                    try {
                        // L'ID dell'utente che ha creato l'app è incorporato nell'ID dell'app stessa
                        const creatorId = toolId.split('-')[1];
                        if (creatorId) {
                            const userDocRef = doc(db, "users", creatorId);
                            const userDocSnap = await getDoc(userDocRef);
                            if (userDocSnap.exists()) {
                                const creatorTools = userDocSnap.data().userTools || [];
                                const remoteTool = creatorTools.find(t => t.id === toolId);
                                if (remoteTool) {
                                    // Traduci la descrizione prima di assegnarla
                                    const description = typeof remoteTool.description === 'object'
                                        ? (remoteTool.description[currentLanguage] || remoteTool.description['en'])
                                        : remoteTool.description;
                                    tool = { ...remoteTool, description };
                                }
                            }
                        }
                    } catch (error) {
                        console.error("Errore nel recupero dello strumento remoto:", error);
                    }
                }

                // 3. Se lo strumento non è ancora stato trovato, esci
                if (!tool) {
                    showToast("Dettagli dello strumento non trovati.");
                    closeModal();
                    return;
                }

                // 4. Ora che abbiamo lo strumento, costruisci e renderizza il modale completo
                const t = translations[currentLanguage];
                const isFavorited = currentUser.uid && currentUser.favorites.includes(toolId);
                const isUserTool = tool.id.startsWith('user-');
                const isMyUserTool = isUserTool && tool.id.includes(currentUser.uid); // Controlla se è la MIA app custom
                const isUserFeatured = isMyUserTool && currentUser.userFeaturedTools?.includes(toolId);

                let recommendationHTML = '';
                let recommendedTool = null;
                const allToolsForRec = getAllToolsForCurrentUser(); // Usa la lista locale per le raccomandazioni
                if (tool.recommendationId) {
                    recommendedTool = allToolsForRec.find(t => t.id === tool.recommendationId);
                } else {
                    const sameCategory = allToolsForRec.filter(t => t.category === tool.category && t.id !== tool.id);
                    if (sameCategory.length > 0) {
                        recommendedTool = sameCategory[Math.floor(Math.random() * sameCategory.length)];
                    }
                }
                if (recommendedTool) {
                    recommendationHTML = `<div class="recommendation-box" data-action="open-detail-modal" data-id="${recommendedTool.id}"><img src="${recommendedTool.logoUrl}" alt="${recommendedTool.name}" class="recommendation-logo" loading="lazy"><div class="recommendation-text">${t.alternativeSuggestion}<strong>${recommendedTool.name}</strong></div></div>`;
                }

                let userToolActionsHTML = '';
                // I pulsanti di modifica/evidenza appaiono solo se sono loggato e sto guardando una delle MIE app custom
                if (isMyUserTool && currentUser.isPrivileged) {
                    userToolActionsHTML = `<button class="button" data-action="toggle-user-featured" data-id="${tool.id}">${isUserFeatured ? t.unmarkAsFeatured : t.markAsFeatured}</button>`;
                }

                const modalHTML = `
                <div id="detail-modal" class="modal-overlay visible">
                    <div class="modal-content">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <div id="detail-content">
                            <h2>${tool.name}</h2>
                            <p>${tool.description}</p>
                            <div class="detail-tags">
                                <span class="tag">🌍 ${tool.country || 'N/A'}</span>
                                <span class="tag">${getTranslatedCategoryName(tool.category || 'N/A')}</span>
                            </div>
                            <div class="detail-actions">
                                ${userToolActionsHTML}
                                ${currentUser.uid ? `<button class="button" data-action="toggle-favorite" data-id="${tool.id}">${isFavorited ? t.detailModalRemoveFavorite : t.detailModalAddFavorite}</button>` : ''}
                                <a href="${tool.website}" target="_blank" class="button" style="text-decoration: none; display: flex; justify-content: center; align-items: center;">${t.visitWebsite}</a>
                            </div>
                            ${featureSettings.isReviewsEnabled ? `
                            <div class="reviews-section">
                                <div class="reviews-header">
                                    <h3 class="reviews-title">${t.reviews || 'Recensioni'}</h3>
                                    ${currentUser.uid ? `<button class="add-review-btn" data-action="add-review" data-tool-id="${tool.id}">${t.addReview || 'Aggiungi Recensione'}</button>` : ''}
                                </div>
                                <div id="reviews-container-${tool.id}">
                                    <div class="loading-reviews">${t.loadingReviews || 'Caricamento recensioni...'}</div>
                                </div>
                                <a class="view-all-reviews-link" data-action="view-all-user-reviews" data-tool-id="${tool.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                                    </svg>
                                    <span data-translate="viewAllUserReviews">Visualizza tutte le recensioni utente</span>
                                </a>
                            </div>
                            ` : ''}
                            ${recommendationHTML}
                        </div>
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;

                // NUOVO: Carica le recensioni dopo aver renderizzato il modal
                setTimeout(() => loadReviews(toolId), 100);
            };

            const closeModal = () => {
                el.modalContainer.innerHTML = '';
                closeUserProfileDropdown();
            };

            // NUOVO: Funzioni per il sistema di recensioni
            // IMPORTANTE: Assicurati di aggiungere queste regole di sicurezza in Firestore:
            /*
            rules_version = '2';
            service cloud.firestore {
              match /databases/{database}/documents {
                // Regole per le recensioni
                match /tools/{toolId}/reviews/{reviewId} {
                  allow read: if true; // Tutti possono leggere le recensioni
                  allow create: if request.auth != null && 
                               request.auth.uid == resource.data.userId &&
                               request.data.keys().hasAll(['userId', 'rating', 'text', 'createdAt']) &&
                               request.data.rating is number &&
                               request.data.rating >= 1 && request.data.rating <= 5;
                  allow update, delete: if false; // Le recensioni non possono essere modificate o eliminate
                }
              }
            }
            */
            let currentReviewToolId = null;
            let currentRating = 0;
            let toolRatingsCache = {}; // Cache per le valutazioni degli strumenti

            const getToolRating = async (toolId) => {
                // Controlla se abbiamo già la valutazione in cache
                if (toolRatingsCache[toolId]) {
                    return toolRatingsCache[toolId];
                }

                try {
                    const reviewsRef = collection(db, 'tools', toolId, 'reviews');
                    const reviewsSnapshot = await getDocs(reviewsRef);

                    if (reviewsSnapshot.empty) {
                        toolRatingsCache[toolId] = { average: 0, count: 0 };
                        return toolRatingsCache[toolId];
                    }

                    let totalRating = 0;
                    let reviewCount = 0;

                    reviewsSnapshot.forEach(doc => {
                        const review = doc.data();
                        totalRating += review.rating;
                        reviewCount++;
                    });

                    const average = totalRating / reviewCount;
                    toolRatingsCache[toolId] = { average, count: reviewCount };
                    return toolRatingsCache[toolId];

                } catch (error) {
                    console.error('Errore nel caricamento della valutazione:', error);
                    toolRatingsCache[toolId] = { average: 0, count: 0 };
                    return toolRatingsCache[toolId];
                }
            };

            const loadToolRatings = async () => {
                // Carica le valutazioni per tutti gli strumenti visibili
                const ratingContainers = document.querySelectorAll('.rating-container');
                const t = translations[currentLanguage];

                for (const container of ratingContainers) {
                    const toolId = container.id.replace('rating-', '');
                    const rating = await getToolRating(toolId);

                    if (rating.count > 0) {
                        const starsHTML = generateStarsHTML(Math.round(rating.average));
                        container.innerHTML = `
                        <div class="stars-display">${starsHTML}</div>
                        <span class="rating-text">${rating.average.toFixed(1)} (${rating.count})</span>
                    `;
                    } else {
                        container.innerHTML = `<span class="rating-text">${t.noReviews}</span>`;
                    }
                }
            };

            const loadReviews = async (toolId) => {
                const reviewsContainer = document.getElementById(`reviews-container-${toolId}`);
                if (!reviewsContainer) return;

                try {
                    // Carica le recensioni da Firestore
                    const reviewsRef = collection(db, 'tools', toolId, 'reviews');
                    const reviewsQuery = query(reviewsRef, orderBy('createdAt', 'desc'));
                    const reviewsSnapshot = await getDocs(reviewsQuery);

                    if (reviewsSnapshot.empty) {
                        const t = translations[currentLanguage];
                        reviewsContainer.innerHTML = `<div class="no-reviews">${t.noReviews}</div>`;
                        return;
                    }

                    let reviewsHTML = '';
                    let totalRating = 0;
                    let reviewCount = 0;

                    const t = translations[currentLanguage];

                    for (const reviewDoc of reviewsSnapshot.docs) {
                        const review = reviewDoc.data();
                        totalRating += review.rating;
                        reviewCount++;

                        // Carica i dati dell'utente che ha scritto la recensione
                        let userName = t.anonymous;
                        let userInitial = 'U';

                        if (review.userId) {
                            try {
                                const userDoc = await getDoc(doc(db, 'users', review.userId));
                                if (userDoc.exists()) {
                                    const userData = userDoc.data();
                                    userName = userData.nickname || userData.fullName || (userData.email ? userData.email.split('@')[0] : 'Utente');
                                    userInitial = userName.charAt(0).toUpperCase();
                                }
                            } catch (error) {
                                console.error('Errore nel caricamento dati utente:', error);
                            }
                        }

                        const reviewDate = review.createdAt ? new Date(review.createdAt.seconds * 1000).toLocaleDateString(currentLanguage === 'it' ? 'it-IT' : 'en-US') : t.unknownDate;
                        const starsHTML = generateStarsHTML(review.rating);

                        reviewsHTML += `
                        <div class="review-item">
                            <div class="review-header">
                                <div class="review-user">
                                    <div class="review-avatar">${userInitial}</div>
                                    <div class="review-user-info">
                                        <div class="review-username">${userName}</div>
                                        <div class="review-date">${reviewDate}</div>
                                    </div>
                                </div>
                                <div class="review-rating">${starsHTML}</div>
                            </div>
                            <div class="review-text">${review.text || ''}</div>
                        </div>
                    `;
                    }

                    // Aggiorna la valutazione media nel titolo
                    const averageRating = totalRating / reviewCount;
                    const reviewsTitle = document.querySelector('.reviews-title');
                    if (reviewsTitle) {
                        reviewsTitle.innerHTML = `${t.reviews} (${reviewCount}) ${generateStarsHTML(Math.round(averageRating))} ${averageRating.toFixed(1)}`;
                    }

                    reviewsContainer.innerHTML = reviewsHTML;

                } catch (error) {
                    console.error('Errore nel caricamento delle recensioni:', error);
                    const t = translations[currentLanguage];
                    reviewsContainer.innerHTML = '<div class="no-reviews">Errore nel caricamento delle recensioni.</div>';
                }
            };

            const generateStarsHTML = (rating) => {
                let starsHTML = '';
                for (let i = 1; i <= 5; i++) {
                    starsHTML += `<span class="star ${i <= rating ? '' : 'empty'}">★</span>`;
                }
                return starsHTML;
            };

            const openReviewModal = (toolId) => {
                if (!currentUser || !currentUser.uid) {
                    showAuthOverlay();
                    return;
                }

                currentReviewToolId = toolId;
                currentRating = 0;
                const t = translations[currentLanguage];

                // Aggiorna il contenuto del modal con le traduzioni correnti
                const reviewModal = document.getElementById('review-modal');
                reviewModal.querySelector('.review-modal-title').textContent = t.addReview;
                reviewModal.querySelector('.rating-input-label').textContent = t.selectRating;
                reviewModal.querySelector('.review-text-label').textContent = t.reviews;
                reviewModal.querySelector('.review-text-input').placeholder = t.writeReview;
                reviewModal.querySelector('.review-cancel-btn').textContent = t.cancel;
                reviewModal.querySelector('.review-submit-btn').textContent = t.publishReview;

                const starsInput = reviewModal.querySelectorAll('.star-input');
                const reviewTextInput = reviewModal.querySelector('.review-text-input');

                // Reset form
                starsInput.forEach(star => star.classList.remove('active'));
                reviewTextInput.value = '';

                reviewModal.classList.add('visible');
            };

            const closeReviewModal = () => {
                const reviewModal = document.getElementById('review-modal');
                reviewModal.classList.remove('visible');
                currentReviewToolId = null;
                currentRating = 0;
            };

            const setRating = (rating) => {
                currentRating = rating;
                const starsInput = document.querySelectorAll('.star-input');
                starsInput.forEach((star, index) => {
                    if (index < rating) {
                        star.classList.add('active');
                    } else {
                        star.classList.remove('active');
                    }
                });
            };

            const submitReview = async () => {
                if (!currentUser || !currentUser.uid || !currentReviewToolId) return;
                const t = translations[currentLanguage];

                if (currentRating === 0) {
                    alert(t.selectRating);
                    return;
                }

                const reviewText = document.querySelector('.review-text-input').value.trim();
                const submitBtn = document.querySelector('.review-submit-btn');

                submitBtn.disabled = true;
                submitBtn.textContent = 'Pubblicazione...';

                try {
                    // Controlla se l'utente ha già recensito questo strumento
                    const existingReviewQuery = query(
                        collection(db, 'tools', currentReviewToolId, 'reviews'),
                        where('userId', '==', currentUser.uid)
                    );
                    const existingReviewSnapshot = await getDocs(existingReviewQuery);

                    if (!existingReviewSnapshot.empty) {
                        alert(t.alreadyReviewed);
                        submitBtn.disabled = false;
                        submitBtn.textContent = t.publishReview;
                        return;
                    }

                    // Aggiungi la nuova recensione
                    const reviewData = {
                        userId: currentUser.uid,
                        rating: currentRating,
                        text: reviewText,
                        createdAt: serverTimestamp()
                    };

                    await addDoc(collection(db, 'tools', currentReviewToolId, 'reviews'), reviewData);

                    // Invalida la cache per questo strumento
                    delete toolRatingsCache[currentReviewToolId];

                    closeReviewModal();
                    loadReviews(currentReviewToolId); // Ricarica le recensioni
                    loadToolRatings(); // Ricarica le valutazioni nelle card
                    showToast(t.reviewSubmitted);

                } catch (error) {
                    console.error('Errore nella pubblicazione della recensione:', error);
                    alert(t.reviewError);
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.textContent = t.publishReview;
                }
            };

            // Variable to store pending favorite action
            let pendingFavoriteAction = null;

            const toggleFavorite = async (toolId) => {
                if (!currentUser || !currentUser.uid) {
                    // Store the pending action and trigger auth flow
                    pendingFavoriteAction = toolId;
                    triggerAuthFlow();
                    return;
                }
                // Removed the check !toolId.startsWith('user-')
                // Now all tools can be favorited

                const userDocRef = doc(db, "users", currentUser.uid);
                const isFavorited = currentUser.favorites.includes(toolId);
                try {
                    if (isFavorited) {
                        await updateDoc(userDocRef, { favorites: arrayRemove(toolId) });
                        currentUser.favorites = currentUser.favorites.filter(id => id !== toolId);
                    } else {
                        await updateDoc(userDocRef, { favorites: arrayUnion(toolId) });
                        currentUser.favorites.push(toolId);
                    }
                } catch (error) { console.error("Error updating favorites:", error); showToast("Could not update favorites. Please try again."); return; }
                // Re-render the current view to update favorite icons
                renderView();
                // If detail modal is open, update it
                if (document.getElementById('detail-modal')) { window.openDetailModal(toolId); }
            };

            // NEW FUNCTION: Toggle user-added tool featured status (Firestore)
            const toggleUserFeatured = async (toolId) => {
                // Allow any logged-in user to perform this action
                if (!currentUser || !currentUser.uid) return;
                // Ensure it is a user-added tool
                if (!toolId.startsWith('user-')) return;

                const userDocRef = doc(db, "users", currentUser.uid);
                const isUserFeatured = currentUser.userFeaturedTools?.includes(toolId);
                const newFeaturedList = isUserFeatured
                    ? currentUser.userFeaturedTools.filter(id => id !== toolId)
                    : [...(currentUser.userFeaturedTools || []), toolId];

                try {
                    await updateDoc(userDocRef, { userFeaturedTools: newFeaturedList });
                    currentUser.userFeaturedTools = newFeaturedList; // Update local state after successful Firestore update
                } catch (error) {
                    console.error("Error updating user featured tools:", error);
                    showToast("Could not update featured status. Please try again.");
                    return;
                }

                // Re-render the current view (Library) and update the detail modal
                renderView();
                if (document.getElementById('detail-modal')) { window.openDetailModal(toolId); }
            };

            // NEW FUNCTION: Replace static featured tool with user tool (Firestore)
            const replaceFeaturedStatic = async (staticToolId, userToolId) => {
                // Allow any logged-in user to perform this action
                if (!currentUser || !currentUser.uid) return;
                if (!staticToolId || !userToolId) return;

                const userDocRef = doc(db, "users", currentUser.uid);
                const newReplacements = { ...(currentUser.userFeaturedReplacements || {}), [staticToolId]: userToolId };

                try {
                    await updateDoc(userDocRef, { userFeaturedReplacements: newReplacements });
                    currentUser.userFeaturedReplacements = newReplacements; // Update local state
                    showToast(translations[currentLanguage].addAppSuccess); // Reuse success toast
                } catch (error) {
                    console.error("Error replacing featured tool:", error);
                    showToast(`Error: ${error.message}`); // Generic error
                    return;
                }

                closeModal();
                renderView(); // Re-render Top AI view
            };

            // NEW FUNCTION: Remove featured replacement (Firestore)
            const removeFeaturedReplacement = async (staticToolId) => {
                // Check privileged status loaded from Firestore
                if (!currentUser || !currentUser.uid || !currentUser.isPrivileged) return;
                if (!staticToolId) return;

                const userDocRef = doc(db, "users", currentUser.uid);
                const newReplacements = { ...(currentUser.userFeaturedReplacements || {}) };
                delete newReplacements[staticToolId];

                try {
                    await updateDoc(userDocRef, { userFeaturedReplacements: newReplacements });
                    currentUser.userFeaturedReplacements = newReplacements; // Update local state
                    showToast(translations[currentLanguage].removeFeaturedReplacement + " Success!"); // Toast confirmation
                } catch (error) {
                    console.error("Error removing featured replacement:", error);
                    showToast(`Error: ${error.message}`); // Generic error
                    return;
                }

                renderView(); // Re-render Top AI view
            };

            // NEW FUNCTION: Remove user-added tool entirely (Firestore)
            const removeUserTool = async (toolId) => {
                // Permetti solo agli utenti loggati di rimuovere le proprie app
                if (!currentUser || !currentUser.uid || !toolId.startsWith('user-')) {
                    showToast("Azione non permessa.");
                    return;
                }

                const userDocRef = doc(db, "users", currentUser.uid);
                const t = translations[currentLanguage];

                try {
                    // 1. Leggi lo stato attuale del documento utente da Firestore
                    const userDocSnap = await getDoc(userDocRef);
                    if (!userDocSnap.exists()) {
                        showToast("Dati utente non trovati.");
                        return;
                    }
                    const userData = userDocSnap.data();

                    // 2. Filtra l'array 'userTools' per rimuovere l'app specificata
                    const updatedUserTools = (userData.userTools || []).filter(tool => tool.id !== toolId);

                    // 3. Rimuovi l'app anche da altri array correlati (preferiti, in evidenza, etc.)
                    const updatedUserFeaturedTools = (userData.userFeaturedTools || []).filter(id => id !== toolId);
                    const updatedFavorites = (userData.favorites || []).filter(id => id !== toolId);
                    const updatedUserFeaturedReplacements = { ...(userData.userFeaturedReplacements || {}) };
                    for (const staticId in updatedUserFeaturedReplacements) {
                        if (updatedUserFeaturedReplacements[staticId] === toolId) {
                            delete updatedUserFeaturedReplacements[staticId];
                        }
                    }

                    // 4. Prepara l'oggetto con tutti i dati aggiornati da scrivere su Firestore
                    const updateData = {
                        userTools: updatedUserTools,
                        userFeaturedTools: updatedUserFeaturedTools,
                        userFeaturedReplacements: updatedUserFeaturedReplacements,
                        favorites: updatedFavorites
                    };

                    // 5. Scrivi i dati aggiornati su Firestore in un'unica operazione
                    await updateDoc(userDocRef, updateData);

                    // 6. Aggiorna lo stato locale per riflettere la rimozione nella UI
                    currentUser.userTools = updatedUserTools;
                    currentUser.userFeaturedTools = updatedUserFeaturedTools;
                    currentUser.userFeaturedReplacements = updatedUserFeaturedReplacements;
                    currentUser.favorites = updatedFavorites;

                    showToast(t.removeUserTool + " - Successo!");
                    renderView();
                    closeModal();
                } catch (error) {
                    console.error("Errore nella rimozione dell'app utente:", error);
                    showToast(`Errore: ${error.message}`);
                }
            };



            const unmountReactApp = () => {
                if (reactRoot) {
                    reactRoot.unmount();
                    reactRoot = null;
                }
            };

            const renderSideMenu = () => {
                const sortedConversations = Object.values(conversations).sort((a, b) => b.timestamp - a.timestamp);
                el.conversationListContainer.innerHTML = sortedConversations.map(conv => `
                <button class="conversation-item" data-action="select-conversation" data-id="${conv.id}">
                    ${conv.title}
                </button>
            `).join('');
                el.conversationListContainer.querySelector(`[data-id="${activeConversationId}"]`)?.classList.add('active');
                applyTranslations(currentLanguage); // Apply translations to menu items
            };

            const toggleSideMenu = (show) => {
                if (show) {
                    renderSideMenu(); // Render menu content before showing
                    el.sideMenuOverlay.classList.add('visible');
                    el.sideMenu.classList.remove('hidden'); /* Ensure it's not hidden by mistake */
                    el.sideMenu.classList.add('visible');
                } else {
                    el.sideMenuOverlay.classList.remove('visible');
                    el.sideMenu.classList.remove('visible');
                    // Add a small delay before hiding overlay completely to allow transition
                    setTimeout(() => {
                        el.sideMenuOverlay.classList.add('hidden');
                    }, 300); // Match CSS transition duration
                }
            };

            // User Profile Dropdown Functions
            const toggleUserProfileDropdown = () => {
                const dropdown = document.getElementById('user-profile-dropdown');
                if (dropdown) {
                    const isVisible = dropdown.classList.contains('visible');
                    if (isVisible) {
                        closeUserProfileDropdown();
                    } else {
                        openUserProfileDropdown();
                    }
                }
            };

            const openUserProfileDropdown = () => {
                const dropdown = document.getElementById('user-profile-dropdown');
                if (dropdown) {
                    // Close any other open dropdowns first
                    closeUserProfileDropdown();

                    // Update user info in dropdown
                    const nameElement = dropdown.querySelector('.user-profile-name');
                    const emailElement = dropdown.querySelector('.user-profile-email');
                    const avatarElement = dropdown.querySelector('.user-profile-avatar');

                    if (nameElement) nameElement.textContent = currentUser.nickname || currentUser.name;
                    if (emailElement) emailElement.textContent = currentUser.name;
                    if (avatarElement) avatarElement.textContent = currentUser.nickname ? currentUser.nickname.charAt(0).toUpperCase() : currentUser.name.charAt(0).toUpperCase();

                    // Apply translations
                    applyTranslations(currentLanguage);

                    // Show dropdown
                    dropdown.classList.add('visible');

                    // Add click outside listener
                    setTimeout(() => {
                        document.addEventListener('click', closeUserProfileDropdownOnClickOutside);
                    }, 100);
                }
            };

            const closeUserProfileDropdown = () => {
                const dropdown = document.getElementById('user-profile-dropdown');
                if (dropdown) {
                    dropdown.classList.remove('visible');
                    document.removeEventListener('click', closeUserProfileDropdownOnClickOutside);
                }
            };

            const closeUserProfileDropdownOnClickOutside = (event) => {
                const dropdown = document.getElementById('user-profile-dropdown');
                const container = document.querySelector('.user-profile-container');

                if (dropdown && container && !container.contains(event.target)) {
                    closeUserProfileDropdown();
                }
            };

            const getGlobalControlsHTML = (options = {}) => {
                const { includeLangToggle = true } = options;

                const themeIcon = currentTheme === 'dark' ? sunIcon : moonIcon;
                const isGuest = !currentUser.uid;
                const userInitial = isGuest ? '?' : (currentUser.nickname ? currentUser.nickname.charAt(0).toUpperCase() : 'U');

                // The avatar is now always rendered in the top-bar, but its click action depends on login status
                const avatarHTML = `
            <div class="user-profile-container">
                <div class="user-avatar" data-action="profile-avatar-click">${userInitial}</div>
                <div class="user-profile-dropdown" id="user-profile-dropdown">
                    <div class="user-profile-header">
                        <div class="user-profile-avatar">${userInitial}</div>
                        <div class="user-profile-name">${currentUser.nickname || currentUser.name}</div>
                        <div class="user-profile-email">${currentUser.name}</div>
                    </div>
                    <div class="user-profile-menu">
                        <div class="user-profile-item" data-action="open-settings">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                            </svg>
                            <span data-translate="settingsTitle">Impostazioni</span>
                        </div>
                        <div class="user-profile-item" data-action="change-nickname">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
                            </svg>
                            <span data-translate="changeNicknameTitle">Cambia nickname</span>
                        </div>
                        <div class="user-profile-item" data-action="change-password">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/>
                            </svg>
                            <span data-translate="changePasswordTitle">Cambia password</span>
                        </div>
                        ${featureSettings.isReviewsEnabled ? `
                        <div class="user-profile-item" data-action="view-sent-reviews">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/>
                            </svg>
                            <span data-translate="sentReviews">Recensioni inviate</span>
                        </div>
                        ` : ''}
                        ${currentUser.role === 'admin' ? `
                        <div class="user-profile-item" data-action="open-manage-alternatives-modal">
                            <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M16.01 11H4v2h12.01v3L20 12l-3.99-4v3z"/></svg>
                            <span data-translate="manageAlternatives">Gestisci Alternative</span>
                        </div>
                        <div class="user-profile-item" data-action="open-feature-toggles-modal">
                             <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.08-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19-.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
                            <span data-translate="featureToggles">Gestione Funzionalità</span>
                        </div>
                        ` : ''}
                        <div class="user-profile-divider"></div>
                        <div class="user-profile-item user-profile-logout" data-action="logout">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"/>
                            </svg>
                            <span data-translate="logout">Logout</span>
                        </div>
                    </div>
                </div>
            </div>
        `;

                let otherControlsHTML = '';

                // Aggiunge il pulsante "Aggiungi AI" per gli amministratori
                if (currentUser.role === 'admin') {
                    otherControlsHTML += `
        <button id="admin-add-tool-btn" class="global-btn" data-action="open-add-global-tool-modal" title="${translations[currentLanguage].addAIToDatabase}">
            <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor">
                <path d="M0 0h24v24H0V0z" fill="none"/>
                <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
            </svg>
        </button>
    `;
                }
                otherControlsHTML += `
        <button id="admin-manage-rankings-btn" class="global-btn" data-action="open-manage-rankings-modal" title="Manage TOP AI Rankings">
            <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor">
                <path d="M0 0h24v24H0z" fill="none"/>
                <path d="M16 11V3H8v6H2v12h20V11h-6zm-6-6h4v14h-4V5zm-6 6h4v8H4v-8zm16 8h-4v-8h4v8z"/>
            </svg>
        </button>
    `;

                // NUOVO: Pulsante Catalogo Video
                otherControlsHTML += `
    <button id="video-catalog-btn" class="global-btn" data-action="open-video-catalog" title="${translations[currentLanguage].videoCatalogTitle}" style="color: var(--spotify-accent);">
        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M10 16.5l6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
    </button>
`;

                otherControlsHTML += `
<button id="theme-toggle-btn" class="global-btn" data-action="toggle-theme">${themeIcon}</button>
`;

                if (includeLangToggle) {
                    otherControlsHTML += `
    <button id="lang-toggle-btn" class="global-btn" data-action="toggle-lang">${currentLanguage.toUpperCase()}</button>
`;
                }

                // Return as an object to pass to React
                return { avatar: avatarHTML, otherControls: otherControlsHTML };
            };

            const renderView = () => {
                const initialLoader = document.getElementById('initial-loader');
                if (initialLoader) {
                    initialLoader.remove();
                }

                // GESTIONE VISIBILITÀ BARRA DI NAVIGAZIONE E PADDING
                // La visibilità della nav bar nella sezione chat è ora gestita dal componente React UserChatApp.
                el.bottomNav.style.display = 'flex';
                el.mainContent.style.paddingBottom = `var(--bottom-nav-height)`;

                // Close any open dropdowns when navigating
                closeUserProfileDropdown();
                unmountReactApp();
                el.mainContent.innerHTML = '';

                const t = translations[currentLanguage];
                const staticTools = window.getLocalizedToolsData(currentLanguage);
                const allTools = getAllToolsForCurrentUser(); // Use combined list for search/explore
                const isGuest = !currentUser.uid;
                // Check privileged status loaded from Firestore
                const isPrivileged = currentUser.uid && currentUser.isPrivileged;
                const pageTitles = { home: t.pageTitleHome, 'top-ai': t.pageTitleTopAI, search: t.pageTitleSearch, 'search-users': t.pageTitleSearchUsers, 'user-chats': t.pageTitleUserChats, favorites: t.pageTitleLibrary };

                // Top bar is only rendered for non-home views
                if (currentView !== 'home') {
                    const globalControls = getGlobalControlsHTML();
                    const pageTitle = pageTitles[currentView] || currentView;
                    // MODIFICATO: Usa la stessa struttura e classi della barra della chat per coerenza
                    const topBarHTML = `<div class="user-chat-header">
                    <div id="profile-avatar-menu" style="margin-left: 8px;">${globalControls.avatar}</div>
                    <div class="user-chat-info" style="flex-grow: 1;"><h3>${pageTitle}</h3></div>
                    <div id="global-controls">${globalControls.otherControls}</div>
                </div>`;
                    el.mainContent.insertAdjacentHTML('beforeend', topBarHTML);
                }

                const contentArea = document.createElement('div');
                contentArea.id = 'content-area';

                if (currentView === 'home') {
                    // Add the same header structure as other pages for consistency
                    const globalControls = getGlobalControlsHTML();
                    const pageTitle = pageTitles[currentView] || currentView;
                    const topBarHTML = `<div class="user-chat-header">
                    <button id="menu-toggle-btn" class="chat-header-btn" title="Chat History" data-action="toggle-menu">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
                    </button>
                    <div id="profile-avatar-menu" style="margin-left: 8px;">${globalControls.avatar}</div>
                    <div class="user-chat-info" style="flex-grow: 1;"><h3>${pageTitle}</h3></div>
                    <div id="global-controls">${globalControls.otherControls}</div>
                </div>`;
                    el.mainContent.insertAdjacentHTML('beforeend', topBarHTML);

                    // Chatbot view handles its own header and global controls via React prop
                    el.mainContent.innerHTML += `<div id="chatbot-container-wrapper"></div>`;
                    const chatbotContainer = document.getElementById('chatbot-container-wrapper');
                    if (window.mountChatbotApp) {
                        reactRoot = window.mountChatbotApp(chatbotContainer, {
                            tools: allTools, // Pass all tools to chatbot for recommendations
                            initialConversations: conversations,
                            initialActiveId: activeConversationId,
                            onConversationsChange: (newConvos) => {
                                saveConversations(newConvos);
                                if (el.sideMenu.classList.contains('visible')) {
                                    renderSideMenu();
                                }
                            },
                            onOpenDetail: window.openDetailModal,
                            lang: currentLanguage,
                            pageTitle: pageTitles[currentView], // <-- RIGA AGGIUNTA
                            globalControlsHTML: getGlobalControlsHTML() // Pass controls HTML to React app
                        });
                    } else {
                        console.error("Chatbot mount function not found.");
                    }
                } else if (currentView === 'top-ai') {

                    // Limita a 4 le AI In evidenza
                    const featuredTools = staticTools.filter(t => t.isFeatured).slice(0, 4); // Solo 4 AI In evidenza
                    let contentHTML = `<div class="section-title" data-translate="featured">${t.featured}</div><div class="grid-container">`;

                    // Render static featured tools, potentially replaced by user tools
                    contentHTML += featuredTools.map(staticTool => {
                        const replacementToolId = currentUser.uid && currentUser.userFeaturedReplacements ? currentUser.userFeaturedReplacements[staticTool.id] : null;
                        const toolToDisplay = replacementToolId ? (currentUser.userTools || []).find(ut => ut.id === replacementToolId) : staticTool;
                        if (!toolToDisplay) return '';
                        // Passiamo l'ID dello strumento statico originale come opzione, in modo che createGridCard sappia come gestire la rimozione della sostituzione
                        return createGridCard(toolToDisplay, 'top-ai-featured', { staticToolId: staticTool.id });
                    }).join('');

                    contentHTML += `</div>`; // Close grid-container

                    // Le classifiche ora vengono da aiRankingsData
                    const rankingCategoryIdentifiers = ["All", ...new Set(aiRankingsData.map(r => r.category))];
                    const filtersHTML = `<div class="filters-container" style="top: 64px; margin-bottom: 20px;">
                    <div class="filter-pills" id="ranking-filters">
                        ${rankingCategoryIdentifiers.map(id => `<button class="pill-btn ${rankingFilter === id ? 'active' : ''}" data-action="set-ranking-filter" data-filter="${id}">${id === 'All' ? t.filterAll : getTranslatedCategoryName(id)}</button>`).join('')}
                    </div>
                </div>`;

                    const createRankingItem = (toolId, rank) => {
                        // Find the tool in the static list first, then user tools if not found
                        const tool = staticTools.find(t => t.id === toolId) || (currentUser.userTools || []).find(t => t.id === toolId);
                        if (!tool) return '';
                        return `
                        <li class="ranking-item" data-id="${tool.id}">
                            <span class="ranking-item-rank">${rank}</span>
                            <img src="${tool.logoUrl}" alt="${tool.name}" class="ranking-item-logo" loading="lazy">
                            <div class="ranking-item-info">
                                <div class="tool-name">${tool.name}</div>
                                <div class="tool-subtext">${getTranslatedCategoryName(tool.category)}</div>
                            </div>
                        </li>
                    `;
                    };

                    const rankingsHTML = `
                    <div class="section-title" style="margin-top: 40px;" data-translate="rankingsTitle">${t.rankingsTitle}</div>
                    ${filtersHTML}
                    <div class="ranking-section-container">
                        ${aiRankingsData.map(ranking => `
                            <div class="ranking-card" data-ranking-category="${ranking.category}">
                                <h3>${currentLanguage === 'it' ? ranking.title_it : ranking.title_en}</h3>
                                <ol class="ranking-list">
                                    ${ranking.toolIds.map((id, index) => createRankingItem(id, index + 1)).join('')}
                                </ol>
                            </div>
                        `).join('')}
                    </div>
                `;

                    contentHTML += rankingsHTML;
                    contentArea.innerHTML = contentHTML;
                    el.mainContent.appendChild(contentArea);

                    const rankingCards = document.querySelectorAll('.ranking-card');
                    rankingCards.forEach(card => {
                        if (rankingFilter !== 'All' && card.dataset.rankingCategory !== rankingFilter) {
                            card.classList.add('hidden');
                        } else {
                            card.classList.remove('hidden'); // Ensure it's visible if filter matches or is 'All'
                        }
                    });

                } else if (currentView === 'explore') {
                    el.mainContent.insertAdjacentHTML('beforeend', `<div class="search-bar-container"><input type="text" id="search-input" placeholder="${t.searchPlaceholder}"></div>`);


                    if (exploreFilter.type) {
                        const allTools = getAllToolsForCurrentUser();
                        const uniqueTools = allTools.filter((tool, idx, arr) => arr.findIndex(t => t.id === tool.id) === idx);
                        const filteredTools = uniqueTools.filter(t => t[exploreFilter.type] === exploreFilter.value);
                        const title = exploreFilter.type === 'category' ? getTranslatedCategoryName(exploreFilter.value) : `${t.toolsFrom} ${exploreFilter.value}`;

                        contentArea.innerHTML = `<div class="back-button" data-action="back-to-explore">${t.backToSearch}</div><h2 class="section-title">${title}</h2><div class="list-container">${filteredTools.map(tool => createListCard(tool, 'explore')).join('')}</div>`;

                    } else {
                        const toolsByCategory = {};
                        const allTools = getAllToolsForCurrentUser();
                        allTools.forEach(tool => {
                            const category = tool.category;
                            if (!toolsByCategory[category]) {
                                toolsByCategory[category] = [];
                            }
                            toolsByCategory[category].push(tool);
                        });

                        let feedHTML = '';
                        categories.forEach(category => {
                            const categoryId = category.id;
                            const categoryName = getTranslatedCategoryName(categoryId);
                            const tools = toolsByCategory[categoryId] || [];

                            if (tools.length > 0) {
                                // Cambiato t.browseAll in una stringa fissa per evitare errori se t non è definito qui
                                const seeAllText = (t && t.browseAll) ? t.browseAll : 'Vedi tutti';
                                feedHTML += `
                                <div class="feed-section">
                                    <div class="feed-section-header">
                                        <h2 class="feed-section-title">${categoryName}</h2>
                                        <button class="see-all-btn" data-action="set-explore-filter" data-filter-type="category" data-filter-value="${categoryId}">
                                            ${seeAllText} >
                                        </button>
                                    </div>
                                    <div class="horizontal-scroll-container">
                                        ${tools.map(tool => `
                                            <div class="tool-item-horizontal" data-id="${tool.id}">
                                                <div class="tool-item-logo-container">
                                                    <img src="${tool.logoUrl}" class="tool-logo" alt="${tool.name}" loading="lazy">
                                                </div>
                                                <div class="tool-item-name">${tool.name}</div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                            }
                        });

                        contentArea.innerHTML = feedHTML;
                    }

                    el.mainContent.appendChild(contentArea);
                } else if (currentView === 'search-users') {
                    if (isGuest) {
                        contentArea.innerHTML = `
                        <div class="auth-prompt-card">
                            <h3 data-translate="libraryPromptTitle">${t.libraryPromptTitle}</h3>
                            <p data-translate="libraryPromptText">${t.libraryPromptText}</p>
                            <div class="auth-prompt-actions">
                                <button class="button" data-action="prompt-login" data-translate="loginButton">${t.loginButton}</button>
                                <button class="pill-btn" data-action="prompt-register" data-translate="registerButton">${t.registerButton}</button>
                            </div>
                        </div>
                    `;
                    } else {
                        contentArea.innerHTML = `
                        <div class="search-users-container">
                            <div class="search-users-header">
                                <div class="search-users-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" height="48" viewBox="0 0 24 24" width="48" fill="currentColor">
                                        <path d="M0 0h24v24H0z" fill="none"/>
                                        <path d="M16 4c0-1.11.89-2 2-2s2 .89 2 2-.89 2-2 2-2-.89-2-2zm4 18v-6h2.5l-2.54-7.63A1.5 1.5 0 0 0 18.54 8H15.46c-.84 0-1.61.5-1.96 1.37L11 18h2v6h7zM12.5 11.5c.83 0 1.5-.67 1.5-1.5s-.67-1.5-1.5-1.5S11 9.17 11 10s.67 1.5 1.5 1.5zM5.5 6c1.11 0 2-.89 2-2s-.89-2-2-2-2 .89-2 2 .89 2 2 2zm2 16v-7H9V9c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v6h1.5v7h4z"/>
                                    </svg>
                                </div>
                                <h1 class="search-users-title" data-translate="searchUsersTitle">${t.searchUsersTitle}</h1>
                                <p class="search-users-subtitle" data-translate="searchUsersSubtitle">${t.searchUsersSubtitle}</p>
                            </div>
                            
                            <div class="search-users-input-container">
                                <div class="search-input-wrapper">
                                    <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20" fill="currentColor">
                                        <path d="M0 0h24v24H0z" fill="none"/>
                                        <path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                                    </svg>
                                    <input type="text" id="user-search-input" class="search-users-input" placeholder="${t.searchUsersPlaceholder}" autocomplete="off">
                                </div>
                            </div>
                            
                            <div id="user-search-results" class="search-results-container">
                                <!-- Search results will be populated here -->
                            </div>
                            

                        </div>
                    `;
                    }
                    el.mainContent.appendChild(contentArea);
                } else if (currentView === 'user-chats') {
                    if (isGuest) {
                        contentArea.innerHTML = `
                        <div class="auth-prompt-card">
                            <h3 data-translate="chatPromptTitle">${t.chatPromptTitle}</h3>
                            <p data-translate="chatPromptText">${t.chatPromptText}</p>
                            <div class="auth-prompt-actions">
                                <button class="button" data-action="prompt-login" data-translate="loginButton">${t.loginButton}</button>
                                <button class="pill-btn" data-action="prompt-register" data-translate="registerButton">${t.registerButton}</button>
                            </div>
                        </div>
                    `;
                        el.mainContent.appendChild(contentArea); // Aggiungi il prompt solo se l'utente è ospite
                    } else {
                        // Per l'utente loggato, monta l'app React direttamente senza aggiungere altro
                        el.mainContent.innerHTML = `<div id="user-chat-container-wrapper"></div>`;
                        const userChatContainer = document.getElementById('user-chat-container-wrapper');
                        if (window.mountUserChatApp) {
                            reactRoot = window.mountUserChatApp(userChatContainer, {
                                currentUser: currentUser,
                                onOpenDetail: window.openDetailModal,
                                lang: currentLanguage,
                                globalControlsHTML: getGlobalControlsHTML({ includeLangToggle: true })
                            });
                        } else {
                            console.error("User chat mount function not found.");
                        }
                    }
                } else if (currentView === 'favorites') { // NUOVO: Vista Libreria stile Spotify
                    if (isGuest) {
                        contentArea.innerHTML = `
                        <div class="auth-prompt-card">
                            <h3 data-translate="libraryPromptTitle">${t.libraryPromptTitle}</h3>
                            <p data-translate="libraryPromptText">${t.libraryPromptText}</p>
                            <div class="auth-prompt-actions">
                                <button class="button" data-action="prompt-login" data-translate="loginButton">${t.loginButton}</button>
                                <button class="pill-btn" data-action="prompt-register" data-translate="registerButton">${t.registerButton}</button>
                            </div>
                        </div>
                    `;
                    } else {
                        // --- STRUTTURA LIBRERIA CON FILTRI ---
                        const filtersHTML = `
                        <div id="library-filters-container">
                            <div class="filter-pills" id="library-filters">
                                <button class="pill-btn ${libraryTab === 'favorites' ? 'active' : ''}" data-action="set-library-tab" data-tab="favorites">${t.libraryFavorites}</button>
                                <button class="pill-btn ${libraryTab === 'custom' ? 'active' : ''}" data-action="set-library-tab" data-tab="custom">${t.libraryCustom}</button>
                                <button class="pill-btn ${libraryTab === 'suggested' ? 'active' : ''}" data-action="set-library-tab" data-tab="suggested">${t.librarySuggested}</button>
                            </div>
                        </div>
                    `;

                        const contentListHTML = `<div id="library-content-list" class="list-container" style="padding: 0 16px;"></div>`;

                        // FABs per aggiungere contenuti
                        const actionButtonsHTML = `
                        <button class="floating-action-btn" data-action="open-add-app-modal" title="${t.addCustomApp}" style="bottom: calc(var(--bottom-nav-height) + 16px);">
                           <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"></path></svg>
                        </button>
                        <button class="floating-action-btn" data-action="add-ai-suggestion" title="${t.addAiSuggestionTitle}" style="bottom: calc(var(--bottom-nav-height) + 88px);">
                             <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z"></path></svg>
                        </button>
                    `;

                        contentArea.innerHTML = filtersHTML + contentListHTML + actionButtonsHTML;

                        // --- FUNZIONE PER RENDERIZZARE IL CONTENUTO DELLA SCHEDA ATTIVA ---
                        const renderLibraryContent = async (tab) => {
                            const listContainer = document.getElementById('library-content-list');
                            if (!listContainer) return;
                            listContainer.innerHTML = `<div class="chat-bubble loading" style="margin: 40px auto; background: transparent;"><span></span><span></span><span></span></div>`;

                            let contentHTML = '';

                            if (tab === 'favorites') {
                                const favoriteIds = currentUser.favorites || [];
                                if (favoriteIds.length > 0) {
                                    // Logica asincrona per recuperare i dati completi dei preferiti
                                    const localTools = getAllToolsForCurrentUser();
                                    const fetchedUsersCache = new Map();
                                    const favoriteToolsPromises = favoriteIds.map(async (toolId) => {
                                        let tool = localTools.find(t => t.id === toolId);
                                        if (tool) return tool;
                                        if (toolId.startsWith('user-')) {
                                            const creatorId = toolId.split('-')[1];
                                            if (!creatorId) return null;
                                            let creatorData = fetchedUsersCache.get(creatorId);
                                            if (!creatorData) {
                                                const userDocRef = doc(db, "users", creatorId);
                                                const userDocSnap = await getDoc(userDocRef);
                                                creatorData = userDocSnap.exists() ? userDocSnap.data() : null;
                                                fetchedUsersCache.set(creatorId, creatorData);
                                            }
                                            if (creatorData) return (creatorData.userTools || []).find(t => t.id === toolId) || null;
                                        }
                                        return null;
                                    });
                                    const resolvedFavoriteTools = (await Promise.all(favoriteToolsPromises)).filter(Boolean);
                                    contentHTML = resolvedFavoriteTools.map(tool => createListCard(tool, 'favorites')).join('');
                                } else {
                                    contentHTML = `<div id="empty-state">${t.emptyFavorites}</div>`;
                                }
                            } else if (tab === 'custom') {
                                const userTools = currentUser.userTools || [];
                                if (userTools.length > 0) {
                                    contentHTML = userTools.map(tool => createListCard(tool, 'custom')).join('');
                                } else {
                                    contentHTML = `<div id="empty-state">${t.emptyUserTools}</div>`;
                                }
                            } else if (tab === 'suggested') {
                                const suggestions = currentUser.aiSuggestions || [];
                                if (suggestions.length > 0) {
                                    contentHTML = suggestions.map(s => `
                                    <div class="suggestion-list-item" data-id="${s.id}">
                                        <div class="suggestion-list-info">
                                            <div class="suggestion-list-app-name">${s.appName}</div>
                                            <div class="suggestion-list-desc">${s.description}</div>
                                        </div>
                                        <div class="suggestion-list-actions">
                                            <button class="remove-suggestion-btn" data-action="remove-ai-suggestion" data-id="${s.id}" title="${t.removeAiSuggestion}">
                                                <svg xmlns="http://www.w3.org/2000/svg" height="18" viewBox="0 0 24 24" width="18" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                                            </button>
                                        </div>
                                    </div>`).join('');
                                } else {
                                    contentHTML = `<div id="empty-state">${t.noSuggestions}</div>`;
                                }
                            }
                            listContainer.innerHTML = contentHTML;
                        };

                        // Renderizza il contenuto della scheda iniziale, con un timeout per garantire che il DOM sia pronto
                        setTimeout(() => renderLibraryContent(libraryTab), 0);
                    }
                    el.mainContent.appendChild(contentArea);
                }

                // NUOVO: Carica le valutazioni degli strumenti dopo aver renderizzato la vista (se abilitate)
                if (featureSettings.isRatingsEnabled) {
                    setTimeout(() => loadToolRatings(), 500);
                }

                // NUOVO: Nascondi/mostra il pulsante della chat in base alle impostazioni
                const chatNavBtn = document.getElementById('nav-btn-user-chats');
                if (chatNavBtn) {
                    chatNavBtn.style.display = featureSettings.isChatEnabled ? 'flex' : 'none';
                }

                updateNavActiveState();
                applyTranslations(currentLanguage); // Apply translations after rendering content
            };

            const updateNavActiveState = () => el.bottomNav.querySelectorAll('.nav-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.page === currentView));

            // --- AUTHENTICATION FUNCTIONS (Copied from index.html and adapted) ---

            const getAuthHTML = (lang) => {
                const t = translations[lang];
                return `
            <div id="register-card" class="auth-card">
                <button class="auth-close-btn" data-action="close-auth">×</button>
                <svg class="auth-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="48" stroke="currentColor" stroke-width="4" fill="none"/><text x="50" y="62" font-size="40" font-weight="bold" text-anchor="middle" fill="currentColor">AI</text></svg>
                                <h2 data-translate="createAccount">${t.createAccount}</h2>
                <div class="input-group"><label for="register-nickname" data-translate="registerNicknameLabel">${t.registerNicknameLabel}</label><input type="text" id="register-nickname" placeholder="${t.registerNicknamePlaceholder}"></div>
                <div class="input-group"><label for="register-fullname" data-translate="registerFullNameLabel">${t.registerFullNameLabel}</label><input type="text" id="register-fullname" placeholder="${t.registerFullNamePlaceholder}"></div>
                <div class="input-group"><label for="register-email" data-translate="registerEmailLabel">${t.registerEmailLabel}</label><input type="email" id="register-email" placeholder="${t.registerEmailPlaceholder}"></div>
                <div class="input-group">
                    <label for="register-password" data-translate="registerPasswordLabel">${t.registerPasswordLabel}</label>
                    <div class="password-input-wrapper">
                        <input type="password" id="register-password" placeholder="${t.registerPasswordPlaceholder}">
                        <button type="button" class="password-toggle-icon" data-action="toggle-password-visibility" data-toggle-for="register-password">${eyeIconSVG}</button>
                    </div>
                </div>
                <button id="register-btn" class="button" data-translate="registerButton">${t.registerButton}</button>
                <div class="auth-links"><a class="auth-switch-link" data-action="show-login" data-translate="switchToLogin">${t.switchToLogin}</a></div>
            </div>
            <div id="login-card" class="auth-card hidden">
                <button class="auth-close-btn" data-action="close-auth">×</button>
                <svg class="auth-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="48" stroke="currentColor" stroke-width="4" fill="none"/><text x="50" y="62" font-size="40" font-weight="bold" text-anchor="middle" fill="currentColor">AI</text></svg>
                <h2 data-translate="loginTitle">${t.loginTitle}</h2>
                <div class="input-group"><label for="login-email" data-translate="registerEmailLabel">${t.registerEmailLabel}</label><input type="email" id="login-email" placeholder="${t.registerEmailPlaceholder}"></div>
                <div class="input-group">
                    <label for="login-password" data-translate="registerPasswordLabel">${t.registerPasswordLabel}</label>
                    <div class="password-input-wrapper">
                        <input type="password" id="login-password" placeholder="${t.registerPasswordPlaceholder}">
                        <button type="button" class="password-toggle-icon" data-action="toggle-password-visibility" data-toggle-for="login-password">${eyeIconSVG}</button>
                    </div>
                </div>
                <button id="login-btn" class="button" data-translate="loginButton">${t.loginButton}</button>
                <div class="auth-links"><a class="auth-switch-link" data-action="show-register" data-translate="switchToRegister">${t.switchToRegister}</a><a class="forgot-password-link" data-action="show-forgot" data-translate="forgotPasswordLink">${t.forgotPasswordLink}</a></div>
            </div>
            <div id="forgot-password-card" class="auth-card hidden">
                <button class="auth-close-btn" data-action="close-auth">×</button>
                <svg class="auth-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="48" stroke="currentColor" stroke-width="4" fill="none"/><text x="50" y="62" font-size="40" font-weight="bold" text-anchor="middle" fill="currentColor">AI</text></svg>
                <h2 data-translate="resetPasswordTitle">${t.resetPasswordTitle}</h2>
                <p style="color: var(--spotify-text-secondary); font-size: 14px; margin-bottom: 20px;" data-translate="resetPasswordInfo">${t.resetPasswordInfo}</p>
                <div class="input-group"><label for="forgot-email" data-translate="registerEmailLabel">${t.registerEmailLabel}</label><input type="email" id="forgot-email" placeholder="${t.registerEmailPlaceholder}"></div>
                <button id="forgot-btn" class="button" data-translate="sendLinkButton">${t.sendLinkButton}</button>
                <div class="auth-links"><a class="auth-switch-link" data-action="show-login" data-translate="backToLogin">${t.backToLogin}</a></div>
            </div>`;
            };

            const showAuthCard = (cardId) => {
                el.authOverlay.querySelectorAll('.auth-card').forEach(c => c.classList.add('hidden'));
                const cardToShow = el.authOverlay.querySelector('#' + cardId);
                if (cardToShow) cardToShow.classList.remove('hidden');
            };

            const attachAuthListeners = () => {
                // Remove previous listeners to avoid duplicates
                // This is a bit heavy, ideally use event delegation or remove specific listeners
                // For this structure, re-attaching to the overlay is simpler.
                // Ensure the overlay itself is the target for delegation.

                // Clear existing listeners by replacing the element (simple but effective)
                const oldAuthOverlay = el.authOverlay;
                const newAuthOverlay = oldAuthOverlay.cloneNode(true);
                oldAuthOverlay.parentNode.replaceChild(newAuthOverlay, oldAuthOverlay);
                el.authOverlay = newAuthOverlay;


                el.authOverlay.addEventListener('click', (e) => {
                    const target = e.target;
                    const actionTarget = target.closest('[data-action]');

                    if (actionTarget) {
                        const action = actionTarget.dataset.action;
                        if (action === 'close-auth') { e.preventDefault(); closeAuthAndReturnToApp(); }
                        else if (action === 'show-login') { e.preventDefault(); showAuthCard('login-card'); }
                        else if (action === 'show-register') { e.preventDefault(); showAuthCard('register-card'); }
                        else if (action === 'show-forgot') { e.preventDefault(); showAuthCard('forgot-password-card'); }
                    }

                    // Handle button clicks directly (delegation is better but keeping original structure)
                    if (target.id === 'register-btn') {
                        const nickname = el.authOverlay.querySelector('#register-nickname').value.trim();
                        const fullName = el.authOverlay.querySelector('#register-fullname').value.trim();
                        const email = el.authOverlay.querySelector('#register-email').value;
                        const password = el.authOverlay.querySelector('#register-password').value;
                        const t = translations[currentLanguage];

                        if (!nickname) { showToast(t.nicknameRequired); return; }
                        if (!fullName) { showToast(t.fullNameRequired); return; }
                        if (!email.includes('@') || password.length < 6) { showToast(t.passwordTooShort); return; }

                        createUserWithEmailAndPassword(auth, email, password).then((userCredential) => {
                            // After successful registration, save nickname and full name to Firestore
                            const userDocRef = doc(db, "users", userCredential.user.uid);
                            const initialUserData = {
                                email: email,
                                nickname: nickname,
                                fullName: fullName,
                                favorites: [],
                                userTools: [],
                                userFeaturedTools: [],
                                userFeaturedReplacements: {},
                                isPrivileged: false,
                                aiSuggestions: [], // New field for AI suggestions
                                role: 'user' // NUOVO: Assegna il ruolo di default
                            };
                            setDoc(userDocRef, initialUserData).catch(e => console.error("Error creating user doc:", e));
                        }).catch(error => showToast(`Error: ${error.message}`));
                    }
                    if (target.id === 'login-btn') {
                        const email = el.authOverlay.querySelector('#login-email').value;
                        const password = el.authOverlay.querySelector('#login-password').value;
                        const t = translations[currentLanguage];
                        if (!email || !password) { showToast(t.registerEmailLabel + ' / ' + t.registerPasswordLabel); return; } // Simplified message
                        signInWithEmailAndPassword(auth, email, password).catch(error => showToast(`Error: ${error.message}`));
                    }
                    if (target.id === 'forgot-btn') {
                        const email = el.authOverlay.querySelector('#forgot-email').value;
                        const t = translations[currentLanguage];
                        if (!email.includes('@')) { showToast(t.registerEmailLabel); return; } // Simplified message
                        sendPasswordResetEmail(auth, email).then(() => {
                            showToast(t.passwordResetSent.replace('%s', email));
                            showAuthCard('login-card');
                        }).catch(error => showToast(`Error: ${error.message}`));
                    }
                });
            };

            const triggerAuthFlow = (card = 'login-card') => {
                el.appContainer.style.display = 'none';
                el.authOverlay.innerHTML = getAuthHTML(currentLanguage); // Generate HTML
                attachAuthListeners(); // Attach listeners to the new HTML
                el.authOverlay.style.display = 'flex';
                el.authOverlay.classList.remove('hidden');
                showAuthCard(card); // Show the requested card
            };

            const closeAuthAndReturnToApp = () => {
                el.authOverlay.classList.add('hidden');
                el.authOverlay.addEventListener('transitionend', () => {
                    el.authOverlay.style.display = 'none';
                    el.authOverlay.innerHTML = ''; // Clear content after transition
                }, { once: true });
                el.appContainer.style.display = 'flex';
            };

            // --- SETTINGS MODAL FUNCTIONS (Copied from index.html and adapted) ---

            window.openSettingsModal = () => {
                if (!currentUser.uid) return;
                const t = translations[currentLanguage];
                const logoutIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2z"/></svg>`;

                const modalHTML = `
                <div id="settings-modal" class="modal-overlay visible">
                    <div class="modal-content">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        
                        <div class="settings-modal-header">
                            <button class="global-btn" data-action="logout" title="${t.logout}">${logoutIconSVG}</button>
                            <h2 data-translate="settingsTitle">${t.settingsTitle}</h2>
                            <div style="width: 32px; height: 32px;"></div> <!-- Placeholder to balance logout button -->
                        </div>
                        
                        <p style="font-size: 16px; color: var(--spotify-text-secondary); margin-bottom: 24px; text-align: center;">${currentUser.name}</p>
                        
                        <hr class="modal-divider">

                        <h4 data-translate="changeNicknameTitle">${t.changeNicknameTitle}</h4>
                        <div class="input-group" style="margin-top: 16px;">
                            <label for="profile-nickname" data-translate="registerNicknameLabel">${t.registerNicknameLabel}</label>
                            <input type="text" id="profile-nickname" placeholder="${t.registerNicknamePlaceholder}" value="${currentUser.nickname || ''}">
                        </div>
                        <button class="button" id="update-nickname-btn" data-translate="saveNicknameButton">${t.saveNicknameButton}</button>

                        <hr class="modal-divider">

                        <h4 data-translate="changePasswordTitle">${t.changePasswordTitle}</h4>
                        <div class="input-group" style="margin-top: 16px;">
                            <label for="profile-new-password" data-translate="newPasswordLabel">${t.newPasswordLabel}</label>
                            <div class="password-input-wrapper">
                                <input type="password" id="profile-new-password" placeholder="${t.newPasswordPlaceholder}">
                                <button type="button" class="password-toggle-icon" data-action="toggle-password-visibility" data-toggle-for="profile-new-password">${eyeIconSVG}</button>
                            </div>
                        </div>
                        <div class="input-group">
                            <label for="profile-confirm-password" data-translate="confirmPasswordLabel">${t.confirmPasswordLabel}</label>
                             <div class="password-input-wrapper">
                                <input type="password" id="profile-confirm-password" placeholder="${t.confirmPasswordPlaceholder}">
                                <button type="button" class="password-toggle-icon" data-action="toggle-password-visibility" data-toggle-for="profile-confirm-password">${eyeIconSVG}</button>
                            </div>
                        </div>
                        <button class="button" id="update-password-btn" data-translate="savePasswordButton">${t.savePasswordButton}</button>

                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;

                // Attach listener to the update nickname button
                document.getElementById('update-nickname-btn')?.addEventListener('click', handleNicknameUpdate);
                // Attach listener to the update password button
                document.getElementById('update-password-btn')?.addEventListener('click', handlePasswordUpdate);
                // The logout action is now handled by the main body event listener via data-action="logout"
            };

            const handleNicknameUpdate = async () => {
                const nicknameInput = document.getElementById('profile-nickname');
                const newNickname = nicknameInput.value.trim();
                const t = translations[currentLanguage];

                if (!newNickname) {
                    showToast(t.nicknameRequired);
                    return;
                }

                try {
                    const userDocRef = doc(db, "users", currentUser.uid);
                    await updateDoc(userDocRef, { nickname: newNickname });
                    currentUser.nickname = newNickname;
                    showToast(t.nicknameUpdateSuccess);
                    closeModal(); // Close modal on success
                } catch (error) {
                    console.error("Error updating nickname:", error);
                    showToast(`Error: ${error.message}`);
                }
            };

            const handlePasswordUpdate = async () => {
                const newPasswordInput = document.getElementById('profile-new-password');
                const confirmPasswordInput = document.getElementById('profile-confirm-password');
                const newPassword = newPasswordInput.value;
                const confirmPassword = confirmPasswordInput.value;
                const t = translations[currentLanguage];

                if (newPassword.length < 6) {
                    showToast(t.passwordTooShort);
                    return;
                }
                if (newPassword !== confirmPassword) {
                    showToast(t.passwordsDoNotMatch);
                    return;
                }

                try {
                    await updatePassword(auth.currentUser, newPassword);
                    showToast(t.passwordUpdateSuccess);
                    newPasswordInput.value = '';
                    confirmPasswordInput.value = '';
                    closeModal(); // Close modal on success
                } catch (error) {
                    console.error("Error updating password:", error);
                    showToast(t.updatePasswordError.replace('%s', error.message));
                }
            };

            // NEW FUNCTION: Open Add App Modal
            const openAddAppModal = () => {
                // Only allow logged-in users to open this modal.
                if (!currentUser.uid) return;
                const t = translations[currentLanguage];

                // Get available categories for the dropdown
                const categoryOptions = categories.map(cat =>
                    `<option value="${cat.id}">${cat.name[currentLanguage]}</option>`
                ).join('');

                const modalHTML = `
                 <div id="add-app-modal" class="modal-overlay visible">
                     <div class="modal-content">
                         <button class="modal-close-btn" data-action="close-modal">×</button>
                         <h2 data-translate="addAppTitle">${t.addAppTitle}</h2>

                         <div class="input-group" style="margin-top: 24px;">
                             <label for="add-app-name" data-translate="appNameLabel">${t.appNameLabel}</label>
                             <input type="text" id="add-app-name" placeholder="${t.appNamePlaceholder}">
                         </div>
                         <div class="input-group">
                             <label for="add-app-description" data-translate="appDescriptionLabel">${t.appDescriptionLabel}</label>
                             <textarea id="add-app-description" placeholder="${t.appDescriptionPlaceholder}"></textarea>
                         </div>
                         <div class="input-group">
                             <label for="add-app-website" data-translate="appWebsiteLabel">${t.appWebsiteLabel}</label>
                             <input type="url" id="add-app-website" placeholder="${t.appWebsitePlaceholder}">
                         </div>
                         <div class="input-group">
                             <label for="add-app-logo" data-translate="appLogoLabel">${t.appLogoLabel}</label>
                             <input type="file" id="add-app-logo" accept="image/*">
                             <img id="add-app-logo-preview" src="" alt="Logo Preview" style="display: none;">
                         </div>
                         <div class="input-group">
                             <label for="add-app-category" data-translate="category">${t.category}</label>
                             <select id="add-app-category" style="width: 100%; padding: 14px 16px; font-size: 16px; background-color: var(--spotify-bg-light); border: 1px solid rgba(128,128,128,0.2); border-radius: 8px; color: var(--spotify-text);">
                                 ${categoryOptions}
                             </select>
                         </div>

                         <button class="button" id="add-app-btn" data-translate="addAppButton">${t.addAppButton}</button>
                     </div>
                 </div>
             `;
                el.modalContainer.innerHTML = modalHTML;

                // Attach listener to the add app button
                document.getElementById('add-app-btn')?.addEventListener('click', handleAddApp);

                // Attach listener for file input change to show preview
                const logoInput = document.getElementById('add-app-logo');
                const logoPreview = document.getElementById('add-app-logo-preview');
                logoInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            logoPreview.src = e.target.result;
                            logoPreview.style.display = 'block';
                        };
                        reader.readAsDataURL(file);
                    } else {
                        logoPreview.src = '';
                        logoPreview.style.display = 'none';
                    }
                });
            };

            // NEW FUNCTION: Open Change Nickname Modal
            const openChangeNicknameModal = () => {
                if (!currentUser.uid) return;
                const t = translations[currentLanguage];

                const modalHTML = `
                <div id="change-nickname-modal" class="modal-overlay visible">
                    <div class="modal-content">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <h2 data-translate="changeNicknameTitle">${t.changeNicknameTitle}</h2>
                        
                        <div class="input-group" style="margin-top: 24px;">
                            <label for="change-nickname-input" data-translate="registerNicknameLabel">${t.registerNicknameLabel}</label>
                            <input type="text" id="change-nickname-input" placeholder="${t.registerNicknamePlaceholder}" value="${currentUser.nickname || ''}">
                        </div>
                        <button class="button" id="save-nickname-btn" data-translate="saveNicknameButton">${t.saveNicknameButton}</button>
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;

                // Attach listener to the save nickname button
                document.getElementById('save-nickname-btn')?.addEventListener('click', handleChangeNickname);
            };

            // NEW FUNCTION: Open Change Password Modal
            const openChangePasswordModal = () => {
                if (!currentUser.uid) return;
                const t = translations[currentLanguage];

                const modalHTML = `
                <div id="change-password-modal" class="modal-overlay visible">
                    <div class="modal-content">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <h2 data-translate="changePasswordTitle">${t.changePasswordTitle}</h2>
                        
                        <div class="input-group" style="margin-top: 24px;">
                            <label for="change-new-password" data-translate="newPasswordLabel">${t.newPasswordLabel}</label>
                            <div class="password-input-wrapper">
                                <input type="password" id="change-new-password" placeholder="${t.newPasswordPlaceholder}">
                                <button type="button" class="password-toggle-icon" data-action="toggle-password-visibility" data-toggle-for="change-new-password">${eyeIconSVG}</button>
                            </div>
                        </div>
                        <div class="input-group">
                            <label for="change-confirm-password" data-translate="confirmPasswordLabel">${t.confirmPasswordLabel}</label>
                            <div class="password-input-wrapper">
                                <input type="password" id="change-confirm-password" placeholder="${t.confirmPasswordPlaceholder}">
                                <button type="button" class="password-toggle-icon" data-action="toggle-password-visibility" data-toggle-for="change-confirm-password">${eyeIconSVG}</button>
                            </div>
                        </div>
                        <button class="button" id="save-password-btn" data-translate="savePasswordButton">${t.savePasswordButton}</button>
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;

                // Attach listener to the save password button
                document.getElementById('save-password-btn')?.addEventListener('click', handleChangePassword);
            };

            // NEW FUNCTION: Handle Change Nickname
            const handleChangeNickname = async () => {
                const nicknameInput = document.getElementById('change-nickname-input');
                const newNickname = nicknameInput.value.trim();
                const t = translations[currentLanguage];

                if (!newNickname) {
                    showToast(t.nicknameRequired);
                    return;
                }

                try {
                    const userDocRef = doc(db, "users", currentUser.uid);
                    await updateDoc(userDocRef, { nickname: newNickname });
                    currentUser.nickname = newNickname;
                    showToast(t.nicknameUpdateSuccess);
                    closeModal();
                } catch (error) {
                    console.error("Error updating nickname:", error);
                    showToast(`Error: ${error.message}`);
                }
            };

            // NEW FUNCTION: Handle Change Password
            const handleChangePassword = async () => {
                const newPasswordInput = document.getElementById('change-new-password');
                const confirmPasswordInput = document.getElementById('change-confirm-password');
                const newPassword = newPasswordInput.value;
                const confirmPassword = confirmPasswordInput.value;
                const t = translations[currentLanguage];

                if (newPassword.length < 6) {
                    showToast(t.passwordTooShort);
                    return;
                }
                if (newPassword !== confirmPassword) {
                    showToast(t.passwordsDoNotMatch);
                    return;
                }

                try {
                    await updatePassword(auth.currentUser, newPassword);
                    showToast(t.passwordUpdateSuccess);
                    newPasswordInput.value = '';
                    confirmPasswordInput.value = '';
                    closeModal();
                } catch (error) {
                    console.error("Error updating password:", error);
                    showToast(t.updatePasswordError.replace('%s', error.message));
                }
            };

            const handleLogout = async () => {
                if (currentUser && currentUser.uid) {
                    try {
                        // 1. Imposta lo stato a 'offline' su Firebase e attende il completamento
                        await updateUserOnlineStatus(currentUser.uid, false);

                        // 2. Solo dopo, esegue il logout da Firebase Auth
                        await signOut(auth);

                        // 3. Mostra un messaggio di successo
                        showToast(translations[currentLanguage].logout + " effettuato.");
                    } catch (error) {
                        console.error("Logout Error:", error);
                        showToast("Errore durante il logout.");
                    }
                }
            };

            // NEW FUNCTION: Open Sent Reviews Modal
            const openSentReviewsModal = async () => {
                if (!currentUser.uid) return;
                const t = translations[currentLanguage];

                const modalHTML = `
                <div id="sent-reviews-modal" class="sent-reviews-modal visible">
                    <div class="sent-reviews-modal-content">
                        <div class="sent-reviews-modal-header">
                            <h2 class="sent-reviews-modal-title" data-translate="sentReviews">Recensioni inviate</h2>
                            <button class="sent-reviews-modal-close" data-action="close-modal">×</button>
                        </div>
                        <div id="sent-reviews-container">
                            <div class="loading-reviews">${t.loadingReviews || 'Caricamento recensioni...'}</div>
                        </div>
                    </div>
                </div>`;

                el.modalContainer.innerHTML = modalHTML;
                await loadSentReviews();
            };

            // NEW FUNCTION: Load Sent Reviews (CORRECTED AND OPTIMIZED)
            const loadSentReviews = async () => {
                const container = document.getElementById('sent-reviews-container');
                if (!container || !currentUser.uid) return;

                const t = translations[currentLanguage];
                container.innerHTML = `<div class="loading-reviews">${t.loadingReviews || 'Caricamento recensioni...'}</div>`;

                try {
                    // Step 1: Use a Collection Group Query to find all reviews by the current user
                    const reviewsQuery = query(collectionGroup(db, 'reviews'), where('userId', '==', currentUser.uid));
                    const reviewsSnapshot = await getDocs(reviewsQuery);

                    if (reviewsSnapshot.empty) {
                        container.innerHTML = `<div class="no-sent-reviews">${t.noSentReviews || 'Non hai ancora inviato recensioni.'}</div>`;
                        return;
                    }

                    // Step 2: Prepare to fetch the tool data for each review
                    const reviewsWithToolData = [];
                    for (const reviewDoc of reviewsSnapshot.docs) {
                        const reviewData = reviewDoc.data();
                        const toolId = reviewDoc.ref.parent.parent.id; // Get the parent tool ID

                        // Find the tool in the local list (static + custom)
                        const tool = getAllToolsForCurrentUser().find(t => t.id === toolId);

                        if (tool) {
                            reviewsWithToolData.push({
                                id: reviewDoc.id,
                                toolId: toolId,
                                toolName: tool.name, // Use name from local data
                                toolLogoUrl: tool.logoUrl, // Use logo from local data
                                ...reviewData
                            });
                        }
                    }

                    // Step 3: Sort and render the reviews
                    reviewsWithToolData.sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0));

                    const reviewsHTML = reviewsWithToolData.map(review => {
                        const starsHTML = Array.from({ length: 5 }, (_, i) =>
                            `<span class="star ${i < review.rating ? '' : 'empty'}">★</span>`
                        ).join('');
                        const reviewDate = review.createdAt ? new Date(review.createdAt.seconds * 1000).toLocaleDateString() : 'N/A';

                        return `
                        <div class="sent-review-item">
                            <div class="sent-review-header">
                                <div class="sent-review-tool-info">
                                    <img src="${review.toolLogoUrl}" alt="${review.toolName}" class="sent-review-tool-logo">
                                    <div class="sent-review-tool-name">${review.toolName}</div>
                                </div>
                                <div class="sent-review-actions">
                                    <button class="sent-review-edit-btn" data-action="edit-review" data-tool-id="${review.toolId}" data-review-id="${review.id}">Modifica</button>
                                    <button class="sent-review-delete-btn" data-action="delete-review" data-tool-id="${review.toolId}" data-review-id="${review.id}">Elimina</button>
                                </div>
                            </div>
                            <div class="sent-review-rating">${starsHTML}</div>
                            <div class="sent-review-text">${review.text}</div>
                            <div class="sent-review-date">${reviewDate}</div>
                        </div>`;
                    }).join('');

                    container.innerHTML = reviewsHTML;

                } catch (error) {
                    console.error('Error loading sent reviews:', error);
                    container.innerHTML = `<div class="no-sent-reviews">Errore nel caricamento delle recensioni.</div>`;
                    // Firestore often gives a helpful error message in the console with a link to create the required index for collection group queries.
                    if (error.message.includes('index')) {
                        container.innerHTML += `<p style="font-size:12px; color: #ff6b6b; margin-top: 10px;">Questo errore potrebbe richiedere la creazione di un indice in Firestore. Controlla la console del browser per un link di creazione automatica.</p>`;
                    }
                }
            };

            // NEW FUNCTION: Open All User Reviews Modal
            const openAllUserReviewsModal = async (toolId) => {
                const t = translations[currentLanguage];

                const modalHTML = `
                <div id="all-user-reviews-modal" class="sent-reviews-modal visible">
                    <div class="sent-reviews-modal-content">
                        <div class="sent-reviews-modal-header">
                            <h2 class="sent-reviews-modal-title" data-translate="allUserReviews">Tutte le recensioni utente</h2>
                            <button class="sent-reviews-modal-close" data-action="close-modal">×</button>
                        </div>
                        <div id="all-user-reviews-container">
                            <div class="loading-reviews">${t.loadingReviews || 'Caricamento recensioni...'}</div>
                        </div>
                    </div>
                </div>`;

                el.modalContainer.innerHTML = modalHTML;
                await loadAllUserReviews(toolId);
            };

            // NEW FUNCTION: Load All User Reviews for a specific tool
            const loadAllUserReviews = async (toolId) => {
                const container = document.getElementById('all-user-reviews-container');
                if (!container) return;

                try {
                    const t = translations[currentLanguage];
                    const reviewsRef = collection(db, 'tools', toolId, 'reviews');
                    const reviewsQuery = query(reviewsRef, orderBy('createdAt', 'desc'));
                    const reviewsSnapshot = await getDocs(reviewsQuery);

                    if (reviewsSnapshot.empty) {
                        container.innerHTML = `<div class="no-reviews">${t.noReviews}</div>`;
                        return;
                    }

                    let reviewsHTML = '';
                    for (const reviewDoc of reviewsSnapshot.docs) {
                        const review = reviewDoc.data();
                        let username = 'Utente Anonimo';
                        let userInitial = 'U';

                        if (review.userId) {
                            try {
                                const userDoc = await getDoc(doc(db, 'users', review.userId));
                                if (userDoc.exists()) {
                                    const userData = userDoc.data();
                                    username = userData.nickname || userData.name || 'Utente';
                                    userInitial = username.charAt(0).toUpperCase();
                                }
                            } catch (error) {
                                console.error('Error fetching user data:', error);
                            }
                        }

                        const starsHTML = Array.from({ length: 5 }, (_, i) =>
                            `<span class="star ${i < review.rating ? '' : 'empty'}">★</span>`
                        ).join('');

                        reviewsHTML += `
                        <div class="review-item">
                            <div class="review-header">
                                <div class="review-user">
                                    <div class="review-avatar">${userInitial}</div>
                                    <div class="review-user-info">
                                        <div class="review-username">${username}</div>
                                        <div class="review-date">${review.createdAt?.toDate().toLocaleDateString()}</div>
                                    </div>
                                </div>
                                <div class="review-rating">${starsHTML}</div>
                            </div>
                            <div class="review-text">${review.text}</div>
                        </div>`;
                    }

                    container.innerHTML = reviewsHTML;
                } catch (error) {
                    console.error('Error loading all user reviews:', error);
                    container.innerHTML = '<div class="no-reviews">Errore nel caricamento delle recensioni.</div>';
                }
            };

            // NEW FUNCTION: Open Edit Review Modal
            const openEditReviewModal = async (toolId, reviewId) => {
                if (!currentUser.uid) return;

                try {
                    const reviewDoc = await getDoc(doc(db, 'tools', toolId, 'reviews', reviewId));
                    if (!reviewDoc.exists()) {
                        showToast('Recensione non trovata');
                        return;
                    }

                    const reviewData = reviewDoc.data();
                    const t = translations[currentLanguage];

                    const modalHTML = `
                    <div id="edit-review-modal" class="review-modal visible">
                        <div class="review-modal-content">
                            <div class="review-modal-header">
                                <h2 class="review-modal-title">Modifica Recensione</h2>
                                <button class="review-modal-close" data-action="close-modal">×</button>
                            </div>
                            <div class="rating-input-container">
                                <label class="rating-input-label">Valutazione</label>
                                <div class="stars-input">
                                    ${Array.from({ length: 5 }, (_, i) =>
                        `<span class="star-input ${i < reviewData.rating ? 'active' : ''}" data-rating="${i + 1}">★</span>`
                    ).join('')}
                                </div>
                            </div>
                            <div class="review-text-container">
                                <label class="review-text-label">Recensione</label>
                                <textarea class="review-text-input" id="edit-review-text" placeholder="Scrivi la tua recensione...">${reviewData.text}</textarea>
                            </div>
                            <div class="review-modal-actions">
                                <button class="review-cancel-btn" data-action="close-modal">Annulla</button>
                                <button class="review-submit-btn" id="update-review-btn" data-tool-id="${toolId}" data-review-id="${reviewId}">Aggiorna Recensione</button>
                            </div>
                        </div>
                    </div>`;

                    el.modalContainer.innerHTML = modalHTML;

                    // Set current rating
                    window.currentEditRating = reviewData.rating;

                    // Attach event listener for update
                    document.getElementById('update-review-btn')?.addEventListener('click', handleUpdateReview);
                } catch (error) {
                    console.error('Error opening edit review modal:', error);
                    showToast('Errore nel caricamento della recensione');
                }
            };

            // NEW FUNCTION: Handle Update Review
            const handleUpdateReview = async (event) => {
                const toolId = event.target.dataset.toolId;
                const reviewId = event.target.dataset.reviewId;
                const reviewText = document.getElementById('edit-review-text').value.trim();
                const rating = window.currentEditRating || 1;

                if (!reviewText) {
                    showToast('Inserisci il testo della recensione');
                    return;
                }

                try {
                    const reviewRef = doc(db, 'tools', toolId, 'reviews', reviewId);
                    await updateDoc(reviewRef, {
                        text: reviewText,
                        rating: rating,
                        updatedAt: new Date()
                    });

                    showToast('Recensione aggiornata con successo');
                    closeModal();

                    // Refresh the sent reviews modal if it's open
                    if (document.getElementById('sent-reviews-modal')) {
                        await loadSentReviews();
                    }
                } catch (error) {
                    console.error('Error updating review:', error);
                    showToast('Errore nell\'aggiornamento della recensione');
                }
            };

            // NEW FUNCTION: Confirm Delete Review
            const confirmDeleteReview = (toolId, reviewId) => {
                const t = translations[currentLanguage];

                const modalHTML = `
                <div id="confirm-delete-review-modal" class="modal-overlay visible">
                    <div class="modal-content">
                        <h2>Conferma Eliminazione</h2>
                        <p>Sei sicuro di voler eliminare questa recensione? Questa azione non può essere annullata.</p>
                        <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px;">
                            <button class="review-cancel-btn" data-action="close-modal">Annulla</button>
                            <button class="review-submit-btn" id="confirm-delete-review-btn" data-tool-id="${toolId}" data-review-id="${reviewId}" style="background-color: #ff6b6b;">Elimina</button>
                        </div>
                    </div>
                </div>`;

                el.modalContainer.innerHTML = modalHTML;

                // Attach event listener for delete confirmation
                document.getElementById('confirm-delete-review-btn')?.addEventListener('click', handleDeleteReview);
            };

            // NEW FUNCTION: Handle Delete Review
            const handleDeleteReview = async (event) => {
                const toolId = event.target.dataset.toolId;
                const reviewId = event.target.dataset.reviewId;

                try {
                    await deleteDoc(doc(db, 'tools', toolId, 'reviews', reviewId));
                    showToast('Recensione eliminata con successo');
                    closeModal();

                    // Refresh the sent reviews modal if it's open
                    if (document.getElementById('sent-reviews-modal')) {
                        await loadSentReviews();
                    }
                } catch (error) {
                    console.error('Error deleting review:', error);
                    showToast('Errore nell\'eliminazione della recensione');
                }
            };

            // NEW FUNCTION: Open Replace Featured Modal
            const openReplaceFeaturedModal = (staticToolId) => {
                // Allow any logged-in user to perform this action
                if (!currentUser.uid) return;
                const t = translations[currentLanguage];
                const userTools = currentUser.userTools || [];

                const toolListHTML = userTools.length > 0 ? userTools.map(tool => `
                 <div class="tool-list-item" data-action="select-user-tool-for-featured" data-static-id="${staticToolId}" data-user-id="${tool.id}">
                     <img src="${tool.logoUrl}" alt="${tool.name}" loading="lazy">
                     <div class="info">
                         <div class="tool-name">${tool.name}</div>
                         <div class="tool-subtext">${getTranslatedCategoryName(tool.category)}</div>
                     </div>
                 </div>
             `).join('') : `<div id="empty-state" style="padding: 20px 0;">${t.noUserApps}</div>`;


                const modalHTML = `
                 <div id="replace-featured-modal" class="modal-overlay visible">
                     <div class="modal-content">
                         <button class="modal-close-btn" data-action="close-modal">×</button>
                         <h2 data-translate="replaceFeaturedTitle">${t.replaceFeaturedTitle}</h2>
                         <p style="color: var(--spotify-text-secondary); font-size: 14px; margin-bottom: 20px;" data-translate="selectAppToFeature">${t.selectAppToFeature}</p>
                         <div class="list-container">
                             ${toolListHTML}
                         </div>
                     </div>
                 </div>
             `;
                el.modalContainer.innerHTML = modalHTML;
            };


            // NEW FUNCTION: Handle Add App submission (Firestore)
            const handleAddApp = async () => { // Assicuriamoci che sia asincrona per Firestore
                // Permetti solo agli utenti loggati di inviare il form
                if (!currentUser.uid) return;

                const nameInput = document.getElementById('add-app-name');
                const descInput = document.getElementById('add-app-description');
                const websiteInput = document.getElementById('add-app-website');
                const logoInput = document.getElementById('add-app-logo'); // Input di tipo file
                const categorySelect = document.getElementById('add-app-category');

                const name = nameInput.value.trim();
                const description = descInput.value.trim();
                const website = websiteInput.value.trim();
                const file = logoInput.files[0]; // Ottieni il file selezionato
                const category = categorySelect.value;
                const t = translations[currentLanguage];

                // Validazione campi
                if (!name) { showToast(t.appNameRequired); return; }
                if (!website) { showToast(t.appWebsiteRequired); return; }
                if (!file) { showToast(t.appLogoRequired); return; }

                // Converti il file immagine in una stringa Base64 per salvarla su Firestore
                const logoUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });

                // Crea il nuovo oggetto 'tool'
                const newTool = {
                    id: `user-${currentUser.uid}-${Date.now()}`, // ID univoco per le app utente
                    name: name,
                    // CORREZIONE: La descrizione è sempre un oggetto per coerenza
                    description: {
                        it: description || 'Descrizione non fornita.',
                        en: description || 'Description not provided.'
                    },
                    website: website,
                    logoUrl: logoUrl, // Stringa Base64 dell'immagine
                    category: category,
                    country: 'User Added', // Identifica l'origine
                };

                const userDocRef = doc(db, "users", currentUser.uid);

                try {
                    // Usa arrayUnion per aggiungere il nuovo tool all'array 'userTools' in Firestore
                    await updateDoc(userDocRef, {
                        userTools: arrayUnion(newTool)
                    });
                    // Aggiorna lo stato locale per riflettere immediatamente la modifica nella UI
                    currentUser.userTools = [...(currentUser.userTools || []), newTool];

                    showToast(t.addAppSuccess);
                    closeModal();
                    renderView(); // Ri-disegna la vista per mostrare la nuova app
                } catch (error) {
                    console.error("Errore nell'aggiungere l'app utente:", error);
                    showToast(t.addAppError.replace('%s', error.message));
                }
            };

            // NEW FUNCTION: Open Edit App Modal
            const openEditAppModal = (toolId) => {
                if (!currentUser.uid) return;
                const t = translations[currentLanguage];
                const tool = (currentUser.userTools || []).find(t => t.id === toolId);
                if (!tool) {
                    showToast("App not found.");
                    return;
                }

                const modalHTML = `
                 <div id="edit-app-modal" class="modal-overlay visible">
                     <div class="modal-content">
                         <button class="modal-close-btn" data-action="close-modal">×</button>
                         <h2 data-translate="editAppTitle">${t.editAppTitle}</h2>

                         <div class="input-group" style="margin-top: 24px;">
                             <label for="edit-app-name">${t.appNameLabel}</label>
                             <input type="text" id="edit-app-name" value="${tool.name}">
                         </div>
                         <div class="input-group">
                             <label for="edit-app-website">${t.appWebsiteLabel}</label>
                             <input type="url" id="edit-app-website" value="${tool.website}">
                         </div>

                         <div style="display: flex; justify-content: space-between; gap: 12px; margin-top: 24px;">
                            <button class="button" id="delete-app-btn" data-id="${tool.id}" style="background-color: #cc3333; flex-grow: 1;">${t.deleteButton}</button>
                            <button class="button" id="update-app-btn" data-id="${tool.id}" style="flex-grow: 2;">${t.saveChanges}</button>
                         </div>
                     </div>
                 </div>
             `;
                el.modalContainer.innerHTML = modalHTML;

                document.getElementById('update-app-btn').addEventListener('click', (e) => {
                    console.log('update-app-btn clicked');
                    const id = e.currentTarget.dataset.id;
                    console.log('App ID:', id);
                    handleUpdateApp(id);
                });

                document.getElementById('delete-app-btn').addEventListener('click', (e) => {
                    if (confirm(t.confirmDeleteApp)) {
                        const id = e.currentTarget.dataset.id;
                        removeUserTool(id);
                    }
                });
            };

            // NEW FUNCTION: Handle app update
            const handleUpdateApp = async (toolId) => {
                console.log('handleUpdateApp called with toolId:', toolId);
                if (!currentUser.uid) {
                    console.log('No user logged in');
                    return;
                }

                const t = translations[currentLanguage];
                const nameInput = document.getElementById('edit-app-name');
                const websiteInput = document.getElementById('edit-app-website');

                const newName = nameInput.value.trim();
                const newWebsite = websiteInput.value.trim();

                if (!newName) {
                    showToast(t.appNameRequired);
                    return;
                }
                if (!newWebsite) {
                    showToast(t.appWebsiteRequired);
                    return;
                }

                try {
                    new URL(newWebsite);
                } catch (e) {
                    showToast("URL del sito web non valido.");
                    return;
                }

                const toolIndex = (currentUser.userTools || []).findIndex(t => t.id === toolId);

                if (toolIndex === -1) {
                    showToast("App non trovata.");
                    return;
                }

                const updatedUserTools = [...currentUser.userTools];
                updatedUserTools[toolIndex] = {
                    ...updatedUserTools[toolIndex],
                    name: newName,
                    website: newWebsite
                };

                const userDocRef = doc(db, "users", currentUser.uid);

                try {
                    await updateDoc(userDocRef, {
                        userTools: updatedUserTools
                    });

                    currentUser.userTools = updatedUserTools;

                    showToast(t.appUpdateSuccess);
                    closeModal();
                    renderView();
                } catch (error) {
                    console.error("Errore durante l'aggiornamento dell'app:", error);
                    showToast(`Errore: ${error.message}`);
                }
            };


            // NEW FUNCTION: Add AI Suggestion
            window.addAiSuggestion = async () => {
                console.log('addAiSuggestion function called');
                if (!currentUser.uid) {
                    console.log('No user logged in, returning');
                    return;
                }

                const t = translations[currentLanguage];
                console.log('Creating AI suggestion modal');

                // Create modal for AI suggestion form
                const modalHTML = `
                <div id="add-ai-suggestion-modal" class="modal-overlay visible">
                    <div class="modal-content">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <h2>${t.addAiSuggestionTitle}</h2>
                        
                        <form id="ai-suggestion-form">
                            <div class="form-group">
                                <label for="app-name">${t.appNameLabel} *</label>
                                <input type="text" id="app-name" required placeholder="${t.appNamePlaceholder}">
                            </div>
                            
                            <div class="form-group">
                                <label for="app-description">${t.appDescriptionLabel} *</label>
                                <textarea id="app-description" required placeholder="${t.appDescriptionPlaceholder}" rows="4"></textarea>
                            </div>
                            
                            <div class="form-group">
                                <label for="app-website">${t.appWebsiteLabel} *</label>
                                <input type="url" id="app-website" required placeholder="${t.appWebsitePlaceholder}">
                            </div>
                            
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="app-category">${t.category} *</label>
                                    <select id="app-category" required>
                                        <option value="">${t.selectCategory}</option>
                                        <option value="Testo">Testo</option>
                                        <option value="Immagini">Immagini</option>
                                        <option value="Video">Video</option>
                                        <option value="Audio">Audio</option>
                                        <option value="Codice">Codice</option>
                                        <option value="Presentazioni">Presentazioni</option>
                                        <option value="Browser AI">Browser AI</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label for="app-country">${t.country} *</label>
                                    <select id="app-country" required>
                                        <option value="">${t.selectCountry}</option>
                                        <option value="USA">USA</option>
                                        <option value="Cina">Cina</option>
                                        <option value="Europe">Europe</option>
                                        
                                        <option value="Altro">Altro</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="form-actions">
                                <button type="button" class="button secondary" data-action="close-modal">${t.cancel}</button>
                                <button type="submit" class="button primary">${t.addAiSuggestionButton}</button>
                            </div>
                        </form>
                    </div>
                </div>`;

                el.modalContainer.innerHTML = modalHTML;

                // Add form submit handler
                document.getElementById('ai-suggestion-form').addEventListener('submit', async (e) => {
                    e.preventDefault();

                    const appName = document.getElementById('app-name').value.trim();
                    const appDescription = document.getElementById('app-description').value.trim();
                    const appWebsite = document.getElementById('app-website').value.trim();
                    const appCategory = document.getElementById('app-category').value;
                    const appCountry = document.getElementById('app-country').value;

                    if (!appName || !appDescription || !appWebsite || !appCategory || !appCountry) {
                        showToast(t.allFieldsRequired);
                        return;
                    }

                    // Validate URL format
                    try {
                        new URL(appWebsite);
                    } catch (e) {
                        showToast("Inserisci un URL valido (es. https://example.com)");
                        return;
                    }

                    try {
                        // Show loading state
                        const submitBtn = document.querySelector('#ai-suggestion-form button[type="submit"]');
                        const originalText = submitBtn.textContent;
                        submitBtn.textContent = 'Salvando...';
                        submitBtn.disabled = true;

                        const userDocRef = doc(db, "users", currentUser.uid);
                        const newSuggestion = {
                            id: `suggestion-${currentUser.uid}-${Date.now()}`,
                            appName: appName,
                            description: appDescription,
                            website: appWebsite,
                            category: appCategory,
                            country: appCountry,
                            timestamp: Date.now()
                        };

                        await updateDoc(userDocRef, {
                            aiSuggestions: arrayUnion(newSuggestion)
                        });

                        // Update local state
                        currentUser.aiSuggestions = [...(currentUser.aiSuggestions || []), newSuggestion];

                        showToast(t.aiSuggestionAdded);
                        closeModal();
                        renderView(); // Re-render to show the new suggestion
                    } catch (error) {
                        console.error("Error adding AI suggestion:", error);
                        showToast(`Error: ${error.message}`);
                    } finally {
                        // Reset button state
                        const submitBtn = document.querySelector('#ai-suggestion-form button[type="submit"]');
                        if (submitBtn) {
                            submitBtn.textContent = t.addAiSuggestionButton;
                            submitBtn.disabled = false;
                        }
                    }
                });
            };

            // NEW FUNCTION: Remove AI Suggestion
            const removeAiSuggestion = async (suggestionId) => {
                if (!currentUser.uid) return;

                const t = translations[currentLanguage];
                const userDocRef = doc(db, "users", currentUser.uid);

                try {
                    const updatedSuggestions = (currentUser.aiSuggestions || []).filter(s => s.id !== suggestionId);
                    await updateDoc(userDocRef, {
                        aiSuggestions: updatedSuggestions
                    });
                    currentUser.aiSuggestions = updatedSuggestions;
                    showToast(t.aiSuggestionRemoved);
                    renderView(); // Re-render to update the list
                } catch (error) {
                    console.error("Error removing AI suggestion:", error);
                    showToast(`Error: ${error.message}`);
                }
            };

            // NEW FUNCTION: Search Users (for button click)
            const searchUsers = async () => {
                if (!currentUser.uid) return;

                const searchInput = document.getElementById('user-search-input');
                const searchTerm = searchInput.value.trim();
                const t = translations[currentLanguage];

                if (!searchTerm) {
                    showToast("Inserisci un nickname da cercare.");
                    return;
                }

                await searchUsersByTerm(searchTerm);
            };

            // NEW FUNCTION: Create Test Users (for debugging)
            const createTestUsers = async () => {
                if (!currentUser.uid) return;

                try {
                    const testUsers = [
                        {
                            email: "mario.rossi@test.com",
                            nickname: "Mario",
                            aiSuggestions: [
                                {
                                    id: "test-1",
                                    appName: "ChatGPT",
                                    description: "Perfetto per la scrittura creativa e conversazioni",
                                    website: "https://chatgpt.com/",
                                    category: "Testo",
                                    country: "USA",
                                    timestamp: Date.now()
                                },
                                {
                                    id: "test-2",
                                    appName: "Midjourney",
                                    description: "Genera immagini artistiche di alta qualità",
                                    website: "https://www.midjourney.com/",
                                    category: "Immagini",
                                    country: "USA",
                                    timestamp: Date.now() - 86400000
                                }
                            ]
                        },
                        {
                            email: "lucia.bianchi@test.com",
                            nickname: "Lucia",
                            aiSuggestions: [
                                {
                                    id: "test-3",
                                    appName: "Claude",
                                    description: "Eccellente per la programmazione e sviluppo",
                                    website: "https://claude.ai/",
                                    category: "Codice",
                                    country: "USA",
                                    timestamp: Date.now()
                                },
                                {
                                    id: "test-4",
                                    appName: "Google AI Studio",
                                    description: "Per creare app e prototipi con Gemini",
                                    website: "https://aistudio.google.com/",
                                    category: "Codice",
                                    country: "USA",
                                    timestamp: Date.now() - 172800000
                                },
                                {
                                    id: "test-5",
                                    appName: "Perplexity",
                                    description: "La migliore AI per la ricerca web",
                                    website: "https://www.perplexity.ai/",
                                    category: "Testo",
                                    country: "USA",
                                    timestamp: Date.now() - 259200000
                                }
                            ]
                        },
                        {
                            email: "giovanni.verdi@test.com",
                            nickname: "Giovanni",
                            aiSuggestions: [
                                {
                                    id: "test-6",
                                    appName: "Leonardo AI",
                                    description: "Perfetto per asset di gioco e concept art",
                                    website: "https://leonardo.ai/",
                                    category: "Immagini",
                                    country: "USA",
                                    timestamp: Date.now()
                                }
                            ]
                        }
                    ];

                    for (const testUser of testUsers) {
                        const userDocRef = doc(db, "users", `test-${Date.now()}-${Math.random()}`);
                        await setDoc(userDocRef, testUser);
                    }

                    showToast("Utenti di test creati!");
                } catch (error) {
                    console.error("Error creating test users:", error);
                    showToast(`Error: ${error.message}`);
                }
            };

            // NEW FUNCTION: Search Users By Term (for real-time search)
            const searchUsersByTerm = async (searchTerm) => {
                if (!currentUser.uid) return;

                const t = translations[currentLanguage];
                const searchResults = document.getElementById('user-search-results');

                if (!searchResults) return;

                if (!searchTerm || searchTerm.trim().length < 2) {
                    searchResults.innerHTML = '';
                    return;
                }

                try {
                    // Search for users by nickname in Firestore
                    const usersRef = collection(db, "users");
                    const searchTermLower = searchTerm.toLowerCase();

                    // Get all users and filter client-side for better search
                    const querySnapshot = await getDocs(usersRef);

                    if (querySnapshot.empty) {
                        searchResults.innerHTML = `<div id="empty-state">${t.noUsersFound}</div>`;
                        return;
                    }

                    const users = [];
                    querySnapshot.forEach((doc) => {
                        const userData = doc.data();
                        if (doc.id !== currentUser.uid) { // Don't show current user
                            const nickname = userData.nickname || userData.email || '';
                            const email = userData.email || '';

                            // Search in both nickname and email
                            if (nickname.toLowerCase().includes(searchTermLower) ||
                                email.toLowerCase().includes(searchTermLower)) {
                                users.push({
                                    uid: doc.id,
                                    nickname: userData.nickname || userData.email?.split('@')[0] || 'Utente',
                                    email: userData.email || '',
                                    aiSuggestions: userData.aiSuggestions || []
                                });
                            }
                        }
                    });

                    // Limit results to first 10 users
                    const limitedUsers = users.slice(0, 10);

                    if (limitedUsers.length === 0) {
                        searchResults.innerHTML = `<div id="empty-state">${t.noUsersFound}</div>`;
                        return;
                    }

                    const usersHTML = limitedUsers.map(user => `
                    <div class="user-search-result" data-uid="${user.uid}">
                        <div class="user-info">
                            <div class="user-nickname">${user.nickname}</div>
                            <div class="user-email">${user.email}</div>
                            <div class="user-suggestions-count">${user.aiSuggestions.length} ${user.aiSuggestions.length === 1 ? t.suggestion : t.suggestions}</div>
                        </div>
                        <div class="user-actions">
                            <button class="view-suggestions-btn" data-action="view-user-suggestions" data-uid="${user.uid}" data-nickname="${user.nickname}">
                                ${t.viewSuggestions}
                            </button>
                            ${featureSettings.isChatEnabled ? `
                            <button class="chat-button" data-action="start-user-chat" data-uid="${user.uid}" data-nickname="${user.nickname}">
                                <svg xmlns="http://www.w3.org/2000/svg" height="16" viewBox="0 0 24 24" width="16" fill="currentColor">
                                    <path d="M0 0h24v24H0z" fill="none"/>
                                    <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                                </svg>
                                ${t.startChat}
                            </button>
                            ` : ''}
                                <svg xmlns="http://www.w3.org/2000/svg" height="16" viewBox="0 0 24 24" width="16" fill="currentColor">
                                    <path d="M0 0h24v24H0z" fill="none"/>
                                    <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                                </svg>
                                ${t.startChat}
                            </button>
                        </div>
                    </div>
                `).join('');

                    // Add message if there are more results
                    const moreResultsMessage = users.length > 10 ? `<div style="text-align: center; color: var(--spotify-text-secondary); font-size: 12px; margin-top: 8px;">Mostrando i primi 10 risultati di ${users.length}</div>` : '';

                    searchResults.innerHTML = usersHTML + moreResultsMessage;
                } catch (error) {
                    console.error("Error searching users:", error);
                    showToast(`Error: ${error.message}`);
                }
            };

            // NEW FUNCTION: View User Suggestions
            // NEW FUNCTION: Search Users for Chat
            const searchUsersForChat = async (searchTerm, currentUserId) => {
                const resultsContainer = document.getElementById('user-chat-search-results');
                if (!resultsContainer) return;

                const t = translations[currentLanguage];
                if (!searchTerm || searchTerm.trim().length < 2) {
                    resultsContainer.innerHTML = '';
                    return;
                }

                try {
                    const usersRef = collection(db, "users");
                    const searchTermLower = searchTerm.toLowerCase();
                    const querySnapshot = await getDocs(usersRef);

                    const users = [];
                    querySnapshot.forEach((doc) => {
                        const userData = doc.data();
                        if (doc.id !== currentUserId) { // Escludi l'utente corrente
                            const nickname = userData.nickname || '';
                            if (nickname.toLowerCase().includes(searchTermLower)) {
                                users.push({
                                    uid: doc.id,
                                    nickname: userData.nickname,
                                });
                            }
                        }
                    });

                    if (users.length === 0) {
                        resultsContainer.innerHTML = `<div id="empty-state">${t.noUsersFound}</div>`;
                        return;
                    }

                    // **MODIFICA APPLICATA QUI**
                    // Usiamo lo stesso stile della lista chat principale per un look pulito e coerente.
                    resultsContainer.innerHTML = users.slice(0, 10).map(user => `
                    <div class="simple-chat-search-item" onclick="window.handleReactChatStart('${user.uid}', '${user.nickname}')">
                        ${user.nickname}
                    </div>
                `).join('');

                } catch (error) {
                    console.error("Error searching users for chat:", error);
                    resultsContainer.innerHTML = `<div id="empty-state">Error searching users.</div>`;
                }
            };
            window.searchUsersForChat = searchUsersForChat;


            // NEW FUNCTION: View User Suggestions
            const viewUserSuggestions = async (userId, userNickname) => {
                if (!currentUser.uid) return;

                const t = translations[currentLanguage];

                try {
                    const userDocRef = doc(db, "users", userId);
                    const userDocSnap = await getDoc(userDocRef);

                    if (!userDocSnap.exists()) {
                        showToast("Utente non trovato.");
                        return;
                    }

                    const userData = userDocSnap.data();
                    const suggestions = userData.aiSuggestions || [];

                    const modalHTML = `
                    <div id="user-suggestions-modal" class="modal-overlay visible">
                        <div class="modal-content" style="max-width: 600px;">
                            <button class="modal-close-btn" data-action="close-modal">×</button>
                            <h2>${t.userSuggestionsTitle.replace('%s', userNickname)}</h2>
                            <div class="suggestions-list">
                                ${suggestions.length > 0 ? suggestions.map(suggestion => {
                        // Handle both old format (text) and new format (appName, description, etc.)
                        if (suggestion.text) {
                            // Old format - show as simple text
                            return `
                                            <div class="suggestion-item old-format">
                                                <div class="suggestion-text">${suggestion.text}</div>
                                                <div class="suggestion-date">${new Date(suggestion.timestamp).toLocaleDateString()}</div>
                                            </div>
                                        `;
                        } else {
                            // New format - show as app card
                            return `
                                            <div class="suggestion-item new-format">
                                                <div class="suggestion-header">
                                                    <h3 class="suggestion-app-name">${suggestion.appName}</h3>
                                                    <div class="suggestion-meta">
                                                        <span class="suggestion-category">${suggestion.category}</span>
                                                        <span class="suggestion-country">${suggestion.country}</span>
                                                    </div>
                                                </div>
                                                <div class="suggestion-description">${suggestion.description}</div>
                                                <div class="suggestion-actions">
                                                    <a href="${suggestion.website}" target="_blank" class="suggestion-website-btn">
                                                        🌐 ${t.visitWebsite}
                                                    </a>
                                                    <div class="suggestion-date">${new Date(suggestion.timestamp).toLocaleDateString()}</div>
                                                </div>
                                            </div>
                                        `;
                        }
                    }).join('') : `<div id="empty-state">${t.noSuggestions}</div>`}
                            </div>
                        </div>
                    </div>`;

                    el.modalContainer.innerHTML = modalHTML;
                } catch (error) {
                    console.error("Error viewing user suggestions:", error);
                    showToast(`Error: ${error.message}`);
                }
            };

            // NEW FUNCTION: Start User Chat
            const startUserChat = async (userId, userNickname) => {
                if (!currentUser.uid) return;

                try {
                    // Create or get existing chat
                    const chatId = await getOrCreateChat(currentUser.uid, userId);

                    // Navigate to user-chats view
                    currentView = 'user-chats';
                    renderView();

                    // If the user chat app is mounted, trigger the start chat function
                    if (window.startUserChat) {
                        window.startUserChat(userId, userNickname);
                    }
                } catch (error) {
                    console.error("Error starting user chat:", error);
                    showToast(`Error: ${error.message}`);
                }
            };


            // --- NUOVE FUNZIONI PER PROMPT OPTIMIZER E GALLERIA ---

            // Salva un prompt ottimizzato su Firebase
            const saveOptimizedPromptToFirebase = async (originalPrompt, optimizedPrompt) => {
                if (!currentUser.uid) {
                    showToast("Devi essere loggato per salvare i prompt.");
                    triggerAuthFlow();
                    return;
                }
                const savedPromptsRef = collection(db, "users", currentUser.uid, "savedPrompts");
                try {
                    await addDoc(savedPromptsRef, {
                        originalPrompt,
                        optimizedPrompt,
                        timestamp: serverTimestamp()
                    });
                    showToast("Prompt salvato nella galleria!");
                } catch (error) {
                    console.error("Errore nel salvataggio del prompt:", error);
                    showToast("Errore durante il salvataggio del prompt.");
                }
            };

            // Recupera i prompt salvati per l'utente corrente da Firebase
            const getSavedPromptsForUser = async (userId) => {
                const savedPromptsRef = collection(db, "users", userId, "savedPrompts");
                const q = query(savedPromptsRef, orderBy("timestamp", "desc"));
                const querySnapshot = await getDocs(q);
                const prompts = [];
                querySnapshot.forEach((doc) => {
                    prompts.push({ id: doc.id, ...doc.data() });
                });
                return prompts;
            };

            // Gestisce il click sul pulsante "Salva" dell'optimizer
            const handleSaveOptimizedPrompt = async () => {
                const originalPrompt = document.getElementById('optimizer-original-prompt').value.trim();
                const optimizedPrompt = document.getElementById('optimizer-optimized-prompt').value.trim();

                if (!optimizedPrompt) {
                    showToast("Ottimizza prima un prompt per poterlo salvare.");
                    return;
                }

                // Trova il pulsante di salvataggio per dare feedback visivo
                const saveButton = document.querySelector('[data-action="save-optimized-prompt"]');
                const originalButtonText = saveButton ? saveButton.textContent : '';
                
                if (saveButton) {
                    saveButton.disabled = true;
                    saveButton.style.opacity = '0.6';
                    saveButton.innerHTML = '✓ Salvato!';
                    saveButton.style.backgroundColor = 'var(--spotify-accent)';
                    saveButton.style.color = '#000';
                }

                await saveOptimizedPromptToFirebase(originalPrompt, optimizedPrompt);

                // Ripristina il pulsante dopo 2 secondi
                if (saveButton) {
                    setTimeout(() => {
                        saveButton.innerHTML = originalButtonText;
                        saveButton.disabled = false;
                        saveButton.style.opacity = '1';
                        saveButton.style.backgroundColor = '';
                        saveButton.style.color = '';
                    }, 2000);
                }
            };

            // Gestisce il click sul pulsante "Copia" dell'optimizer
            const handleCopyOptimizedPrompt = () => {
                const optimizedPrompt = document.getElementById('optimizer-optimized-prompt').value;
                if (optimizedPrompt) {
                    navigator.clipboard.writeText(optimizedPrompt)
                        .then(() => showToast("Prompt ottimizzato copiato!"))
                        .catch(err => showToast("Errore nella copia."));
                } else {
                    showToast("Nessun prompt da copiare.");
                }
            };

            // Apre il modale della galleria con i prompt salvati
            const openPromptGalleryModal = async () => {
                if (!currentUser.uid) {
                    triggerAuthFlow();
                    return;
                }

                // Mostra un caricamento
                el.modalContainer.innerHTML = `<div class="modal-overlay visible"><div class="modal-content" style="display:flex; justify-content:center; align-items:center;"><div class="chat-bubble loading"><span></span><span></span><span></span></div></div></div>`;

                let savedPrompts = await getSavedPromptsForUser(currentUser.uid);
                const t = translations[currentLanguage];

                // Funzione per formattare la data
                const formatDate = (timestamp) => {
                    if (!timestamp) return '';
                    const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
                    return date.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric' });
                };

                // Funzione per generare l'HTML dei prompt
                const generatePromptsHTML = (prompts) => {
                    if (prompts.length === 0) {
                        return `<div id="empty-state">Nessun prompt salvato.</div>`;
                    }
                    
                    return prompts.map((p, index) => `
                        <div class="prompt-gallery-item" data-prompt-id="${p.id}">
                            <div class="prompt-gallery-item-header" data-action="toggle-prompt">
                                <div class="prompt-gallery-item-title">
                                    <span class="prompt-gallery-item-number">#${index + 1}</span>
                                    <div class="prompt-gallery-item-info">
                                        <h3>${p.originalPrompt.substring(0, 50)}${p.originalPrompt.length > 50 ? '...' : ''}</h3>
                                        <span class="prompt-gallery-item-date">${formatDate(p.timestamp)}</span>
                                    </div>
                                </div>
                                <div class="prompt-gallery-item-toggle">
                                    <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20" fill="currentColor">
                                        <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
                                    </svg>
                                </div>
                            </div>
                            <div class="prompt-gallery-item-content">
                                <div class="prompt-gallery-header">
                                    <label>${t.originalPromptLabel}</label>
                                    <div class="prompt-gallery-actions">
                                        <button class="prompt-gallery-copy-btn" data-action="copy-gallery-prompt" data-target-id="original-${p.id}">${t.copyButton}</button>
                                    </div>
                                </div>
                                <div class="prompt-gallery-content" id="original-${p.id}">${p.originalPrompt}</div>
                                <hr class="prompt-gallery-divider">
                                <div class="prompt-gallery-header">
                                    <label>${t.optimizedPromptLabel}</label>
                                    <div class="prompt-gallery-actions">
                                        <button class="prompt-gallery-delete-btn" title="Elimina prompt" data-action="delete-saved-prompt" data-id="${p.id}">
                                            <svg xmlns="http://www.w3.org/2000/svg" height="16" viewBox="0 0 24 24" width="16" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                                        </button>
                                    </div>
                                </div>
                                <div class="prompt-gallery-content optimized" id="optimized-${p.id}">${p.optimizedPrompt}</div>
                            </div>
                        </div>
                    `).join('');
                };

                const modalHTML = `
                    <div id="prompt-gallery-modal" class="modal-overlay visible">
                        <div class="modal-content">
                            <button class="modal-close-btn" data-action="close-modal">×</button>
                            <div class="gallery-header">
                                <h2>Galleria Prompt</h2>
                                <div class="gallery-search-bar">
                                    <input type="text" class="gallery-search-input" placeholder="Cerca nei prompt..." id="gallery-search-input">
                                    <select class="gallery-sort-select" id="gallery-sort-select">
                                        <option value="newest">Più recenti</option>
                                        <option value="oldest">Più vecchi</option>
                                    </select>
                                </div>
                            </div>
                            <div class="gallery-list" id="gallery-list">${generatePromptsHTML(savedPrompts)}</div>
                        </div>
                    </div>
                `;
                
                el.modalContainer.innerHTML = modalHTML;

                // Aggiungi event listener per la ricerca
                const searchInput = document.getElementById('gallery-search-input');
                const sortSelect = document.getElementById('gallery-sort-select');
                const galleryList = document.getElementById('gallery-list');

                const filterAndSortPrompts = () => {
                    const searchTerm = searchInput.value.toLowerCase();
                    const sortOrder = sortSelect.value;

                    let filtered = savedPrompts.filter(p => 
                        p.originalPrompt.toLowerCase().includes(searchTerm) || 
                        p.optimizedPrompt.toLowerCase().includes(searchTerm)
                    );

                    if (sortOrder === 'newest') {
                        filtered.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));
                    } else {
                        filtered.sort((a, b) => (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0));
                    }

                    galleryList.innerHTML = generatePromptsHTML(filtered);
                };

                searchInput.addEventListener('input', filterAndSortPrompts);
                sortSelect.addEventListener('change', filterAndSortPrompts);

                // Ordina inizialmente per più recenti
                filterAndSortPrompts();
            };

            // --- FUNZIONI CORRETTE PER COPIA ED ELIMINAZIONE ---

            // Gestisce la copia del testo dalla galleria in modo più robusto
            const handleCopyFromGallery = (targetId) => {
                const element = document.getElementById(targetId);
                if (!element) {
                    showToast("Errore: Impossibile trovare il testo.");
                    return;
                }
                const textToCopy = element.innerText || element.textContent; // .innerText è più affidabile

                // Fallback per browser che non supportano navigator.clipboard o contesti non sicuri
                const textarea = document.createElement('textarea');
                textarea.value = textToCopy;
                textarea.style.position = 'absolute';
                textarea.style.left = '-9999px'; // Nascondi l'elemento
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showToast("Copiato!");
                } catch (err) {
                    console.error('Fallback di copia fallito:', err);
                    showToast("Errore durante la copia.");
                } finally {
                    document.body.removeChild(textarea);
                }
            };

            // Gestisce l'eliminazione di un prompt salvato da Firebase
            // Apre il modale di conferma per l'eliminazione di un prompt
            const handleDeleteSavedPrompt = (promptId) => {
                if (!promptId) return;
                const t = translations[currentLanguage];

                const modalHTML = `
    <div id="confirm-delete-prompt-modal" class="modal-overlay visible">
        <div class="modal-content" style="text-align: left; max-width: 400px;">
            <h2 style="font-size: 20px; margin-bottom: 16px;">${t.confirmDeletePromptTitle}</h2>
            <p style="color: var(--spotify-text-secondary); line-height: 1.5; margin-bottom: 24px;">${t.confirmDeletePromptText}</p>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="pill-btn" data-action="close-modal">${t.cancel}</button>
                <button class="button" data-action="execute-delete-saved-prompt" data-id="${promptId}" style="background-color: #ff6b6b; color: white;">${t.deleteButton}</button>
            </div>
        </div>
    </div>`;
                el.modalContainer.innerHTML = modalHTML;
            };

            // Esegue l'eliminazione effettiva di un prompt dopo la conferma
            const executeDeleteSavedPrompt = async (promptId) => {
                if (!currentUser.uid || !promptId) return;

                const promptRef = doc(db, "users", currentUser.uid, "savedPrompts", promptId);
                try {
                    await deleteDoc(promptRef);
                    showToast("Prompt eliminato con successo!");
                    await openPromptGalleryModal(); // Ricarica la galleria per mostrare le modifiche
                } catch (error) {
                    console.error("Errore nell'eliminazione del prompt:", error);
                    showToast("Impossibile eliminare il prompt.");
                }
            };


            // --- FUNZIONE PER OTTIMIZZARE I PROMPT ---
            const handlePromptOptimization = async () => {
                const originalPromptTextarea = document.getElementById('optimizer-original-prompt');
                const optimizedPromptTextarea = document.getElementById('optimizer-optimized-prompt');
                const optimizeBtn = document.getElementById('optimizer-submit-btn');

                const originalPrompt = originalPromptTextarea.value.trim();
                if (!originalPrompt) {
                    showToast("Per favore, inserisci un prompt da ottimizzare.");
                    return;
                }

                optimizeBtn.disabled = true;
                optimizeBtn.textContent = 'Optimizing...';
                optimizedPromptTextarea.value = ''; // Pulisce l'output precedente

                const lang = currentLanguage;
                const instructions = {
                    it: `Sei un esperto di ingegneria dei prompt. Il tuo compito è riscrivere il prompt dell'utente per renderlo più efficace per un modello linguistico avanzato come GPT-5.
                Obiettivi:
                1.  **Chiarezza e Specificità:** Rendi il prompt inequivocabile. Aggiungi dettagli mancanti se necessario per evitare ambiguità.
                2.  **Contesto:** Fornisci un contesto adeguato. Specifica il ruolo che l'AI deve assumere (es. "Agisci come un esperto di marketing...").
                3.  **Formato di Output:** Definisci chiaramente il formato di output desiderato (es. "rispondi in formato JSON", "crea una tabella markdown", "usa un elenco puntato").
                4.  **Vincoli:** Aggiungi vincoli per guidare la risposta (es. "la risposta non deve superare le 200 parole", "usa un tono formale").
                5.  **Migliori Pratiche:** Applica tecniche come il "Chain of Thought" o fornisci esempi "few-shot" se appropriato.
                IMPORTANTE: Mantieni l'intento originale del prompt dell'utente, ma migliorane la struttura e la formulazione per massimizzare la qualità della risposta dell'AI. Rispondi SOLO con il prompt ottimizzato, senza alcun testo introduttivo o di chiusura.`,
                    en: `You are an expert prompt engineer. Your task is to rewrite the user's prompt to make it more effective for an advanced language model like GPT-5.
                Objectives:
                1.  **Clarity and Specificity:** Make the prompt unambiguous. Add missing details if necessary to avoid ambiguity.
                2.  **Context:** Provide adequate context. Specify the role the AI should assume (e.g., "Act as a marketing expert...").
                3.  **Output Format:** Clearly define the desired output format (e.g., "respond in JSON format," "create a markdown table," "use a bulleted list").
                4.  **Constraints:** Add constraints to guide the response (e.g., "the response must not exceed 200 words," "use a formal tone").
                5.  **Best Practices:** Apply techniques like "Chain of Thought" or provide "few-shot" examples if appropriate.
                IMPORTANT: Maintain the original intent of the user's prompt, but improve its structure and wording to maximize the quality of the AI's response. Respond ONLY with the optimized prompt, without any introductory or closing text.`
                };

                try {
                    // Utilizziamo le stesse utility del chatbot principale
                    const optimizerAi = new window.GoogleGenAI({ apiKey: "AIzaSyCncR2My7lkE73UwdndvIqkasIw0iasdP0" });
                    const optimizerChat = optimizerAi.chats.create({
                        model: 'gemini-2.0-flash',
                        config: { systemInstruction: instructions[lang] }
                    });

                    const result = await optimizerChat.sendMessageStream({ message: originalPrompt });

                    for await (const chunk of result) {
                        optimizedPromptTextarea.value += chunk.text;
                    }

                } catch (error) {
                    console.error("Optimization Error:", error);
                    optimizedPromptTextarea.value = "An error occurred during optimization. Please try again.";
                    showToast("Optimization failed.");
                } finally {
                    optimizeBtn.disabled = false;
                    optimizeBtn.textContent = translations[lang].optimizeButton;
                }
            };

            const openVideoCatalogModal = () => {
                const t = translations[currentLanguage];
                const isAdmin = currentUser.role === 'admin';

                const adminAddButton = isAdmin
                    ? `<button class="admin-add-video-btn" data-action="open-add-video-modal" title="${t.addVideoTitle}">+</button>`
                    : '';

                const videosHTML = youtubeVideosData.map((video, index) => {
                    let videoId = '';
                    try {
                        const url = new URL(video.youtubeUrl);
                        videoId = url.hostname === 'youtu.be' ? url.pathname.slice(1) : url.searchParams.get('v');
                    } catch (e) { }

                    const thumbnailUrl = videoId ? `https://img.youtube.com/vi/${videoId}/mqdefault.jpg` : 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                    const videoDate = video.createdAt ? new Date(video.createdAt.seconds * 1000).toLocaleDateString(currentLanguage === 'it' ? 'it-IT' : 'en-US') : '';

                    const adminActionsHTML = isAdmin ? `
                        <button class="video-admin-btn" data-action="open-edit-video-modal" data-id="${video.id}" title="${t.editVideo}">${smallPencilIcon}</button>
                        <button class="video-admin-btn delete" data-action="delete-video" data-id="${video.id}" title="${t.deleteVideo}">${trashIcon}</button>
                    ` : '';

                    return `
                        <div class="video-card" data-id="${video.id}" ${isAdmin ? 'draggable="true"' : ''}>
                            <img src="${thumbnailUrl}" class="video-thumbnail" alt="Thumbnail">
                            <div class="video-info">
                                <h4>${index + 1}. ${video.title}</h4>
                                <p>${video.description[currentLanguage] || video.description['en']}</p>
                                <div class="video-actions">
                                    <button class="button" data-action="watch-youtube-video" data-url="${video.youtubeUrl}">${t.watchVideo}</button>
                                    ${adminActionsHTML}
                                </div>
                                ${videoDate ? `<div class="video-date">${videoDate}</div>` : ''}
                            </div>
                        </div>
                    `;
                }).join('');

                const saveOrderButton = isAdmin ? `<button class="button" id="save-video-order-btn" data-action="save-video-order">${t.saveOrder}</button>` : '';

                const modalHTML = `
                <div id="video-catalog-modal" class="modal-overlay visible">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>${t.videoCatalogTitle}</h2>
                            <div class="modal-header-buttons">
                                ${adminAddButton}
                                <button class="modal-close-btn" data-action="close-modal" style="position: static;">×</button>
                            </div>
                        </div>
                        <div class="video-list-container">
                            ${videosHTML.length > 0 ? videosHTML : `<div id="empty-state">Nessun video disponibile.</div>`}
                        </div>
                        ${saveOrderButton}
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;

                if (isAdmin) {
                    initializeVideoDragAndDrop();
                }
            };

            const initializeVideoDragAndDrop = () => {
                const container = document.querySelector('#video-catalog-modal .video-list-container');
                if (!container) return;

                let draggedItem = null;

                container.addEventListener('dragstart', e => {
                    if (e.target.classList.contains('video-card')) {
                        draggedItem = e.target;
                        setTimeout(() => draggedItem.classList.add('dragging'), 0);
                        document.getElementById('save-video-order-btn').style.display = 'block';
                    }
                });

                container.addEventListener('dragend', () => {
                    if (draggedItem) {
                        draggedItem.classList.remove('dragging');
                        draggedItem = null;
                    }
                });

                container.addEventListener('dragover', e => {
                    e.preventDefault();
                    const afterElement = getDragAfterElement(container, e.clientY);
                    const dragging = container.querySelector('.dragging');
                    if (dragging) {
                        if (afterElement == null) {
                            container.appendChild(dragging);
                        } else {
                            container.insertBefore(dragging, afterElement);
                        }
                    }
                });

                function getDragAfterElement(container, y) {
                    const draggableElements = [...container.querySelectorAll('.video-card:not(.dragging)')];
                    return draggableElements.reduce((closest, child) => {
                        const box = child.getBoundingClientRect();
                        const offset = y - box.top - box.height / 2;
                        if (offset < 0 && offset > closest.offset) {
                            return { offset: offset, element: child };
                        } else {
                            return closest;
                        }
                    }, { offset: Number.NEGATIVE_INFINITY }).element;
                }
            };

            const openAddVideoModal = () => {
                if (currentUser.role !== 'admin') return;
                const t = translations[currentLanguage];

                const modalHTML = `
            <div id="add-video-modal" class="modal-overlay visible">
                <div class="modal-content add-ai-modal" style="text-align: left;">
                    <button class="modal-close-btn" data-action="close-modal">×</button>
                    <h2>${t.addVideoTitle}</h2>
                    <div class="add-ai-form">
                        <div class="input-group">
                            <label for="video-title">${t.videoTitleLabel}</label>
                            <input type="text" id="video-title" placeholder="${t.videoTitlePlaceholder}">
                        </div>
                        <div class="input-group">
                            <label for="video-desc-it">${t.videoDescItLabel}</label>
                            <textarea id="video-desc-it" placeholder="${t.videoDescPlaceholder}"></textarea>
                        </div>
                        <div class="input-group">
                            <label for="video-desc-en">${t.videoDescEnLabel}</label>
                            <textarea id="video-desc-en" placeholder="${t.videoDescPlaceholder}"></textarea>
                        </div>
                        <div class="input-group">
                            <label for="video-link">${t.videoLinkLabel}</label>
                            <input type="url" id="video-link" placeholder="${t.videoLinkPlaceholder}">
                        </div>
                        <button class="button" data-action="submit-video">${t.addVideoButton}</button>
                    </div>
                </div>
            </div>`;
                el.modalContainer.innerHTML = modalHTML;
            };

            const handleAddVideo = async () => {
                if (currentUser.role !== 'admin') return;
                const t = translations[currentLanguage];

                const newVideoData = {
                    title: document.getElementById('video-title').value.trim(),
                    description: {
                        it: document.getElementById('video-desc-it').value.trim(),
                        en: document.getElementById('video-desc-en').value.trim(),
                    },
                    youtubeUrl: document.getElementById('video-link').value.trim(),
                    createdAt: serverTimestamp(),
                    order: Date.now() // Aggiunge un valore di ordine per posizionarlo alla fine
                };

                if (!newVideoData.title || !newVideoData.youtubeUrl || !newVideoData.description.it || !newVideoData.description.en) {
                    showToast("Tutti i campi sono obbligatori.");
                    return;
                }

                // Validazione semplice dell'URL di YouTube
                if (!newVideoData.youtubeUrl.includes('youtube.com') && !newVideoData.youtubeUrl.includes('youtu.be')) {
                    showToast(t.invalidYoutubeUrl);
                    return;
                }

                try {
                    const videosCollectionRef = collection(db, "videos");
                    await addDoc(videosCollectionRef, newVideoData);
                    showToast(t.videoAddedSuccess);

                    // Ricarica i video e riapri il catalogo per mostrare l'aggiornamento
                    youtubeVideosData = await fetchVideosFromFirestore();
                    openVideoCatalogModal();

                } catch (error) {
                    console.error("Errore nell'aggiunta del video:", error);
                    showToast(`Errore: ${error.message}`);
                }
            };


            const openEditVideoModal = (videoId) => {
                if (currentUser.role !== 'admin') return;
                const t = translations[currentLanguage];
                const videoToEdit = youtubeVideosData.find(v => v.id === videoId);
                if (!videoToEdit) return;

                const modalHTML = `
                <div id="edit-video-modal" class="modal-overlay visible">
                    <div class="modal-content add-ai-modal" style="text-align: left;">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <h2>${t.editVideo}</h2>
                        <div class="add-ai-form">
                            <div class="input-group">
                                <label for="edit-video-title">${t.videoTitleLabel}</label>
                                <input type="text" id="edit-video-title" value="${videoToEdit.title}">
                            </div>
                            <div class="input-group">
                                <label for="edit-video-desc-it">${t.videoDescItLabel}</label>
                                <textarea id="edit-video-desc-it">${videoToEdit.description.it}</textarea>
                            </div>
                            <div class="input-group">
                                <label for="edit-video-desc-en">${t.videoDescEnLabel}</label>
                                <textarea id="edit-video-desc-en">${videoToEdit.description.en}</textarea>
                            </div>
                            <div class="input-group">
                                <label for="edit-video-link">${t.videoLinkLabel}</label>
                                <input type="url" id="edit-video-link" value="${videoToEdit.youtubeUrl}">
                            </div>
                            <button class="button" data-action="submit-video-edit" data-id="${videoId}">${t.saveChanges}</button>
                        </div>
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;
            };

            const handleUpdateVideo = async (videoId) => {
                if (currentUser.role !== 'admin') return;
                const t = translations[currentLanguage];

                const updatedData = {
                    title: document.getElementById('edit-video-title').value.trim(),
                    description: {
                        it: document.getElementById('edit-video-desc-it').value.trim(),
                        en: document.getElementById('edit-video-desc-en').value.trim(),
                    },
                    youtubeUrl: document.getElementById('edit-video-link').value.trim(),
                };

                if (!updatedData.title || !updatedData.youtubeUrl) {
                    showToast("Titolo e Link sono obbligatori."); return;
                }

                try {
                    const videoDocRef = doc(db, "videos", videoId);
                    await updateDoc(videoDocRef, updatedData);
                    showToast(t.videoUpdatedSuccess);

                    youtubeVideosData = await fetchVideosFromFirestore();
                    openVideoCatalogModal();
                } catch (error) {
                    console.error("Errore nell'aggiornamento del video:", error);
                    showToast(`Errore: ${error.message}`);
                }
            };

            const handleDeleteVideo = async (videoId) => {
                if (currentUser.role !== 'admin') return;
                const t = translations[currentLanguage];

                if (confirm(t.confirmDeleteVideo)) {
                    try {
                        await deleteDoc(doc(db, "videos", videoId));
                        showToast(t.videoDeletedSuccess);

                        youtubeVideosData = await fetchVideosFromFirestore();
                        openVideoCatalogModal();
                    } catch (error) {
                        console.error("Errore nell'eliminazione del video:", error);
                        showToast(`Errore: ${error.message}`);
                    }
                }
            };

            const handleSaveVideoOrder = async () => {
                const t = translations[currentLanguage];
                const videoList = document.querySelector('#video-catalog-modal .video-list-container');
                if (!videoList) return;

                const videoCards = videoList.querySelectorAll('.video-card');
                const batch = writeBatch(db);

                videoCards.forEach((card, index) => {
                    const videoId = card.dataset.id;
                    const videoRef = doc(db, "videos", videoId);
                    batch.update(videoRef, { order: index });
                });

                try {
                    await batch.commit();
                    showToast(t.orderSavedSuccess);
                    document.getElementById('save-video-order-btn').style.display = 'none';
                    youtubeVideosData = await fetchVideosFromFirestore(); // Ricarica per consistenza
                } catch (error) {
                    console.error("Errore nel salvataggio dell'ordine:", error);
                    showToast(`Errore: ${error.message}`);
                }
            };


            // --- INITIALIZATION LOGIC ---

            const initializeAppForGuest = () => {
                // Initialize currentUser with default empty state
                currentUser = { uid: null, name: 'Guest', nickname: 'Guest', favorites: [], isPrivileged: false, userTools: [], userFeaturedTools: [], userFeaturedReplacements: {}, aiSuggestions: [] };
                loadConversations();
                unmountReactApp();
                el.appContainer.style.display = 'flex';
                el.authOverlay.style.display = 'none';
                el.authOverlay.innerHTML = ''; // Ensure auth overlay is empty
                renderView();
            };

            const initializeAppWithUser = async (user) => {
                const userDocRef = doc(db, "users", user.uid);
                try {
                    const userDocSnap = await getDoc(userDocRef);
                    if (userDocSnap.exists()) {
                        // Fetch all user data from Firestore
                        const data = userDocSnap.data();
                        currentUser = {
                            uid: user.uid,
                            name: user.email, // Use email as name for now
                            nickname: data.nickname || user.email.split('@')[0], // Use nickname or email prefix as fallback
                            favorites: data.favorites || [],
                            userTools: data.userTools || [],
                            userFeaturedTools: data.userFeaturedTools || [],
                            userFeaturedReplacements: data.userFeaturedReplacements || {}, // Fetch replacements
                            isPrivileged: data.isPrivileged || false, // Load privileged status from Firestore
                            aiSuggestions: data.aiSuggestions || [], // Load AI suggestions
                            role: data.role || 'user' // NUOVO: Carica il ruolo dell'utente, con 'user' come default
                        };
                    } else {
                        // Create user doc if it doesn't exist with initial empty arrays and non-privileged status
                        const initialUserData = {
                            email: user.email,
                            nickname: user.email.split('@')[0], // Use email prefix as default nickname
                            favorites: [],
                            userTools: [],
                            userFeaturedTools: [],
                            userFeaturedReplacements: {}, // Initialize replacements
                            isPrivileged: false, // Default to non-privileged
                            aiSuggestions: [] // Initialize AI suggestions
                        };
                        await setDoc(userDocRef, initialUserData).catch(e => console.error("Error creating user doc:", e));
                        currentUser = { uid: user.uid, name: user.email, ...initialUserData };
                    }
                } catch (error) {
                    console.error("Error fetching user data:", error);
                    // Fallback to minimal user data if Firestore fails
                    currentUser = { uid: user.uid, name: user.email, favorites: [], userTools: [], userFeaturedTools: [], userFeaturedReplacements: {}, isPrivileged: false };
                    showToast("Could not load user data."); // Inform user
                }

                loadConversations();
                el.authOverlay.classList.add('hidden');
                el.authOverlay.addEventListener('transitionend', () => {
                    el.authOverlay.style.display = 'none';
                    el.authOverlay.innerHTML = ''; // Clear content after transition
                }, { once: true });
                el.appContainer.style.display = 'flex';
                renderView(); // Render the app view
            };

            // Apply theme on initial load
            document.body.classList.toggle('light-mode', currentTheme === 'light');

            // NUOVA FUNZIONE PER APRIRE IL MODALE DI CONFERMA
            const openConfirmDeleteAllModal = () => {
                const t = translations[currentLanguage];
                const modalHTML = `
                <div id="confirm-delete-modal" class="modal-overlay visible">
                    <div class="modal-content" style="text-align: left; max-width: 400px;">
                        <h2 style="font-size: 20px; margin-bottom: 16px;">${t.deleteAll}</h2>
                        <p style="color: var(--spotify-text-secondary); line-height: 1.5; margin-bottom: 24px;">${t.confirmDeleteAll}</p>
                        <div style="display: flex; gap: 12px; justify-content: flex-end;">
                            <button class="pill-btn" data-action="close-modal">${t.cancel || 'Annulla'}</button>
                            <button class="button" data-action="confirm-delete-all-chats" style="background-color: #ff4444; color: white;">${t.deleteAll}</button>
                        </div>
                    </div>
                </div>
            `;
                el.modalContainer.innerHTML = modalHTML;
            };

            // NUOVA FUNZIONE: Apre il modale per aggiungere uno strumento globale (solo admin) - STILE MIGLIORATO
            const openAddGlobalToolModal = () => {
                if (currentUser.role !== 'admin') return;
                const t = translations[currentLanguage];

                const categoryOptions = categories.map(cat => `<option value="${cat.id}">${cat.name[currentLanguage]}</option>`).join('');

                const modalHTML = `
                <div id="add-global-tool-modal" class="modal-overlay visible">
                    <div class="modal-content add-ai-modal" style="text-align: left;">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <h2>${t.addAIToDatabase}</h2>
                        
                        <div class="add-ai-form">
                            <div class="input-group">
                                <label for="global-tool-name">${t.aiNameLabel}</label>
                                <input type="text" id="global-tool-name" placeholder="${t.aiNamePlaceholder}">
                            </div>

                            <div class="input-group">
                                <label for="global-tool-desc-it">${t.descriptionITLabel}</label>
                                <textarea id="global-tool-desc-it" placeholder="${t.descriptionITPlaceholder}"></textarea>
                            </div>
                            
                            <div class="input-group">
                                <label for="global-tool-desc-en">${t.descriptionENLabel}</label>
                                <textarea id="global-tool-desc-en" placeholder="${t.descriptionENPlaceholder}"></textarea>
                            </div>

                            <div class="input-group">
                                <label for="global-tool-website">${t.websiteLinkLabel}</label>
                                <input type="url" id="global-tool-website" placeholder="${t.websiteLinkPlaceholder}">
                            </div>
                            
                            <div class="input-group">
                                <label for="global-tool-logo">${t.logoURLLabel}</label>
                                <input type="url" id="global-tool-logo" placeholder="${t.logoURLPlaceholder}">
                            </div>

                            <div class="input-group">
                                <label for="global-tool-category">${t.categoryLabel}</label>
                                <select id="global-tool-category">${categoryOptions}</select>
                            </div>
                            
                            <div class="input-group">
                                <label for="global-tool-country">${t.countryLabel}</label>
                                <input type="text" id="global-tool-country" placeholder="${t.countryPlaceholder}">
                            </div>

                            <button class="button" data-action="submit-global-tool">${t.saveToDatabase}</button>
                        </div>
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;
            };

            // NUOVA FUNZIONE: Apre il modale per MODIFICARE uno strumento globale (solo admin)
            const openEditGlobalToolModal = (toolId) => {
                if (currentUser.role !== 'admin') return;

                const toolToEdit = aiToolsData.find(t => t.id === toolId);
                if (!toolToEdit) {
                    showToast("Strumento non trovato.");
                    return;
                }

                const t = translations[currentLanguage];
                const categoryOptions = categories.map(cat => `<option value="${cat.id}" ${cat.id === toolToEdit.category ? 'selected' : ''}>${cat.name[currentLanguage]}</option>`).join('');
                const modalHTML = `
                <div id="edit-global-tool-modal" class="modal-overlay visible">
                    <div class="modal-content add-ai-modal" style="text-align: left;">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <h2>${t.editAIInDatabase}</h2>
                        
                        <div class="add-ai-form">
                            <div class="input-group">
                                <label>${t.documentIdLabel}</label>
                                <input type="text" value="${toolToEdit.id}" disabled style="background-color: var(--spotify-bg);">
                            </div>

                            <div class="input-group">
                                <label for="edit-global-tool-name">${t.aiNameLabel}</label>
                                <input type="text" id="edit-global-tool-name" value="${toolToEdit.name || ''}">
                            </div>

                            <div class="input-group">
                                <label for="edit-global-tool-desc-it">${t.descriptionITLabel}</label>
                                <textarea id="edit-global-tool-desc-it">${toolToEdit.description.it || ''}</textarea>
                            </div>
                            
                            <div class="input-group">
                                <label for="edit-global-tool-desc-en">${t.descriptionENLabel}</label>
                                <textarea id="edit-global-tool-desc-en">${toolToEdit.description.en || ''}</textarea>
                            </div>

                            <div class="input-group">
                                <label for="edit-global-tool-website">${t.websiteLinkLabel}</label>
                                <input type="url" id="edit-global-tool-website" value="${toolToEdit.website || ''}">
                            </div>
                            
                            <div class="input-group">
                                <label for="edit-global-tool-logo">${t.logoURLLabel}</label>
                                <input type="url" id="edit-global-tool-logo" value="${toolToEdit.logoUrl || ''}">
                            </div>

                            <div class="input-group">
                                <label for="edit-global-tool-category">${t.categoryLabel}</label>
                                <select id="edit-global-tool-category">${categoryOptions}</select>
                            </div>
                            
                            <div class="input-group">
                                <label for="edit-global-tool-country">${t.countryLabel}</label>
                                <input type="text" id="edit-global-tool-country" value="${toolToEdit.country || ''}">
                            </div>

                            <button class="button" data-action="submit-edit-global-tool" data-id="${toolToEdit.id}">${t.saveChanges}</button>
                        </div>
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;
            };

            // --- NUOVA LOGICA DI GESTIONE CLASSIFICHE (CRUD COMPLETO) ---

            // Apre il modale principale che elenca tutte le classifiche
            const openManageRankingsModal = () => {
                if (currentUser.role !== 'admin') return;
                const t = translations[currentLanguage];

                const rankingsListHTML = aiRankingsData.map(ranking => `
                    <div class="sent-review-item">
                        <div class="sent-review-header">
                            <div class="sent-review-tool-info">
                                <div class="sent-review-tool-name">${ranking.title_it}</div>
                            </div>
                            <div class="sent-review-actions">
                                <button class="ranking-action-btn edit" data-action="open-edit-ranking-modal" data-id="${ranking.id}" title="${t.editRanking}">${smallPencilIcon}</button>
                                <button class="ranking-action-btn delete" data-action="delete-ranking" data-id="${ranking.id}" title="${t.deleteButton}">${trashIcon}</button>
                            </div>
                        </div>
                    </div>
                `).join('');

                const modalHTML = `
                <div id="manage-rankings-modal" class="modal-overlay visible">
                    <div class="modal-content add-ai-modal" style="text-align: left;">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <h2>${t.manageRankings}</h2>
                        <div style="margin-top: 24px;">${rankingsListHTML}</div>
                        <button class="button" data-action="open-edit-ranking-modal" style="width: 100%; margin-top: 24px;">${t.createRanking}</button>
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;
            };

            // Apre il modale per creare o modificare una singola classifica
            const openEditRankingModal = (rankingId = null) => {
                const t = translations[currentLanguage];
                const isEditing = rankingId !== null;
                const ranking = isEditing ? aiRankingsData.find(r => r.id === rankingId) : {};

                let selectedTools = ranking.toolIds ? ranking.toolIds.map(id => aiToolsData.find(t => t.id === id)).filter(Boolean) : [];

                const renderSelectedTools = () => selectedTools.map(tool => `
                    <div class="tool-list-item" data-id="${tool.id}" draggable="true">
                        <img src="${tool.logoUrl}" alt="${tool.name}">
                        <div class="info"><div class="tool-name">${tool.name}</div></div>
                        <button class="sent-review-delete-btn" data-action="ranking-remove-tool" data-id="${tool.id}">×</button>
                    </div>
                `).join('');

                const modalHTML = `
                <div id="edit-ranking-modal" class="modal-overlay visible">
                    <div class="modal-content add-ai-modal" style="text-align: left; max-width: 600px;">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <h2>${isEditing ? t.editRanking : t.createRanking}</h2>
                        <div class="add-ai-form">
                            <div class="input-group"><label for="ranking-title-it">${t.rankingTitleITLabel}</label><input type="text" id="ranking-title-it" value="${ranking.title_it || ''}"></div>
                            <div class="input-group"><label for="ranking-title-en">${t.rankingTitleENLabel}</label><input type="text" id="ranking-title-en" value="${ranking.title_en || ''}"></div>
                            <div class="input-group"><label for="ranking-category">${t.rankingCategoryLabel}</label><input type="text" id="ranking-category" value="${ranking.category || ''}"></div>
                            
                            
                            <div class="input-group">
                                <label>${t.rankingToolsLabel}</label>
                                <div id="ranking-selected-tools" class="list-container" style="margin-bottom: 16px;">${renderSelectedTools()}</div>
                                <input type="text" id="ranking-tool-search" placeholder="${t.searchAIs}">
                                <div id="ranking-tool-search-results" class="list-container" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
                            </div>
                            <button class="button" data-action="save-ranking" data-id="${rankingId || ''}">${t.saveChanges}</button>
                        </div>
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;

                const searchInput = document.getElementById('ranking-tool-search');
                const resultsContainer = document.getElementById('ranking-tool-search-results');
                const selectedContainer = document.getElementById('ranking-selected-tools');

                const updateUI = () => {
                    selectedContainer.innerHTML = renderSelectedTools();
                };

                searchInput.addEventListener('input', () => {
                    const searchTerm = searchInput.value.toLowerCase();
                    if (searchTerm.length < 2) {
                        resultsContainer.innerHTML = '';
                        return;
                    }
                    const filteredTools = aiToolsData.filter(tool => tool.name.toLowerCase().includes(searchTerm) && !selectedTools.find(st => st.id === tool.id));
                    resultsContainer.innerHTML = filteredTools.slice(0, 10).map(tool => `
                        <div class="tool-list-item" data-action="ranking-add-tool" data-id="${tool.id}" style="cursor: pointer;">
                            <img src="${tool.logoUrl}" alt="${tool.name}"><div class="info"><div class="tool-name">${tool.name}</div></div>
                        </div>
                    `).join('');
                });

                // --- START: Drag and Drop Logic for Ranking Editor ---
                const draggableItemsContainer = selectedContainer;
                let draggedItem = null;

                draggableItemsContainer.addEventListener('dragstart', e => {
                    draggedItem = e.target;
                    // Use a timeout to allow the browser to create a drag image before adding the class
                    setTimeout(() => {
                        if (draggedItem) draggedItem.classList.add('dragging');
                    }, 0);
                });

                draggableItemsContainer.addEventListener('dragend', e => {
                    if (draggedItem) {
                        draggedItem.classList.remove('dragging');
                        draggedItem = null;
                    }
                });

                draggableItemsContainer.addEventListener('dragover', e => {
                    e.preventDefault(); // Necessary to allow drop
                    const afterElement = getDragAfterElement(draggableItemsContainer, e.clientY);
                    const currentlyDragged = document.querySelector('.dragging');
                    if (currentlyDragged) {
                        if (afterElement == null) {
                            draggableItemsContainer.appendChild(currentlyDragged);
                        } else {
                            draggableItemsContainer.insertBefore(currentlyDragged, afterElement);
                        }
                    }
                });

                function getDragAfterElement(container, y) {
                    const draggableElements = [...container.querySelectorAll('.tool-list-item:not(.dragging)')];

                    return draggableElements.reduce((closest, child) => {
                        const box = child.getBoundingClientRect();
                        const offset = y - box.top - box.height / 2;
                        if (offset < 0 && offset > closest.offset) {
                            return { offset: offset, element: child };
                        } else {
                            return closest;
                        }
                    }, { offset: Number.NEGATIVE_INFINITY }).element;
                }
                // --- END: Drag and Drop Logic ---

                const editRankingModalElement = document.getElementById('edit-ranking-modal');
                if (editRankingModalElement) {
                    editRankingModalElement.addEventListener('click', e => {
                        const actionTarget = e.target.closest('[data-action]');
                        if (!actionTarget) return;
                        const action = actionTarget.dataset.action;
                        const toolId = actionTarget.dataset.id;

                        if (action === 'ranking-add-tool') {
                            if (selectedTools.length < 3) {
                                const toolToAdd = aiToolsData.find(t => t.id === toolId);
                                if (toolToAdd) {
                                    selectedTools.push(toolToAdd);
                                    updateUI();
                                    searchInput.value = '';
                                    resultsContainer.innerHTML = '';
                                }
                            } else {
                                showToast("Puoi selezionare al massimo 3 AI.");
                            }
                        } else if (action === 'ranking-remove-tool') {
                            // Prevent click event during a drag operation
                            if (draggedItem) return;
                            selectedTools = selectedTools.filter(t => t.id !== toolId);
                            updateUI();
                        }
                    });
                }
            };

            // Salva le modifiche per una singola classifica
            const handleSaveRanking = async (rankingId) => {
                const isEditing = !!rankingId;
                const t = translations[currentLanguage];

                const data = {
                    title_it: document.getElementById('ranking-title-it').value.trim(),
                    title_en: document.getElementById('ranking-title-en').value.trim(),
                    category: document.getElementById('ranking-category').value.trim(),
                    // 'order' field removed
                    toolIds: Array.from(document.querySelectorAll('#ranking-selected-tools .tool-list-item')).map(el => el.dataset.id)
                };

                if (!data.title_it || !data.title_en || !data.category || data.toolIds.length === 0) {
                    showToast("Tutti i campi sono obbligatori.");
                    return;
                }

                try {
                    if (isEditing) {
                        const rankingDocRef = doc(db, "rankings", rankingId);
                        await updateDoc(rankingDocRef, data);
                    } else {
                        const rankingsCollectionRef = collection(db, "rankings");
                        await addDoc(rankingsCollectionRef, data);
                    }
                    showToast(`Classifica ${isEditing ? 'aggiornata' : 'creata'} con successo!`);
                    closeModal();
                    [aiRankingsData] = await Promise.all([fetchRankingsFromFirestore()]);
                    renderView();
                } catch (error) {
                    console.error("Errore nel salvataggio della classifica:", error);
                    showToast(`Errore: ${error.message}`);
                }
            };

            // NUOVA FUNZIONE: Apre il modale per la gestione delle funzionalità
            const openFeatureTogglesModal = () => {
                if (currentUser.role !== 'admin') return;
                const t = translations[currentLanguage];

                const modalHTML = `
                <div id="feature-toggles-modal" class="modal-overlay visible">
                    <div class="modal-content add-ai-modal" style="text-align: left;">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <h2>${t.featureToggles}</h2>
                        <div class="add-ai-form">
                            <div class="checkbox-group">
                                <div class="checkbox-wrapper">
                                    <input type="checkbox" id="toggle-chat" ${featureSettings.isChatEnabled ? 'checked' : ''}>
                                    <label for="toggle-chat">${t.enableUserChat}</label>
                                </div>
                            </div>
                             <div class="checkbox-group">
                                <div class="checkbox-wrapper">
                                    <input type="checkbox" id="toggle-reviews" ${featureSettings.isReviewsEnabled ? 'checked' : ''}>
                                    <label for="toggle-reviews">${t.enableReviews}</label>
                                </div>
                            </div>
                             <div class="checkbox-group">
                                <div class="checkbox-wrapper">
                                    <input type="checkbox" id="toggle-ratings" ${featureSettings.isRatingsEnabled ? 'checked' : ''}>
                                    <label for="toggle-ratings">${t.enableRatings}</label>
                                </div>
                            </div>
                            <button class="button" data-action="save-feature-toggles">${t.saveChanges}</button>
                        </div>
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;
            };

            // --- NUOVE FUNZIONI PER GESTIONE ALTERNATIVE (ADMIN) ---

            const openManageAlternativesModal = () => {
                if (currentUser.role !== 'admin') return;
                const t = translations[currentLanguage];

                // Helper to generate the HTML for a single row
                const generateAlternativeRowHTML = (tool) => {
                    const alternative = tool.recommendationId ? aiToolsData.find(t => t.id === tool.recommendationId) : null;

                    let alternativeHTML;
                    if (alternative) {
                        alternativeHTML = `
                            <div class="tool-list-item">
                                <img class="sent-review-tool-logo" src="${alternative.logoUrl}" alt="${alternative.name}">
                                <div class="info"><div class="tool-name">${alternative.name}</div></div>
                            </div>
                            <button class="ranking-action-btn delete" data-action="remove-alternative" data-id="${tool.id}" title="${t.removeAlternative}">${trashIcon}</button>
                        `;
                    } else {
                        alternativeHTML = `<div class="alt-empty-state">${t.noAlternative}</div>`;
                    }

                    return `
                        <div class="alternative-row" data-id="${tool.id}" data-tool-name="${tool.name.toLowerCase()}" data-tool-category="${tool.category}">
                            <div class="main-ai-col">
                                <img class="sent-review-tool-logo" src="${tool.logoUrl}" alt="${tool.name}">
                                <div class="tool-name">${tool.name}</div>
                            </div>
                            <div class="alt-ai-col">
                                ${alternativeHTML}
                                <button class="ranking-action-btn edit" data-action="edit-alternative-inline" data-id="${tool.id}" title="${t.editAlternative}">${smallPencilIcon}</button>
                            </div>
                        </div>
                    `;
                };

                const categoryFiltersHTML = `
                <div class="filter-pills" id="alternative-category-filters" style="margin-top: 16px; padding-bottom: 8px;">
                    <button class="pill-btn active" data-action="set-alternative-filter" data-category="All">${t.filterAll}</button>
                    ${categories.map(cat => `<button class="pill-btn" data-action="set-alternative-filter" data-category="${cat.id}">${getTranslatedCategoryName(cat.id)}</button>`).join('')}
                </div>`;

                const modalHTML = `
                <div id="manage-alternatives-modal" class="modal-overlay visible">
                    <div class="modal-content add-ai-modal" style="text-align: left; max-width: 800px;">
                        <button class="modal-close-btn" data-action="close-modal">×</button>
                        <h2>${t.manageAlternatives}</h2>
                        <div class="input-group" style="margin-top: 24px;">
                            <input type="text" id="alternative-main-search" class="chat-search-input" placeholder="${t.searchMainAI}">
                        </div>
                        ${categoryFiltersHTML}
                        <div id="alternatives-tool-list" class="list-container" style="max-height: 55vh; overflow-y: auto; margin-top: 8px;">
                            ${aiToolsData.sort((a, b) => a.name.localeCompare(b.name)).map(generateAlternativeRowHTML).join('')}
                        </div>
                    </div>
                </div>`;
                el.modalContainer.innerHTML = modalHTML;

                // --- Filtering Logic ---
                const searchInput = document.getElementById('alternative-main-search');
                const categoryFiltersContainer = document.getElementById('alternative-category-filters');
                const toolListContainer = document.getElementById('alternatives-tool-list');
                let currentCategoryFilter = 'All';

                const applyFilters = () => {
                    const searchTerm = searchInput.value.toLowerCase();
                    toolListContainer.querySelectorAll('.alternative-row').forEach(item => {
                        const matchesCategory = currentCategoryFilter === 'All' || item.dataset.toolCategory === currentCategoryFilter;
                        const matchesSearch = item.dataset.toolName.includes(searchTerm);
                        item.style.display = (matchesCategory && matchesSearch) ? 'flex' : 'none';
                    });
                };

                searchInput.addEventListener('input', applyFilters);

                categoryFiltersContainer.addEventListener('click', (e) => {
                    const filterBtn = e.target.closest('[data-action="set-alternative-filter"]');
                    if (filterBtn) {
                        currentCategoryFilter = filterBtn.dataset.category;
                        categoryFiltersContainer.querySelectorAll('.pill-btn').forEach(btn => btn.classList.remove('active'));
                        filterBtn.classList.add('active');
                        applyFilters();
                    }
                });
            };

            const enterAlternativeEditMode = (mainToolId, rowElement) => {
                const altCol = rowElement.querySelector('.alt-ai-col');
                if (!altCol || altCol.dataset.editing === 'true') return;

                altCol.dataset.editing = 'true';
                altCol.dataset.originalHtml = altCol.innerHTML;
                const t = translations[currentLanguage];

                altCol.innerHTML = `
                    <div class="edit-mode-container">
                        <input type="text" class="chat-search-input" placeholder="${t.searchNewAlternative}" id="inline-alt-search-${mainToolId}">
                        <div class="list-container" id="inline-alt-results-${mainToolId}" style="max-height: 150px; overflow-y: auto;"></div>
                    </div>
                    <button class="ranking-action-btn" data-action="cancel-alternative-edit" title="${t.cancel}">×</button>
                `;

                const searchInput = document.getElementById(`inline-alt-search-${mainToolId}`);
                const resultsContainer = document.getElementById(`inline-alt-results-${mainToolId}`);

                searchInput.focus();
                searchInput.addEventListener('input', () => {
                    const searchTerm = searchInput.value.toLowerCase();
                    if (searchTerm.length < 2) {
                        resultsContainer.innerHTML = ''; return;
                    }
                    const filteredTools = aiToolsData.filter(tool => tool.id !== mainToolId && tool.name.toLowerCase().includes(searchTerm));
                    resultsContainer.innerHTML = filteredTools.slice(0, 5).map(tool => `
                        <div class="tool-list-item" data-action="update-alternative" data-main-id="${mainToolId}" data-alt-id="${tool.id}" style="cursor: pointer;">
                            <img class="sent-review-tool-logo" src="${tool.logoUrl}" alt="${tool.name}"><div class="info"><div class="tool-name">${tool.name}</div></div>
                        </div>
                    `).join('');
                });
            };

            const handleUpdateAlternative = async (mainToolId, alternativeToolId) => {
                const t = translations[currentLanguage];
                try {
                    const toolDocRef = doc(db, "tools", mainToolId);
                    await updateDoc(toolDocRef, { recommendationId: alternativeToolId });

                    const toolIndex = aiToolsData.findIndex(t => t.id === mainToolId);
                    if (toolIndex !== -1) aiToolsData[toolIndex].recommendationId = alternativeToolId;

                    showToast(t.alternativeUpdated);

                    // Update UI inline instead of reloading
                    const rowToUpdate = document.querySelector(`.alternative-row[data-id="${mainToolId}"]`);
                    const altColToUpdate = rowToUpdate.querySelector('.alt-ai-col');
                    const newAlternative = aiToolsData.find(t => t.id === alternativeToolId);
                    altColToUpdate.innerHTML = `
                        <div class="tool-list-item">
                            <img class="sent-review-tool-logo" src="${newAlternative.logoUrl}" alt="${newAlternative.name}">
                            <div class="info"><div class="tool-name">${newAlternative.name}</div></div>
                        </div>
                        <button class="ranking-action-btn delete" data-action="remove-alternative" data-id="${mainToolId}" title="${t.removeAlternative}">${trashIcon}</button>
                        <button class="ranking-action-btn edit" data-action="edit-alternative-inline" data-id="${mainToolId}" title="${t.editAlternative}">${smallPencilIcon}</button>
                    `;
                } catch (error) {
                    console.error("Error updating alternative:", error);
                    showToast(t.errorUpdatingAlternative);
                }
            };

            const handleRemoveAlternative = async (mainToolId) => {
                const t = translations[currentLanguage];
                try {
                    const toolDocRef = doc(db, "tools", mainToolId);
                    await updateDoc(toolDocRef, { recommendationId: null });

                    const toolIndex = aiToolsData.findIndex(t => t.id === mainToolId);
                    if (toolIndex !== -1) delete aiToolsData[toolIndex].recommendationId;

                    showToast(t.alternativeRemoved);

                    // Update UI inline
                    const rowToUpdate = document.querySelector(`.alternative-row[data-id="${mainToolId}"]`);
                    const altColToUpdate = rowToUpdate.querySelector('.alt-ai-col');
                    altColToUpdate.innerHTML = `
                        <div class="alt-empty-state">${t.noAlternative}</div>
                        <button class="ranking-action-btn edit" data-action="edit-alternative-inline" data-id="${mainToolId}" title="${t.editAlternative}">${smallPencilIcon}</button>
                    `;
                } catch (error) {
                    console.error("Error removing alternative:", error);
                    showToast(t.errorUpdatingAlternative);
                }
            };


            // NUOVA FUNZIONE: Salva le impostazioni delle funzionalità
            const handleSaveFeatureToggles = async () => {
                if (currentUser.role !== 'admin') return;

                const newSettings = {
                    isChatEnabled: document.getElementById('toggle-chat').checked,
                    isReviewsEnabled: document.getElementById('toggle-reviews').checked,
                    isRatingsEnabled: document.getElementById('toggle-ratings').checked
                };

                try {
                    const settingsDocRef = doc(db, "settings", "featureToggles");
                    await setDoc(settingsDocRef, newSettings); // setDoc sovrascrive il documento
                    featureSettings = newSettings; // Aggiorna lo stato locale
                    showToast("Impostazioni salvate con successo!");
                    closeModal();
                    renderView(); // Ricarica la UI per applicare le modifiche
                } catch (error) {
                    console.error("Errore nel salvataggio delle impostazioni:", error);
                    showToast(`Errore: ${error.message}`);
                }
            };
            // Elimina una classifica
            const handleDeleteRanking = async (rankingId) => {
                const t = translations[currentLanguage];
                if (confirm(t.confirmDeleteRanking)) {
                    try {
                        const rankingDocRef = doc(db, "rankings", rankingId);
                        await deleteDoc(rankingDocRef);
                        showToast("Classifica eliminata con successo!");
                        [aiRankingsData] = await Promise.all([fetchRankingsFromFirestore()]);
                        openManageRankingsModal(); // Riapre il modale di gestione aggiornato
                    } catch (error) {
                        console.error("Errore nell'eliminazione della classifica:", error);
                        showToast(`Errore: ${error.message}`);
                    }
                }
            };
            // NUOVA FUNZIONE: Salva le modifiche dello strumento globale su Firestore
            const handleEditGlobalTool = async (toolId) => {
                console.log('handleEditGlobalTool called with toolId:', toolId);
                if (currentUser.role !== 'admin' || !toolId) {
                    console.log('User is not admin or no toolId, role:', currentUser.role, 'toolId:', toolId);
                    return;
                }

                // Recuperiamo il tool esistente per mantenere i campi non modificabili
                const existingTool = aiToolsData.find(t => t.id === toolId);
                if (!existingTool) {
                    console.log('Tool not found in aiToolsData');
                    showToast("Strumento non trovato.");
                    return;
                }

                const updatedToolData = {
                    id: toolId, // Manteniamo l'ID
                    name: document.getElementById('edit-global-tool-name').value.trim(),
                    description: {
                        it: document.getElementById('edit-global-tool-desc-it').value.trim(),
                        en: document.getElementById('edit-global-tool-desc-en').value.trim()
                    },
                    website: document.getElementById('edit-global-tool-website').value.trim(),
                    logoUrl: document.getElementById('edit-global-tool-logo').value.trim(),
                    category: document.getElementById('edit-global-tool-category').value,
                    country: document.getElementById('edit-global-tool-country').value.trim(),
                    isFeatured: existingTool.isFeatured || false
                };

                // Validazione base
                if (!updatedToolData.name || !updatedToolData.website || !updatedToolData.logoUrl) {
                    showToast("Nome, Sito Web e URL Logo sono obbligatori.");
                    return;
                }

                try {
                    const toolDocRef = doc(db, "tools", toolId);
                    // Usiamo updateDoc per aggiornare il documento esistente
                    await updateDoc(toolDocRef, updatedToolData);

                    showToast("Strumento AI aggiornato con successo!");
                    closeModal();

                    // Ricarica i dati e la vista per mostrare le modifiche
                    aiToolsData = await fetchToolsFromFirestore();
                    renderView();

                } catch (error) {
                    console.error("Errore nell'aggiornamento dello strumento:", error);
                    showToast(`Errore: ${error.message}`);
                }
            };
            // NUOVA FUNZIONE: Salva il nuovo strumento globale su Firestore
            const handleAddGlobalTool = async () => {
                console.log('handleAddGlobalTool called');
                if (currentUser.role !== 'admin') {
                    console.log('User is not admin, role:', currentUser.role);
                    return;
                }

                // Rimosso il tentativo di leggere un ID inesistente.

                const newToolData = {
                    // L'ID non viene più specificato qui. Verrà generato da Firestore.
                    name: document.getElementById('global-tool-name').value.trim(),
                    description: {
                        it: document.getElementById('global-tool-desc-it').value.trim(),
                        en: document.getElementById('global-tool-desc-en').value.trim()
                    },
                    website: document.getElementById('global-tool-website').value.trim(),
                    logoUrl: document.getElementById('global-tool-logo').value.trim(),
                    category: document.getElementById('global-tool-category').value,
                    country: document.getElementById('global-tool-country').value.trim(),
                    isFeatured: false // Valore di default per i nuovi strumenti
                };

                // Validazione base
                if (!newToolData.name || !newToolData.website || !newToolData.logoUrl) {
                    showToast("Nome, Sito Web e URL Logo sono obbligatori.");
                    return;
                }

                try {
                    // Usa addDoc per creare un nuovo documento con un ID generato automaticamente
                    const toolsCollectionRef = collection(db, "tools");
                    await addDoc(toolsCollectionRef, newToolData);

                    showToast("Strumento AI aggiunto con successo al database!");
                    closeModal();

                    // Ricarica i dati e la vista per mostrare il nuovo strumento
                    aiToolsData = await fetchToolsFromFirestore();
                    renderView();

                } catch (error) {
                    console.error("Errore nell'aggiunta dello strumento globale:", error);
                    showToast(`Errore: ${error.message}`);
                }
            };
            window.addEventListener('popstate', (event) => {
                if (event.state && event.state.page) {
                    // If a state exists from a previous pushState, update the view
                    currentView = event.state.page;
                    renderView();
                } else {
                    // If no state is found (e.g., initial page load), default to home
                    currentView = 'home';
                    renderView();
                }
            });

            // --- MAIN EVENT LISTENER ---
            document.body.addEventListener('click', (e) => {
                const target = e.target;

                // 1. Handle navigation buttons FIRST
                const navBtn = target.closest('.nav-btn');
                if (navBtn && navBtn.dataset.page !== currentView) {
                    const newView = navBtn.dataset.page;
                    currentView = newView;

                    // --- INSERT THIS CODE ---
                    const state = { page: newView };
                    const title = ''; // Title is ignored by most browsers
                    const url = `#${newView}`; // Update the URL with a hash
                    history.pushState(state, title, url);
                    // --- END OF INSERTION ---

                    // Reset filters when changing main pages
                    activeFilter = 'All'; exploreFilter = { type: null, value: null }; rankingFilter = 'All'; // Reset all filters
                    renderView();
                    el.mainContent.scrollTop = 0; // Scroll to top on page change
                    e.preventDefault(); // Prevent default link behavior
                    return; // Stop processing
                }




                // 3. Handle elements with data-action (excluding the K button which is handled above)
                const actionTarget = target.closest('[data-action]');
                if (actionTarget && actionTarget.id !== 'privileged-unlock-btn') { // Explicitly exclude K button
                    const action = actionTarget.dataset.action;

                    switch (action) {
                        // NUOVE AZIONI ADMIN
                        case 'open-add-global-tool-modal':
                            openAddGlobalToolModal();
                            break;
                        case 'open-manage-rankings-modal':
                            openManageRankingsModal();
                            break;
                        case 'open-edit-ranking-modal':
                            openEditRankingModal(actionTarget.dataset.id || null);
                            break;
                        case 'save-ranking':
                            handleSaveRanking(actionTarget.dataset.id || null);
                            break;
                        case 'delete-ranking':
                            handleDeleteRanking(actionTarget.dataset.id);
                            break;
                        // AZIONI CATALOGO VIDEO
                        case 'open-video-catalog':
                            openVideoCatalogModal();
                            break;
                        case 'open-add-video-modal':
                            openAddVideoModal();
                            break;
                        case 'submit-video':
                            handleAddVideo();
                            break;
                        case 'watch-youtube-video':
                            const url = actionTarget.dataset.url;
                            if (url) window.open(url, '_blank');
                            break;
                        case 'open-edit-video-modal':
                            openEditVideoModal(actionTarget.dataset.id);
                            break;
                        case 'submit-video-edit':
                            handleUpdateVideo(actionTarget.dataset.id);
                            break;
                        case 'delete-video':
                            handleDeleteVideo(actionTarget.dataset.id);
                            break;
                        case 'save-video-order':
                            handleSaveVideoOrder();
                            break;

                        case 'open-feature-toggles-modal':
                            openFeatureTogglesModal();
                            break;
                        case 'save-feature-toggles':
                            handleSaveFeatureToggles();
                            break;
                        // ADMIN: MANAGE ALTERNATIVES
                        case 'open-manage-alternatives-modal':
                            closeUserProfileDropdown();
                            openManageAlternativesModal();
                            break;
                        case 'edit-alternative-inline':
                            const rowElement = actionTarget.closest('.alternative-row');
                            enterAlternativeEditMode(actionTarget.dataset.id, rowElement);
                            break;
                        case 'cancel-alternative-edit':
                            const rowToCancel = actionTarget.closest('.alternative-row');
                            const altCol = rowToCancel.querySelector('.alt-ai-col');
                            if (altCol.dataset.originalHtml) {
                                altCol.innerHTML = altCol.dataset.originalHtml;
                                delete altCol.dataset.editing;
                                delete altCol.dataset.originalHtml;
                            }
                            break;
                        case 'update-alternative':
                            handleUpdateAlternative(actionTarget.dataset.mainId, actionTarget.dataset.altId);
                            break;
                        case 'remove-alternative':
                            handleRemoveAlternative(actionTarget.dataset.id);
                            break;
                        case 'submit-global-tool':
                            console.log('submit-global-tool action triggered');
                            handleAddGlobalTool();
                            break;
                        case 'open-edit-global-tool-modal':
                            openEditGlobalToolModal(actionTarget.dataset.id);
                            break;
                        case 'submit-edit-global-tool':
                            console.log('submit-edit-global-tool action triggered');
                            handleEditGlobalTool(actionTarget.dataset.id);
                            break;
                        case 'navigate-to-optimizer':
                            const optimizer = document.getElementById('optimizer-overlay');
                            if (optimizer) {
                                optimizer.classList.add('visible');
                                // Blocchiamo lo scroll del body quando l'overlay è attivo
                                document.body.style.overflow = 'hidden';
                            }
                            break;
                        case 'close-optimizer':
                            const optimizerToClose = document.getElementById('optimizer-overlay');
                            if (optimizerToClose) {
                                optimizerToClose.classList.remove('visible');
                                // Ripristiniamo lo scroll del body
                                document.body.style.overflow = '';
                            }
                            break;
                        case 'optimize-prompt':
                            handlePromptOptimization();
                            break;
                        // --- AZIONI PER OPTIMIZER E GALLERIA (NUOVE) ---
                        case 'copy-optimized-prompt':
                            handleCopyOptimizedPrompt();
                            break;
                        case 'save-optimized-prompt':
                            handleSaveOptimizedPrompt();
                            break;
                        case 'show-prompt-gallery':
                            openPromptGalleryModal();
                            break;
                        case 'copy-gallery-prompt':
                            // Chiama la nuova funzione helper per la copia
                            handleCopyFromGallery(actionTarget.dataset.targetId);
                            break;
                        case 'delete-saved-prompt':
                            handleDeleteSavedPrompt(actionTarget.dataset.id);
                            break;
                        case 'execute-delete-saved-prompt': // NUOVA AZIONE
                            executeDeleteSavedPrompt(actionTarget.dataset.id);
                            break;
                        case 'toggle-prompt':
                            // Toggle per aprire/chiudere i prompt
                            const promptItem = actionTarget.closest('.prompt-gallery-item');
                            if (promptItem) {
                                promptItem.classList.toggle('collapsed');
                            }
                            break;
                        // NUOVO: Gestisce il click sull'icona della password
                        case 'toggle-password-visibility':
                            handlePasswordVisibilityToggle(actionTarget);
                            break;
                        // NUOVO: Gestisce i filtri della Libreria
                        case 'set-library-tab':
                            const tab = actionTarget.dataset.tab;
                            if (tab && tab !== libraryTab) {
                                libraryTab = tab;
                                renderView(); // Un re-render completo è il modo più semplice per aggiornare tutto
                            }
                            break;
                        // Global Controls
                        case 'toggle-theme':
                            // Cambia il tema
                            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
                            document.body.classList.toggle('light-mode', currentTheme === 'light');
                            localStorage.setItem('koda-theme', currentTheme);

                            // Aggiorna l'icona del tema manually senza ri-renderizzare tutto
                            const themeBtn = document.getElementById('theme-toggle-btn');
                            if (themeBtn) {
                                themeBtn.innerHTML = currentTheme === 'dark' ? sunIcon : moonIcon;
                            }
                            break;
                        case 'toggle-lang':
                            // Cambia la lingua a livello globale
                            currentLanguage = currentLanguage === 'it' ? 'en' : 'it';
                            localStorage.setItem('koda-lang', currentLanguage);

                            // Aggiorna il testo del pulsante stesso
                            const langBtn = document.getElementById('lang-toggle-btn');
                            if (langBtn) {
                                langBtn.textContent = currentLanguage.toUpperCase();
                            }

                            // Applica le traduzioni agli elementi HTML non gestiti da React
                            applyTranslations(currentLanguage);

                            // **NUOVA LOGICA:** Se siamo nella vista chat e la funzione-ponte esiste,
                            // la usiamo per aggiornare lo stato interno di React senza ricaricare.
                            if (currentView === 'user-chats' && typeof window.updateUserChatLanguage === 'function') {
                                window.updateUserChatLanguage(currentLanguage);
                            } else {
                                // Altrimenti, per tutte le altre pagine, eseguiamo un re-render completo
                                renderView();
                            }
                            break;
                        case 'toggle-menu':
                            toggleSideMenu(true);
                            break;
                        case 'open-settings-modal':
                            if (!currentUser.uid) { triggerAuthFlow(); } else { window.openSettingsModal(); }
                            break;
                        case 'logout':
                            // NUOVO: Imposta lo stato offline prima del logout
                            if (currentUser && currentUser.uid) {
                                updateUserOnlineStatus(currentUser.uid, false);
                            }

                            // NUOVO: Rimuovi i listener di stato
                            if (window.userStatusListeners) {
                                document.removeEventListener('visibilitychange', window.userStatusListeners.visibilitychange);
                                window.removeEventListener('focus', window.userStatusListeners.focus);
                                window.removeEventListener('blur', window.userStatusListeners.blur);
                                window.userStatusListeners = null;
                            }

                            // NUOVO: Pulisci l'interval dello stato online
                            if (window.onlineStatusInterval) {
                                clearInterval(window.onlineStatusInterval);
                                window.onlineStatusInterval = null;
                            }

                            signOut(auth).catch(error => console.error("Logout Error:", error));
                            break; // Rimuovi il logout dal global controls

                        // Side Menu
                        case 'new-chat': startNewChat(); break;
                        case 'delete-all-chats':
                            openConfirmDeleteAllModal(); // Ora apre il modale personalizzato
                            break;
                        case 'confirm-delete-all-chats': // NUOVA AZIONE
                            conversations = {};
                            localStorage.removeItem(getStorageKey());
                            localStorage.removeItem(`activeConversationId_${currentUser.uid || 'guest'}`);
                            startNewChat(true); // Esegue la cancellazione
                            closeModal(); // Chiude il modale di conferma
                            break;
                        case 'select-conversation':
                            const newActiveId = actionTarget.dataset.id;
                            if (newActiveId !== activeConversationId) {
                                activeConversationId = newActiveId;
                                saveActiveConversationId();
                                renderView(); // Re-render with the selected conversation
                            }
                            toggleSideMenu(false); // Close menu
                            break;

                        // Auth Prompts (from Library page)
                        case 'prompt-login': triggerAuthFlow('login-card'); break;
                        case 'prompt-register': triggerAuthFlow('register-card'); break;

                        // Explore/Top AI Filters
                        case 'back-to-explore': exploreFilter = { type: null, value: null }; renderView(); break;
                        case 'set-explore-filter':
                            exploreFilter.type = actionTarget.dataset.filterType;
                            exploreFilter.value = actionTarget.dataset.filterValue;
                            renderView();
                            break;
                        case 'set-ranking-filter':
                            rankingFilter = actionTarget.dataset.filter;
                            renderView(); // Re-render to apply ranking filter
                            break;
                        case 'set-favorite-filter':
                            activeFilter = actionTarget.dataset.filter;
                            renderView(); // Re-render to apply favorite filter
                            break;

                        case 'navigate':
                            const page = actionTarget.dataset.page;
                            if (page && page !== currentView) {
                                currentView = page;
                                renderView();
                            }
                            break;
                        // Modals (Detail, Settings, Add App, Replace Featured)
                        case 'close-modal': closeModal(); break;
                        case 'toggle-favorite': toggleFavorite(actionTarget.dataset.id); break;
                        // NUOVO: Gestione recensioni
                        case 'add-review': openReviewModal(actionTarget.dataset.toolId); break;
                        case 'close-review-modal': closeReviewModal(); break;
                        case 'submit-review': submitReview(); break;
                        case 'open-detail-modal': // For recommendation box in detail modal
                            window.openDetailModal(actionTarget.dataset.id);
                            break;
                        case 'open-add-app-modal':
                            // MODIFICATO: Rimosso il controllo isPrivileged.
                            // Ora qualsiasi utente loggato può aggiungere un'app.
                            if (currentUser.uid) {
                                openAddAppModal();
                            } else {
                                triggerAuthFlow(); // Se non è loggato, chiedi di accedere.
                            }
                            break;
                        case 'open-edit-app-modal':
                            if (currentUser.uid) {
                                openEditAppModal(actionTarget.dataset.id);
                            } else {
                                triggerAuthFlow();
                            }
                            break;
                        case 'toggle-user-featured': // Triggered by pencil on user featured apps in Library
                            // Allow any logged-in user to perform this action
                            if (currentUser.uid) {
                                toggleUserFeatured(actionTarget.dataset.id);
                            } else {
                                triggerAuthFlow();
                            }
                            break;
                        case 'replace-featured-static': // Triggered by pencil on static featured apps in Top AI
                            // Allow any logged-in user to perform this action
                            if (currentUser.uid) {
                                openReplaceFeaturedModal(actionTarget.dataset.id);
                            } else {
                                triggerAuthFlow();
                            }
                            break;
                        case 'select-user-tool-for-featured': // Triggered by clicking a user app in the replace modal
                            // Allow any logged-in user to perform this action
                            if (currentUser.uid) {
                                replaceFeaturedStatic(actionTarget.dataset.staticId, actionTarget.dataset.userId);
                            } else {
                                triggerAuthFlow();
                            }
                            break;
                        case 'remove-user-tool': // Triggered by pencil on user apps in the main Library list
                            // Allow any logged-in user to perform this action
                            if (currentUser.uid) {
                                removeUserTool(actionTarget.dataset.id);
                            } else {
                                triggerAuthFlow();
                            }
                            break;
                        case 'add-ai-suggestion': // Triggered by add AI suggestion button
                            console.log('add-ai-suggestion action triggered');
                            if (currentUser.uid) {
                                console.log('User logged in, calling addAiSuggestion');
                                window.addAiSuggestion();
                            } else {
                                console.log('No user logged in, triggering auth flow');
                                triggerAuthFlow();
                            }
                            break;
                        case 'remove-ai-suggestion': // Triggered by remove AI suggestion button
                            if (currentUser.uid) {
                                removeAiSuggestion(actionTarget.dataset.id);
                            } else {
                                triggerAuthFlow();
                            }
                            break;
                        case 'search-users': // Triggered by search users button
                            if (currentUser.uid) {
                                searchUsers();
                            } else {
                                triggerAuthFlow();
                            }
                            break;
                        case 'view-user-suggestions': // Triggered by view suggestions button
                            if (currentUser.uid) {
                                viewUserSuggestions(actionTarget.dataset.uid, actionTarget.dataset.nickname);
                            } else {
                                triggerAuthFlow();
                            }
                            break;
                        case 'start-user-chat': // Triggered by start chat button
                            if (currentUser.uid) {
                                startUserChat(actionTarget.dataset.uid, actionTarget.dataset.nickname);
                            } else {
                                triggerAuthFlow();
                            }
                            break;


                        // Auth Overlay actions are handled by attachAuthListeners on the overlay itself
                        case 'close-auth': // Handled by attachAuthListeners
                        case 'show-login': // Handled by attachAuthListeners
                        case 'show-register': // Handled by attachAuthListeners
                        case 'show-forgot': // Handled by attachAuthListeners
                            // Let the specific auth overlay listener handle these
                            return;
                        case 'profile-avatar-click':
                            if (!currentUser.uid) {
                                triggerAuthFlow('register-card');
                            } else {
                                toggleUserProfileDropdown();
                            }
                            break;
                        case 'open-settings':
                            closeUserProfileDropdown();
                            window.openSettingsModal();
                            break;
                        case 'change-nickname':
                            closeUserProfileDropdown();
                            openChangeNicknameModal();
                            break;
                        case 'change-password':
                            closeUserProfileDropdown();
                            openChangePasswordModal();
                            break;
                        case 'view-sent-reviews':
                            closeUserProfileDropdown();
                            openSentReviewsModal();
                            break;
                        case 'view-all-user-reviews':
                            const toolId = actionTarget.dataset.toolId;
                            if (toolId) {
                                openAllUserReviewsModal(toolId);
                            }
                            break;
                        case 'edit-review':
                            const editToolId = actionTarget.dataset.toolId;
                            const editReviewId = actionTarget.dataset.reviewId;
                            if (editToolId && editReviewId) {
                                openEditReviewModal(editToolId, editReviewId);
                            }
                            break;
                        case 'delete-review':
                            const deleteToolId = actionTarget.dataset.toolId;
                            const deleteReviewId = actionTarget.dataset.reviewId;
                            if (deleteToolId && deleteReviewId) {
                                confirmDeleteReview(deleteToolId, deleteReviewId);
                            }
                            break;
                        case 'logout':
                            closeUserProfileDropdown();
                            handleLogout(); // Usa la nuova funzione centralizzata
                            break;
                    }
                    // Prevent default for any element with data-action
                    e.preventDefault();
                    return; // Stop processing after handling a data-action
                }

                // 4. Handle clicks on tool/ranking cards (excluding favorite icon and edit icon which have data-actions)
                const toolCard = target.closest('.tool-card-grid, .tool-card-list, .ranking-item, .tool-item-horizontal, .tool-shelf-item');
                if (toolCard && !target.closest('.favorite-icon') && !target.closest('.edit-icon')) {
                    window.openDetailModal(toolCard.dataset.id);
                    return;
                }

                // 5. Handle clicks outside side menu/modals to close them
                if (target.id === 'side-menu-overlay') { toggleSideMenu(false); return; }
                if (target.matches('.modal-overlay')) { closeModal(); return; }

                // 6. Close user profile dropdown when clicking outside
                closeUserProfileDropdown();

                // If none of the above were clicked, let the default behavior happen
            });

            // NUOVO: Event listeners per le stelle del rating
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('star-input')) {
                    const rating = parseInt(e.target.dataset.rating);
                    // Check if we're in edit mode
                    if (document.getElementById('edit-review-modal')) {
                        window.currentEditRating = rating;
                        const starsInput = document.querySelectorAll('.star-input');
                        starsInput.forEach((star, index) => {
                            star.classList.toggle('active', index < rating);
                        });
                    } else {
                        setRating(rating);
                    }
                }
            });

            // NUOVO: Event listener per chiudere il modal delle recensioni cliccando fuori
            document.addEventListener('click', (e) => {
                const reviewModal = document.getElementById('review-modal');
                if (e.target === reviewModal) {
                    closeReviewModal();
                }
            });

            const getExploreFeedHTML = () => {
                const t = translations[currentLanguage];
                const toolsByCategory = {};
                const allTools = getAllToolsForCurrentUser();
                allTools.forEach(tool => {
                    const category = tool.category;
                    if (!toolsByCategory[category]) {
                        toolsByCategory[category] = [];
                    }
                    toolsByCategory[category].push(tool);
                });

                let feedHTML = '';
                categories.forEach(category => {
                    const categoryId = category.id;
                    const categoryName = getTranslatedCategoryName(categoryId);
                    const tools = toolsByCategory[categoryId] || [];

                    if (tools.length > 0) {
                        const seeAllText = (t && t.browseAll) ? t.browseAll : 'Vedi tutti';
                        feedHTML += `
                        <div class="feed-section">
                            <div class="feed-section-header">
                                <h2 class="feed-section-title">${categoryName}</h2>
                                <button class="see-all-btn" data-action="set-explore-filter" data-filter-type="category" data-filter-value="${categoryId}">
                                    ${seeAllText} >
                                </button>
                            </div>
                            <div class="horizontal-scroll-container">
                                ${tools.map(tool => `
                                    <div class="tool-item-horizontal" data-id="${tool.id}">
                                        <div class="tool-item-logo-container">
                                            <img src="${tool.logoUrl}" class="tool-logo" alt="${tool.name}" loading="lazy">
                                        </div>
                                        <div class="tool-item-name">${tool.name}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    }
                });
                return feedHTML;
            };

            // --- SEARCH INPUT LISTENER ---
            el.mainContent.addEventListener('input', e => {
                if (e.target.id === 'search-input') {
                    const searchTerm = e.target.value.toLowerCase();
                    const contentArea = document.getElementById('content-area');
                    if (!contentArea) return;

                    const allTools = getAllToolsForCurrentUser(); // Search across all tools
                    const t = translations[currentLanguage];

                    if (searchTerm.length > 1) {
                        const toolsToShow = allTools.filter(tool =>
                            tool.name.toLowerCase().includes(searchTerm) ||
                            (typeof tool.description === 'string' ? tool.description.toLowerCase().includes(searchTerm) : (typeof tool.description === 'object' ? (tool.description[currentLanguage] || tool.description['en'] || '').toLowerCase().includes(searchTerm) : false))
                        );

                        // Pass context 'explore' to createListCard for search results
                        contentArea.innerHTML = toolsToShow.length > 0 ? `<div class="list-container">${toolsToShow.map(tool => createListCard(tool, 'explore')).join('')}</div>` : `<div id="empty-state">${t.noResultsFor} "${searchTerm}"</div>`;
                    } else {
                        // If search term is cleared, restore the original feed view WITHOUT a full re-render
                        contentArea.innerHTML = getExploreFeedHTML();
                    }
                    applyTranslations(currentLanguage); // Apply translations to search results/empty state
                }
            });

            // Add event listener for user search input
            el.mainContent.addEventListener('input', e => {
                if (e.target.id === 'user-search-input') {
                    const searchTerm = e.target.value.trim();
                    const searchResults = document.getElementById('user-search-results');
                    if (!searchResults) return;

                    // Clear previous timeout
                    if (searchTimeout) {
                        clearTimeout(searchTimeout);
                    }

                    if (searchTerm.length > 1) {
                        // Debounce search to avoid too many Firebase calls
                        searchTimeout = setTimeout(() => {
                            searchUsersByTerm(searchTerm);
                        }, 300);
                    } else {
                        searchResults.innerHTML = '';
                    }
                }
            });

            // --- FIREBASE AUTH STATE CHANGE LISTENER ---
            onAuthStateChanged(auth, async (user) => { // Aggiungi "async" qui
                // --- INSERT THIS CODE ---
                // Check the URL hash to set the initial view
                const initialHash = window.location.hash.substring(1); // e.g., 'explore' from '#explore'
                const validPages = ['home', 'top-ai', 'explore', 'user-chats', 'favorites']; // Add any other valid page keys here

                if (initialHash && validPages.includes(initialHash)) {
                    currentView = initialHash;
                } else {
                    // Default to home view if hash is missing or invalid
                    currentView = 'home';
                    // Use replaceState to set the initial history entry without creating a new one
                    history.replaceState({ page: 'home' }, '', '#home');
                }
                // --- END OF INSERTION ---
                // Carica tutti i dati di configurazione da Firestore PRIMA di inizializzare l'app
                [aiToolsData, aiRankingsData, featureSettings, youtubeVideosData] = await Promise.all([
                    fetchToolsFromFirestore(),
                    fetchRankingsFromFirestore(),
                    fetchFeatureSettings(),
                    fetchVideosFromFirestore() // NUOVA CHIAMATA
                ]);

                if (user) {
                    // L'utente è loggato, avvia l'app con i suoi dati.
                    console.log("User is logged in:", user.uid);
                    initializeAppWithUser(user); // Funzione già esistente, la usiamo qui

                    // NUOVO: Imposta lo stato online quando l'utente si autentica
                    updateUserOnlineStatus(user.uid, true);

                    // NUOVO: Aggiungi listener per la visibilità della pagina e focus della finestra
                    const handleVisibilityChange = () => {
                        if (document.visibilityState === 'visible') {
                            updateUserOnlineStatus(user.uid, true);
                        }
                    };

                    const handleWindowFocus = () => {
                        updateUserOnlineStatus(user.uid, true);
                    };

                    const handleWindowBlur = () => {
                        // Non impostare subito offline, aspetta un po' per evitare falsi positivi
                        setTimeout(() => {
                            if (document.visibilityState === 'hidden') {
                                updateUserOnlineStatus(user.uid, false);
                            }
                        }, 30000); // 30 secondi di delay
                    };

                    // Aggiungi gli event listener
                    document.addEventListener('visibilitychange', handleVisibilityChange);
                    window.addEventListener('focus', handleWindowFocus);
                    window.addEventListener('blur', handleWindowBlur);

                    // Salva i listener per poterli rimuovere al logout
                    window.userStatusListeners = {
                        visibilitychange: handleVisibilityChange,
                        focus: handleWindowFocus,
                        blur: handleWindowBlur
                    };

                    // NUOVO: Aggiorna lo stato online ogni 30 secondi quando l'utente è attivo
                    window.onlineStatusInterval = setInterval(() => {
                        if (document.visibilityState === 'visible') {
                            updateUserOnlineStatus(user.uid, true);
                        }
                    }, 30000); // 30 secondi - più responsivo

                } else {
                    // L'utente non è loggato (o ha fatto logout), avvia l'app in modalità ospite.
                    console.log("User is a guest or logged out.");

                    // NUOVO: Rimuovi i listener di stato se esistono
                    if (window.userStatusListeners) {
                        document.removeEventListener('visibilitychange', window.userStatusListeners.visibilitychange);
                        window.removeEventListener('focus', window.userStatusListeners.focus);
                        window.removeEventListener('blur', window.userStatusListeners.blur);
                        window.userStatusListeners = null;
                    }

                    // NUOVO: Pulisci l'interval dello stato online
                    if (window.onlineStatusInterval) {
                        clearInterval(window.onlineStatusInterval);
                        window.onlineStatusInterval = null;
                    }

                    initializeAppForGuest();
                }
            });

        });
    </script>

    <!-- Modal per aggiungere recensioni -->
    <div id="review-modal" class="review-modal">
        <div class="review-modal-content">
            <div class="review-modal-header">
                <h3 class="review-modal-title">Aggiungi Recensione</h3>
                <button class="review-modal-close" data-action="close-review-modal">×</button>
            </div>
            <div class="rating-input-container">
                <label class="rating-input-label">Valutazione</label>
                <div class="stars-input">
                    <span class="star-input" data-rating="1">★</span>
                    <span class="star-input" data-rating="2">★</span>
                    <span class="star-input" data-rating="3">★</span>
                    <span class="star-input" data-rating="4">★</span>
                    <span class="star-input" data-rating="5">★</span>
                </div>
            </div>
            <div class="review-text-container">
                <label class="review-text-label">Recensione</label>
                <textarea class="review-text-input" placeholder="Scrivi la tua recensione qui..."
                    maxlength="500"></textarea>
            </div>
            <div class="review-modal-actions">
                <button class="review-cancel-btn" data-action="close-review-modal">Annulla</button>
                <button class="review-submit-btn" data-action="submit-review">Pubblica Recensione</button>
            </div>
        </div>
    </div>
</body>

</html>
